impl serde::Serialize for AccountData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.open_id.is_some() {
            len += 1;
        }
        if self.sdk_type.is_some() {
            len += 1;
        }
        if self.account_id.is_some() {
            len += 1;
        }
        if self.account_uuid.is_some() {
            len += 1;
        }
        if self.os.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AccountData", len)?;
        if let Some(v) = self.open_id.as_ref() {
            struct_ser.serialize_field("OpenId", v)?;
        }
        if let Some(v) = self.sdk_type.as_ref() {
            struct_ser.serialize_field("SdkType", v)?;
        }
        if let Some(v) = self.account_id.as_ref() {
            struct_ser.serialize_field("AccountId", v)?;
        }
        if let Some(v) = self.account_uuid.as_ref() {
            struct_ser.serialize_field("AccountUuid", v)?;
        }
        if let Some(v) = self.os.as_ref() {
            let v = SystemType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Os", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AccountData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OpenId",
            "SdkType",
            "AccountId",
            "AccountUuid",
            "Os",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OpenId,
            SdkType,
            AccountId,
            AccountUuid,
            Os,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "OpenId" => Ok(GeneratedField::OpenId),
                            "SdkType" => Ok(GeneratedField::SdkType),
                            "AccountId" => Ok(GeneratedField::AccountId),
                            "AccountUuid" => Ok(GeneratedField::AccountUuid),
                            "Os" => Ok(GeneratedField::Os),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AccountData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AccountData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AccountData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut open_id__ = None;
                let mut sdk_type__ = None;
                let mut account_id__ = None;
                let mut account_uuid__ = None;
                let mut os__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OpenId => {
                            if open_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OpenId"));
                            }
                            open_id__ = map_.next_value()?;
                        }
                        GeneratedField::SdkType => {
                            if sdk_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SdkType"));
                            }
                            sdk_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AccountId => {
                            if account_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccountId"));
                            }
                            account_id__ = map_.next_value()?;
                        }
                        GeneratedField::AccountUuid => {
                            if account_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccountUuid"));
                            }
                            account_uuid__ = map_.next_value()?;
                        }
                        GeneratedField::Os => {
                            if os__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Os"));
                            }
                            os__ = map_.next_value::<::std::option::Option<SystemType>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(AccountData {
                    open_id: open_id__,
                    sdk_type: sdk_type__,
                    account_id: account_id__,
                    account_uuid: account_uuid__,
                    os: os__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AccountData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AccumulateEnd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_uuid.is_some() {
            len += 1;
        }
        if self.end_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AccumulateEnd", len)?;
        if let Some(v) = self.skill_uuid.as_ref() {
            struct_ser.serialize_field("SkillUuid", v)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("EndTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AccumulateEnd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillUuid",
            "EndTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillUuid,
            EndTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillUuid" => Ok(GeneratedField::SkillUuid),
                            "EndTime" => Ok(GeneratedField::EndTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AccumulateEnd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AccumulateEnd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AccumulateEnd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_uuid__ = None;
                let mut end_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillUuid => {
                            if skill_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillUuid"));
                            }
                            skill_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EndTime"));
                            }
                            end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(AccumulateEnd {
                    skill_uuid: skill_uuid__,
                    end_time: end_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AccumulateEnd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Achievement {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.finish_num.is_some() {
            len += 1;
        }
        if self.has_received.is_some() {
            len += 1;
        }
        if self.begin_progress.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Achievement", len)?;
        if let Some(v) = self.finish_num.as_ref() {
            struct_ser.serialize_field("FinishNum", v)?;
        }
        if let Some(v) = self.has_received.as_ref() {
            struct_ser.serialize_field("HasReceived", v)?;
        }
        if let Some(v) = self.begin_progress.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BeginProgress", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Achievement {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FinishNum",
            "HasReceived",
            "BeginProgress",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FinishNum,
            HasReceived,
            BeginProgress,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FinishNum" => Ok(GeneratedField::FinishNum),
                            "HasReceived" => Ok(GeneratedField::HasReceived),
                            "BeginProgress" => Ok(GeneratedField::BeginProgress),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Achievement;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Achievement")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Achievement, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut finish_num__ = None;
                let mut has_received__ = None;
                let mut begin_progress__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FinishNum => {
                            if finish_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FinishNum"));
                            }
                            finish_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HasReceived => {
                            if has_received__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HasReceived"));
                            }
                            has_received__ = map_.next_value()?;
                        }
                        GeneratedField::BeginProgress => {
                            if begin_progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeginProgress"));
                            }
                            begin_progress__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Achievement {
                    finish_num: finish_num__,
                    has_received: has_received__,
                    begin_progress: begin_progress__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Achievement", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ActionInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.action_id.is_some() {
            len += 1;
        }
        if self.period.is_some() {
            len += 1;
        }
        if self.percent.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ActionInfo", len)?;
        if let Some(v) = self.action_id.as_ref() {
            struct_ser.serialize_field("ActionId", v)?;
        }
        if let Some(v) = self.period.as_ref() {
            struct_ser.serialize_field("Period", v)?;
        }
        if let Some(v) = self.percent.as_ref() {
            struct_ser.serialize_field("Percent", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ActionInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ActionId",
            "Period",
            "Percent",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ActionId,
            Period,
            Percent,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ActionId" => Ok(GeneratedField::ActionId),
                            "Period" => Ok(GeneratedField::Period),
                            "Percent" => Ok(GeneratedField::Percent),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ActionInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ActionInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ActionInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut action_id__ = None;
                let mut period__ = None;
                let mut percent__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ActionId => {
                            if action_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActionId"));
                            }
                            action_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Period => {
                            if period__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Period"));
                            }
                            period__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Percent => {
                            if percent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Percent"));
                            }
                            percent__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ActionInfo {
                    action_id: action_id__,
                    period: period__,
                    percent: percent__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ActionInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ActorBodyPartInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.part_id.is_some() {
            len += 1;
        }
        if self.hp.is_some() {
            len += 1;
        }
        if self.max_hp.is_some() {
            len += 1;
        }
        if self.state.is_some() {
            len += 1;
        }
        if self.fleshy_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ActorBodyPartInfo", len)?;
        if let Some(v) = self.part_id.as_ref() {
            struct_ser.serialize_field("PartId", v)?;
        }
        if let Some(v) = self.hp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Hp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.max_hp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("MaxHp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.state.as_ref() {
            let v = BodyPartState::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("State", &v)?;
        }
        if let Some(v) = self.fleshy_id.as_ref() {
            struct_ser.serialize_field("FleshyId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ActorBodyPartInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PartId",
            "Hp",
            "MaxHp",
            "State",
            "FleshyId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PartId,
            Hp,
            MaxHp,
            State,
            FleshyId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PartId" => Ok(GeneratedField::PartId),
                            "Hp" => Ok(GeneratedField::Hp),
                            "MaxHp" => Ok(GeneratedField::MaxHp),
                            "State" => Ok(GeneratedField::State),
                            "FleshyId" => Ok(GeneratedField::FleshyId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ActorBodyPartInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ActorBodyPartInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ActorBodyPartInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut part_id__ = None;
                let mut hp__ = None;
                let mut max_hp__ = None;
                let mut state__ = None;
                let mut fleshy_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PartId => {
                            if part_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartId"));
                            }
                            part_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Hp => {
                            if hp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Hp"));
                            }
                            hp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxHp => {
                            if max_hp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaxHp"));
                            }
                            max_hp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("State"));
                            }
                            state__ = map_.next_value::<::std::option::Option<BodyPartState>>()?.map(|x| x as i32);
                        }
                        GeneratedField::FleshyId => {
                            if fleshy_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FleshyId"));
                            }
                            fleshy_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ActorBodyPartInfo {
                    part_id: part_id__,
                    hp: hp__,
                    max_hp: max_hp__,
                    state: state__,
                    fleshy_id: fleshy_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ActorBodyPartInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ActorBodyPartInfos {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if !self.infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ActorBodyPartInfos", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if !self.infos.is_empty() {
            struct_ser.serialize_field("Infos", &self.infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ActorBodyPartInfos {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "Infos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            Infos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "Infos" => Ok(GeneratedField::Infos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ActorBodyPartInfos;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ActorBodyPartInfos")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ActorBodyPartInfos, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Infos => {
                            if infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Infos"));
                            }
                            infos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ActorBodyPartInfos {
                    uuid: uuid__,
                    infos: infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ActorBodyPartInfos", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ActorUuidStru {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.actor_type.is_some() {
            len += 1;
        }
        if self.is_summon.is_some() {
            len += 1;
        }
        if self.instance_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ActorUuidStru", len)?;
        if let Some(v) = self.actor_type.as_ref() {
            struct_ser.serialize_field("ActorType", v)?;
        }
        if let Some(v) = self.is_summon.as_ref() {
            struct_ser.serialize_field("IsSummon", v)?;
        }
        if let Some(v) = self.instance_id.as_ref() {
            struct_ser.serialize_field("InstanceId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ActorUuidStru {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ActorType",
            "IsSummon",
            "InstanceId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ActorType,
            IsSummon,
            InstanceId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ActorType" => Ok(GeneratedField::ActorType),
                            "IsSummon" => Ok(GeneratedField::IsSummon),
                            "InstanceId" => Ok(GeneratedField::InstanceId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ActorUuidStru;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ActorUuidStru")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ActorUuidStru, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut actor_type__ = None;
                let mut is_summon__ = None;
                let mut instance_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ActorType => {
                            if actor_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActorType"));
                            }
                            actor_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsSummon => {
                            if is_summon__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsSummon"));
                            }
                            is_summon__ = map_.next_value()?;
                        }
                        GeneratedField::InstanceId => {
                            if instance_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InstanceId"));
                            }
                            instance_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ActorUuidStru {
                    actor_type: actor_type__,
                    is_summon: is_summon__,
                    instance_id: instance_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ActorUuidStru", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AffixData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.affix_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AffixData", len)?;
        if !self.affix_ids.is_empty() {
            struct_ser.serialize_field("AffixIds", &self.affix_ids)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AffixData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AffixIds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AffixIds,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AffixIds" => Ok(GeneratedField::AffixIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AffixData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AffixData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AffixData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut affix_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AffixIds => {
                            if affix_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AffixIds"));
                            }
                            affix_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(AffixData {
                    affix_ids: affix_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AffixData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AiBotActiveTrigger {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.active_trigger_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AiBotActiveTrigger", len)?;
        if let Some(v) = self.active_trigger_param.as_ref() {
            struct_ser.serialize_field("ActiveTriggerParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AiBotActiveTrigger {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ActiveTriggerParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ActiveTriggerParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ActiveTriggerParam" => Ok(GeneratedField::ActiveTriggerParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AiBotActiveTrigger;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AiBotActiveTrigger")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AiBotActiveTrigger, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut active_trigger_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ActiveTriggerParam => {
                            if active_trigger_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActiveTriggerParam"));
                            }
                            active_trigger_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AiBotActiveTrigger {
                    active_trigger_param: active_trigger_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AiBotActiveTrigger", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AiBotAddBuffByConfigId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.add_buff_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AiBotAddBuffByConfigId", len)?;
        if let Some(v) = self.add_buff_param.as_ref() {
            struct_ser.serialize_field("AddBuffParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AiBotAddBuffByConfigId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AddBuffParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AddBuffParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AddBuffParam" => Ok(GeneratedField::AddBuffParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AiBotAddBuffByConfigId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AiBotAddBuffByConfigId")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AiBotAddBuffByConfigId, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut add_buff_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AddBuffParam => {
                            if add_buff_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AddBuffParam"));
                            }
                            add_buff_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AiBotAddBuffByConfigId {
                    add_buff_param: add_buff_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AiBotAddBuffByConfigId", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AiBotMove {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.move_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AiBotMove", len)?;
        if let Some(v) = self.move_param.as_ref() {
            struct_ser.serialize_field("MoveParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AiBotMove {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MoveParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MoveParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MoveParam" => Ok(GeneratedField::MoveParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AiBotMove;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AiBotMove")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AiBotMove, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut move_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MoveParam => {
                            if move_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MoveParam"));
                            }
                            move_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AiBotMove {
                    move_param: move_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AiBotMove", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AiBotPlayAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.play_action_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AiBotPlayAction", len)?;
        if let Some(v) = self.play_action_param.as_ref() {
            struct_ser.serialize_field("PlayActionParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AiBotPlayAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PlayActionParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PlayActionParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PlayActionParam" => Ok(GeneratedField::PlayActionParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AiBotPlayAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AiBotPlayAction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AiBotPlayAction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut play_action_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PlayActionParam => {
                            if play_action_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayActionParam"));
                            }
                            play_action_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AiBotPlayAction {
                    play_action_param: play_action_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AiBotPlayAction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AiBotRemoveBuffByConfigId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.remove_buff_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AiBotRemoveBuffByConfigId", len)?;
        if let Some(v) = self.remove_buff_param.as_ref() {
            struct_ser.serialize_field("RemoveBuffParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AiBotRemoveBuffByConfigId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RemoveBuffParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RemoveBuffParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RemoveBuffParam" => Ok(GeneratedField::RemoveBuffParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AiBotRemoveBuffByConfigId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AiBotRemoveBuffByConfigId")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AiBotRemoveBuffByConfigId, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut remove_buff_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RemoveBuffParam => {
                            if remove_buff_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RemoveBuffParam"));
                            }
                            remove_buff_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AiBotRemoveBuffByConfigId {
                    remove_buff_param: remove_buff_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AiBotRemoveBuffByConfigId", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AiBotResurrection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AiBotResurrection", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AiBotResurrection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AiBotResurrection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AiBotResurrection")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AiBotResurrection, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AiBotResurrection {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AiBotResurrection", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AiBotSendChitChatMsg {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AiBotSendChitChatMsg", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AiBotSendChitChatMsg {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AiBotSendChitChatMsg;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AiBotSendChitChatMsg")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AiBotSendChitChatMsg, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AiBotSendChitChatMsg {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AiBotSendChitChatMsg", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AiBotSendGmMsg {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.msg.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AiBotSendGmMsg", len)?;
        if let Some(v) = self.msg.as_ref() {
            struct_ser.serialize_field("Msg", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AiBotSendGmMsg {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Msg",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Msg,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Msg" => Ok(GeneratedField::Msg),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AiBotSendGmMsg;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AiBotSendGmMsg")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AiBotSendGmMsg, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut msg__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Msg => {
                            if msg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Msg"));
                            }
                            msg__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AiBotSendGmMsg {
                    msg: msg__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AiBotSendGmMsg", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AiBotStartRide {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.start_ride_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AiBotStartRide", len)?;
        if let Some(v) = self.start_ride_param.as_ref() {
            struct_ser.serialize_field("StartRideParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AiBotStartRide {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "StartRideParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StartRideParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "StartRideParam" => Ok(GeneratedField::StartRideParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AiBotStartRide;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AiBotStartRide")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AiBotStartRide, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut start_ride_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StartRideParam => {
                            if start_ride_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StartRideParam"));
                            }
                            start_ride_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AiBotStartRide {
                    start_ride_param: start_ride_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AiBotStartRide", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AiBotTeleportToPos {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.teleport_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AiBotTeleportToPos", len)?;
        if let Some(v) = self.teleport_param.as_ref() {
            struct_ser.serialize_field("TeleportParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AiBotTeleportToPos {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TeleportParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TeleportParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TeleportParam" => Ok(GeneratedField::TeleportParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AiBotTeleportToPos;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AiBotTeleportToPos")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AiBotTeleportToPos, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut teleport_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TeleportParam => {
                            if teleport_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TeleportParam"));
                            }
                            teleport_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AiBotTeleportToPos {
                    teleport_param: teleport_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AiBotTeleportToPos", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AiBotUseSkill {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.use_skill_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AiBotUseSkill", len)?;
        if let Some(v) = self.use_skill_param.as_ref() {
            struct_ser.serialize_field("UseSkillParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AiBotUseSkill {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UseSkillParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UseSkillParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UseSkillParam" => Ok(GeneratedField::UseSkillParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AiBotUseSkill;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AiBotUseSkill")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AiBotUseSkill, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut use_skill_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UseSkillParam => {
                            if use_skill_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UseSkillParam"));
                            }
                            use_skill_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(AiBotUseSkill {
                    use_skill_param: use_skill_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AiBotUseSkill", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AnswerList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.answers.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AnswerList", len)?;
        if !self.answers.is_empty() {
            struct_ser.serialize_field("Answers", &self.answers)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AnswerList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Answers",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Answers,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Answers" => Ok(GeneratedField::Answers),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AnswerList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AnswerList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AnswerList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut answers__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Answers => {
                            if answers__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Answers"));
                            }
                            answers__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(AnswerList {
                    answers: answers__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AnswerList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AntiAddictionInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.last_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AntiAddictionInfo", len)?;
        if let Some(v) = self.last_time.as_ref() {
            struct_ser.serialize_field("LastTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AntiAddictionInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LastTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LastTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LastTime" => Ok(GeneratedField::LastTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AntiAddictionInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AntiAddictionInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AntiAddictionInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut last_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LastTime => {
                            if last_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastTime"));
                            }
                            last_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(AntiAddictionInfo {
                    last_time: last_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AntiAddictionInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AoiSyncDelta {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if self.attrs.is_some() {
            len += 1;
        }
        if self.temp_attrs.is_some() {
            len += 1;
        }
        if self.event_data_list.is_some() {
            len += 1;
        }
        if self.bullet_event.is_some() {
            len += 1;
        }
        if self.body_part_infos.is_some() {
            len += 1;
        }
        if self.skill_effects.is_some() {
            len += 1;
        }
        if self.passive_skill_infos.is_some() {
            len += 1;
        }
        if self.passive_skill_end_infos.is_some() {
            len += 1;
        }
        if self.buff_infos.is_some() {
            len += 1;
        }
        if self.buff_effect.is_some() {
            len += 1;
        }
        if !self.fake_bullets.is_empty() {
            len += 1;
        }
        if !self.magnetic_ride_queue_change_info_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AoiSyncDelta", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.attrs.as_ref() {
            struct_ser.serialize_field("Attrs", v)?;
        }
        if let Some(v) = self.temp_attrs.as_ref() {
            struct_ser.serialize_field("TempAttrs", v)?;
        }
        if let Some(v) = self.event_data_list.as_ref() {
            struct_ser.serialize_field("EventDataList", v)?;
        }
        if let Some(v) = self.bullet_event.as_ref() {
            struct_ser.serialize_field("BulletEvent", v)?;
        }
        if let Some(v) = self.body_part_infos.as_ref() {
            struct_ser.serialize_field("BodyPartInfos", v)?;
        }
        if let Some(v) = self.skill_effects.as_ref() {
            struct_ser.serialize_field("SkillEffects", v)?;
        }
        if let Some(v) = self.passive_skill_infos.as_ref() {
            struct_ser.serialize_field("PassiveSkillInfos", v)?;
        }
        if let Some(v) = self.passive_skill_end_infos.as_ref() {
            struct_ser.serialize_field("PassiveSkillEndInfos", v)?;
        }
        if let Some(v) = self.buff_infos.as_ref() {
            struct_ser.serialize_field("BuffInfos", v)?;
        }
        if let Some(v) = self.buff_effect.as_ref() {
            struct_ser.serialize_field("BuffEffect", v)?;
        }
        if !self.fake_bullets.is_empty() {
            struct_ser.serialize_field("FakeBullets", &self.fake_bullets)?;
        }
        if !self.magnetic_ride_queue_change_info_list.is_empty() {
            struct_ser.serialize_field("MagneticRideQueueChangeInfoList", &self.magnetic_ride_queue_change_info_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AoiSyncDelta {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "Attrs",
            "TempAttrs",
            "EventDataList",
            "BulletEvent",
            "BodyPartInfos",
            "SkillEffects",
            "PassiveSkillInfos",
            "PassiveSkillEndInfos",
            "BuffInfos",
            "BuffEffect",
            "FakeBullets",
            "MagneticRideQueueChangeInfoList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            Attrs,
            TempAttrs,
            EventDataList,
            BulletEvent,
            BodyPartInfos,
            SkillEffects,
            PassiveSkillInfos,
            PassiveSkillEndInfos,
            BuffInfos,
            BuffEffect,
            FakeBullets,
            MagneticRideQueueChangeInfoList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "Attrs" => Ok(GeneratedField::Attrs),
                            "TempAttrs" => Ok(GeneratedField::TempAttrs),
                            "EventDataList" => Ok(GeneratedField::EventDataList),
                            "BulletEvent" => Ok(GeneratedField::BulletEvent),
                            "BodyPartInfos" => Ok(GeneratedField::BodyPartInfos),
                            "SkillEffects" => Ok(GeneratedField::SkillEffects),
                            "PassiveSkillInfos" => Ok(GeneratedField::PassiveSkillInfos),
                            "PassiveSkillEndInfos" => Ok(GeneratedField::PassiveSkillEndInfos),
                            "BuffInfos" => Ok(GeneratedField::BuffInfos),
                            "BuffEffect" => Ok(GeneratedField::BuffEffect),
                            "FakeBullets" => Ok(GeneratedField::FakeBullets),
                            "MagneticRideQueueChangeInfoList" => Ok(GeneratedField::MagneticRideQueueChangeInfoList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AoiSyncDelta;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AoiSyncDelta")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AoiSyncDelta, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut attrs__ = None;
                let mut temp_attrs__ = None;
                let mut event_data_list__ = None;
                let mut bullet_event__ = None;
                let mut body_part_infos__ = None;
                let mut skill_effects__ = None;
                let mut passive_skill_infos__ = None;
                let mut passive_skill_end_infos__ = None;
                let mut buff_infos__ = None;
                let mut buff_effect__ = None;
                let mut fake_bullets__ = None;
                let mut magnetic_ride_queue_change_info_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Attrs => {
                            if attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Attrs"));
                            }
                            attrs__ = map_.next_value()?;
                        }
                        GeneratedField::TempAttrs => {
                            if temp_attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TempAttrs"));
                            }
                            temp_attrs__ = map_.next_value()?;
                        }
                        GeneratedField::EventDataList => {
                            if event_data_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EventDataList"));
                            }
                            event_data_list__ = map_.next_value()?;
                        }
                        GeneratedField::BulletEvent => {
                            if bullet_event__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BulletEvent"));
                            }
                            bullet_event__ = map_.next_value()?;
                        }
                        GeneratedField::BodyPartInfos => {
                            if body_part_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BodyPartInfos"));
                            }
                            body_part_infos__ = map_.next_value()?;
                        }
                        GeneratedField::SkillEffects => {
                            if skill_effects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillEffects"));
                            }
                            skill_effects__ = map_.next_value()?;
                        }
                        GeneratedField::PassiveSkillInfos => {
                            if passive_skill_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PassiveSkillInfos"));
                            }
                            passive_skill_infos__ = map_.next_value()?;
                        }
                        GeneratedField::PassiveSkillEndInfos => {
                            if passive_skill_end_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PassiveSkillEndInfos"));
                            }
                            passive_skill_end_infos__ = map_.next_value()?;
                        }
                        GeneratedField::BuffInfos => {
                            if buff_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffInfos"));
                            }
                            buff_infos__ = map_.next_value()?;
                        }
                        GeneratedField::BuffEffect => {
                            if buff_effect__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffEffect"));
                            }
                            buff_effect__ = map_.next_value()?;
                        }
                        GeneratedField::FakeBullets => {
                            if fake_bullets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FakeBullets"));
                            }
                            fake_bullets__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MagneticRideQueueChangeInfoList => {
                            if magnetic_ride_queue_change_info_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MagneticRideQueueChangeInfoList"));
                            }
                            magnetic_ride_queue_change_info_list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AoiSyncDelta {
                    uuid: uuid__,
                    attrs: attrs__,
                    temp_attrs: temp_attrs__,
                    event_data_list: event_data_list__,
                    bullet_event: bullet_event__,
                    body_part_infos: body_part_infos__,
                    skill_effects: skill_effects__,
                    passive_skill_infos: passive_skill_infos__,
                    passive_skill_end_infos: passive_skill_end_infos__,
                    buff_infos: buff_infos__,
                    buff_effect: buff_effect__,
                    fake_bullets: fake_bullets__.unwrap_or_default(),
                    magnetic_ride_queue_change_info_list: magnetic_ride_queue_change_info_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AoiSyncDelta", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AoiSyncToMeDelta {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.base_delta.is_some() {
            len += 1;
        }
        if !self.sync_hate_ids.is_empty() {
            len += 1;
        }
        if !self.sync_skill_c_ds.is_empty() {
            len += 1;
        }
        if !self.fight_res_c_ds.is_empty() {
            len += 1;
        }
        if self.uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AoiSyncToMeDelta", len)?;
        if let Some(v) = self.base_delta.as_ref() {
            struct_ser.serialize_field("BaseDelta", v)?;
        }
        if !self.sync_hate_ids.is_empty() {
            struct_ser.serialize_field("SyncHateIds", &self.sync_hate_ids.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if !self.sync_skill_c_ds.is_empty() {
            struct_ser.serialize_field("SyncSkillCDs", &self.sync_skill_c_ds)?;
        }
        if !self.fight_res_c_ds.is_empty() {
            struct_ser.serialize_field("FightResCDs", &self.fight_res_c_ds)?;
        }
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AoiSyncToMeDelta {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BaseDelta",
            "SyncHateIds",
            "SyncSkillCDs",
            "FightResCDs",
            "Uuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BaseDelta,
            SyncHateIds,
            SyncSkillCDs,
            FightResCDs,
            Uuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BaseDelta" => Ok(GeneratedField::BaseDelta),
                            "SyncHateIds" => Ok(GeneratedField::SyncHateIds),
                            "SyncSkillCDs" => Ok(GeneratedField::SyncSkillCDs),
                            "FightResCDs" => Ok(GeneratedField::FightResCDs),
                            "Uuid" => Ok(GeneratedField::Uuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AoiSyncToMeDelta;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AoiSyncToMeDelta")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AoiSyncToMeDelta, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut base_delta__ = None;
                let mut sync_hate_ids__ = None;
                let mut sync_skill_c_ds__ = None;
                let mut fight_res_c_ds__ = None;
                let mut uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BaseDelta => {
                            if base_delta__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BaseDelta"));
                            }
                            base_delta__ = map_.next_value()?;
                        }
                        GeneratedField::SyncHateIds => {
                            if sync_hate_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SyncHateIds"));
                            }
                            sync_hate_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::SyncSkillCDs => {
                            if sync_skill_c_ds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SyncSkillCDs"));
                            }
                            sync_skill_c_ds__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FightResCDs => {
                            if fight_res_c_ds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FightResCDs"));
                            }
                            fight_res_c_ds__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(AoiSyncToMeDelta {
                    base_delta: base_delta__,
                    sync_hate_ids: sync_hate_ids__.unwrap_or_default(),
                    sync_skill_c_ds: sync_skill_c_ds__.unwrap_or_default(),
                    fight_res_c_ds: fight_res_c_ds__.unwrap_or_default(),
                    uuid: uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AoiSyncToMeDelta", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AttachVelocity {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.attach_speed.is_some() {
            len += 1;
        }
        if self.vel_dir_x.is_some() {
            len += 1;
        }
        if self.vel_dir_y.is_some() {
            len += 1;
        }
        if self.vel_dir_z.is_some() {
            len += 1;
        }
        if self.attach_source.is_some() {
            len += 1;
        }
        if self.source_ent_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AttachVelocity", len)?;
        if let Some(v) = self.attach_speed.as_ref() {
            struct_ser.serialize_field("AttachSpeed", v)?;
        }
        if let Some(v) = self.vel_dir_x.as_ref() {
            struct_ser.serialize_field("VelDirX", v)?;
        }
        if let Some(v) = self.vel_dir_y.as_ref() {
            struct_ser.serialize_field("VelDirY", v)?;
        }
        if let Some(v) = self.vel_dir_z.as_ref() {
            struct_ser.serialize_field("VelDirZ", v)?;
        }
        if let Some(v) = self.attach_source.as_ref() {
            struct_ser.serialize_field("AttachSource", v)?;
        }
        if let Some(v) = self.source_ent_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SourceEntUuid", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AttachVelocity {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AttachSpeed",
            "VelDirX",
            "VelDirY",
            "VelDirZ",
            "AttachSource",
            "SourceEntUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AttachSpeed,
            VelDirX,
            VelDirY,
            VelDirZ,
            AttachSource,
            SourceEntUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AttachSpeed" => Ok(GeneratedField::AttachSpeed),
                            "VelDirX" => Ok(GeneratedField::VelDirX),
                            "VelDirY" => Ok(GeneratedField::VelDirY),
                            "VelDirZ" => Ok(GeneratedField::VelDirZ),
                            "AttachSource" => Ok(GeneratedField::AttachSource),
                            "SourceEntUuid" => Ok(GeneratedField::SourceEntUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AttachVelocity;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AttachVelocity")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AttachVelocity, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut attach_speed__ = None;
                let mut vel_dir_x__ = None;
                let mut vel_dir_y__ = None;
                let mut vel_dir_z__ = None;
                let mut attach_source__ = None;
                let mut source_ent_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AttachSpeed => {
                            if attach_speed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AttachSpeed"));
                            }
                            attach_speed__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VelDirX => {
                            if vel_dir_x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VelDirX"));
                            }
                            vel_dir_x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VelDirY => {
                            if vel_dir_y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VelDirY"));
                            }
                            vel_dir_y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VelDirZ => {
                            if vel_dir_z__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VelDirZ"));
                            }
                            vel_dir_z__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AttachSource => {
                            if attach_source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AttachSource"));
                            }
                            attach_source__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SourceEntUuid => {
                            if source_ent_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SourceEntUuid"));
                            }
                            source_ent_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(AttachVelocity {
                    attach_speed: attach_speed__,
                    vel_dir_x: vel_dir_x__,
                    vel_dir_y: vel_dir_y__,
                    vel_dir_z: vel_dir_z__,
                    attach_source: attach_source__,
                    source_ent_uuid: source_ent_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AttachVelocity", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Attr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.raw_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Attr", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.raw_data.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RawData", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Attr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "RawData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            RawData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "RawData" => Ok(GeneratedField::RawData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Attr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Attr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Attr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut raw_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RawData => {
                            if raw_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RawData"));
                            }
                            raw_data__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Attr {
                    id: id__,
                    raw_data: raw_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Attr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AttrCollection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if !self.attrs.is_empty() {
            len += 1;
        }
        if !self.map_attrs.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AttrCollection", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if !self.attrs.is_empty() {
            struct_ser.serialize_field("Attrs", &self.attrs)?;
        }
        if !self.map_attrs.is_empty() {
            struct_ser.serialize_field("MapAttrs", &self.map_attrs)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AttrCollection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "Attrs",
            "MapAttrs",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            Attrs,
            MapAttrs,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "Attrs" => Ok(GeneratedField::Attrs),
                            "MapAttrs" => Ok(GeneratedField::MapAttrs),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AttrCollection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AttrCollection")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AttrCollection, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut attrs__ = None;
                let mut map_attrs__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Attrs => {
                            if attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Attrs"));
                            }
                            attrs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MapAttrs => {
                            if map_attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MapAttrs"));
                            }
                            map_attrs__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(AttrCollection {
                    uuid: uuid__,
                    attrs: attrs__.unwrap_or_default(),
                    map_attrs: map_attrs__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AttrCollection", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AttrInBattleShowSync {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.attr_in_battle_show.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AttrInBattleShowSync", len)?;
        if let Some(v) = self.attr_in_battle_show.as_ref() {
            struct_ser.serialize_field("AttrInBattleShow", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AttrInBattleShowSync {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AttrInBattleShow",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AttrInBattleShow,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AttrInBattleShow" => Ok(GeneratedField::AttrInBattleShow),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AttrInBattleShowSync;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AttrInBattleShowSync")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AttrInBattleShowSync, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut attr_in_battle_show__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AttrInBattleShow => {
                            if attr_in_battle_show__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AttrInBattleShow"));
                            }
                            attr_in_battle_show__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(AttrInBattleShowSync {
                    attr_in_battle_show: attr_in_battle_show__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AttrInBattleShowSync", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AvatarInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.avatar_id.is_some() {
            len += 1;
        }
        if self.profile.is_some() {
            len += 1;
        }
        if self.half_body.is_some() {
            len += 1;
        }
        if self.business_card_style_id.is_some() {
            len += 1;
        }
        if self.avatar_frame_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.AvatarInfo", len)?;
        if let Some(v) = self.avatar_id.as_ref() {
            struct_ser.serialize_field("AvatarId", v)?;
        }
        if let Some(v) = self.profile.as_ref() {
            struct_ser.serialize_field("Profile", v)?;
        }
        if let Some(v) = self.half_body.as_ref() {
            struct_ser.serialize_field("HalfBody", v)?;
        }
        if let Some(v) = self.business_card_style_id.as_ref() {
            struct_ser.serialize_field("BusinessCardStyleId", v)?;
        }
        if let Some(v) = self.avatar_frame_id.as_ref() {
            struct_ser.serialize_field("AvatarFrameId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AvatarInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AvatarId",
            "Profile",
            "HalfBody",
            "BusinessCardStyleId",
            "AvatarFrameId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AvatarId,
            Profile,
            HalfBody,
            BusinessCardStyleId,
            AvatarFrameId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AvatarId" => Ok(GeneratedField::AvatarId),
                            "Profile" => Ok(GeneratedField::Profile),
                            "HalfBody" => Ok(GeneratedField::HalfBody),
                            "BusinessCardStyleId" => Ok(GeneratedField::BusinessCardStyleId),
                            "AvatarFrameId" => Ok(GeneratedField::AvatarFrameId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AvatarInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.AvatarInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AvatarInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut avatar_id__ = None;
                let mut profile__ = None;
                let mut half_body__ = None;
                let mut business_card_style_id__ = None;
                let mut avatar_frame_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AvatarId => {
                            if avatar_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AvatarId"));
                            }
                            avatar_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Profile => {
                            if profile__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Profile"));
                            }
                            profile__ = map_.next_value()?;
                        }
                        GeneratedField::HalfBody => {
                            if half_body__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HalfBody"));
                            }
                            half_body__ = map_.next_value()?;
                        }
                        GeneratedField::BusinessCardStyleId => {
                            if business_card_style_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BusinessCardStyleId"));
                            }
                            business_card_style_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AvatarFrameId => {
                            if avatar_frame_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AvatarFrameId"));
                            }
                            avatar_frame_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(AvatarInfo {
                    avatar_id: avatar_id__,
                    profile: profile__,
                    half_body: half_body__,
                    business_card_style_id: business_card_style_id__,
                    avatar_frame_id: avatar_frame_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.AvatarInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BasicData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.char_id.is_some() {
            len += 1;
        }
        if self.show_id.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if self.gender.is_some() {
            len += 1;
        }
        if self.body_size.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        if self.scene_id.is_some() {
            len += 1;
        }
        if !self.personal_state.is_empty() {
            len += 1;
        }
        if self.offline_time.is_some() {
            len += 1;
        }
        if self.scene_guid.is_some() {
            len += 1;
        }
        if self.create_time.is_some() {
            len += 1;
        }
        if self.cur_talent_pool_id.is_some() {
            len += 1;
        }
        if self.bot_ai_id.is_some() {
            len += 1;
        }
        if self.register_channel.is_some() {
            len += 1;
        }
        if self.char_state.is_some() {
            len += 1;
        }
        if self.online_time.is_some() {
            len += 1;
        }
        if self.sum_save_diamond.is_some() {
            len += 1;
        }
        if self.is_newbie.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BasicData", len)?;
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharID", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.show_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ShowId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("Name", v)?;
        }
        if let Some(v) = self.gender.as_ref() {
            struct_ser.serialize_field("Gender", v)?;
        }
        if let Some(v) = self.body_size.as_ref() {
            let v = EBodySize::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("BodySize", &v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if let Some(v) = self.scene_id.as_ref() {
            struct_ser.serialize_field("SceneId", v)?;
        }
        if !self.personal_state.is_empty() {
            struct_ser.serialize_field("PersonalState", &self.personal_state)?;
        }
        if let Some(v) = self.offline_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("OfflineTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.scene_guid.as_ref() {
            struct_ser.serialize_field("SceneGuid", v)?;
        }
        if let Some(v) = self.create_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CreateTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.cur_talent_pool_id.as_ref() {
            struct_ser.serialize_field("CurTalentPoolId", v)?;
        }
        if let Some(v) = self.bot_ai_id.as_ref() {
            struct_ser.serialize_field("BotAiId", v)?;
        }
        if let Some(v) = self.register_channel.as_ref() {
            struct_ser.serialize_field("RegisterChannel", v)?;
        }
        if let Some(v) = self.char_state.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharState", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.online_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("OnlineTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.sum_save_diamond.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SumSaveDiamond", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.is_newbie.as_ref() {
            struct_ser.serialize_field("IsNewbie", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BasicData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CharID",
            "ShowId",
            "Name",
            "Gender",
            "BodySize",
            "Level",
            "SceneId",
            "PersonalState",
            "OfflineTime",
            "SceneGuid",
            "CreateTime",
            "CurTalentPoolId",
            "BotAiId",
            "RegisterChannel",
            "CharState",
            "OnlineTime",
            "SumSaveDiamond",
            "IsNewbie",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CharId,
            ShowId,
            Name,
            Gender,
            BodySize,
            Level,
            SceneId,
            PersonalState,
            OfflineTime,
            SceneGuid,
            CreateTime,
            CurTalentPoolId,
            BotAiId,
            RegisterChannel,
            CharState,
            OnlineTime,
            SumSaveDiamond,
            IsNewbie,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CharID" => Ok(GeneratedField::CharId),
                            "ShowId" => Ok(GeneratedField::ShowId),
                            "Name" => Ok(GeneratedField::Name),
                            "Gender" => Ok(GeneratedField::Gender),
                            "BodySize" => Ok(GeneratedField::BodySize),
                            "Level" => Ok(GeneratedField::Level),
                            "SceneId" => Ok(GeneratedField::SceneId),
                            "PersonalState" => Ok(GeneratedField::PersonalState),
                            "OfflineTime" => Ok(GeneratedField::OfflineTime),
                            "SceneGuid" => Ok(GeneratedField::SceneGuid),
                            "CreateTime" => Ok(GeneratedField::CreateTime),
                            "CurTalentPoolId" => Ok(GeneratedField::CurTalentPoolId),
                            "BotAiId" => Ok(GeneratedField::BotAiId),
                            "RegisterChannel" => Ok(GeneratedField::RegisterChannel),
                            "CharState" => Ok(GeneratedField::CharState),
                            "OnlineTime" => Ok(GeneratedField::OnlineTime),
                            "SumSaveDiamond" => Ok(GeneratedField::SumSaveDiamond),
                            "IsNewbie" => Ok(GeneratedField::IsNewbie),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BasicData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BasicData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BasicData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut char_id__ = None;
                let mut show_id__ = None;
                let mut name__ = None;
                let mut gender__ = None;
                let mut body_size__ = None;
                let mut level__ = None;
                let mut scene_id__ = None;
                let mut personal_state__ = None;
                let mut offline_time__ = None;
                let mut scene_guid__ = None;
                let mut create_time__ = None;
                let mut cur_talent_pool_id__ = None;
                let mut bot_ai_id__ = None;
                let mut register_channel__ = None;
                let mut char_state__ = None;
                let mut online_time__ = None;
                let mut sum_save_diamond__ = None;
                let mut is_newbie__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharID"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ShowId => {
                            if show_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShowId"));
                            }
                            show_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Gender => {
                            if gender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Gender"));
                            }
                            gender__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BodySize => {
                            if body_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BodySize"));
                            }
                            body_size__ = map_.next_value::<::std::option::Option<EBodySize>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SceneId => {
                            if scene_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneId"));
                            }
                            scene_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PersonalState => {
                            if personal_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PersonalState"));
                            }
                            personal_state__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::OfflineTime => {
                            if offline_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OfflineTime"));
                            }
                            offline_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SceneGuid => {
                            if scene_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneGuid"));
                            }
                            scene_guid__ = map_.next_value()?;
                        }
                        GeneratedField::CreateTime => {
                            if create_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateTime"));
                            }
                            create_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurTalentPoolId => {
                            if cur_talent_pool_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurTalentPoolId"));
                            }
                            cur_talent_pool_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BotAiId => {
                            if bot_ai_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BotAiId"));
                            }
                            bot_ai_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RegisterChannel => {
                            if register_channel__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RegisterChannel"));
                            }
                            register_channel__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CharState => {
                            if char_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharState"));
                            }
                            char_state__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OnlineTime => {
                            if online_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OnlineTime"));
                            }
                            online_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SumSaveDiamond => {
                            if sum_save_diamond__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SumSaveDiamond"));
                            }
                            sum_save_diamond__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsNewbie => {
                            if is_newbie__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsNewbie"));
                            }
                            is_newbie__ = map_.next_value()?;
                        }
                    }
                }
                Ok(BasicData {
                    char_id: char_id__,
                    show_id: show_id__,
                    name: name__,
                    gender: gender__,
                    body_size: body_size__,
                    level: level__,
                    scene_id: scene_id__,
                    personal_state: personal_state__.unwrap_or_default(),
                    offline_time: offline_time__,
                    scene_guid: scene_guid__,
                    create_time: create_time__,
                    cur_talent_pool_id: cur_talent_pool_id__,
                    bot_ai_id: bot_ai_id__,
                    register_channel: register_channel__,
                    char_state: char_state__,
                    online_time: online_time__,
                    sum_save_diamond: sum_save_diamond__,
                    is_newbie: is_newbie__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BasicData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BattlePass {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        if self.curexp.is_some() {
            len += 1;
        }
        if self.week_exp.is_some() {
            len += 1;
        }
        if self.exp_last_time.is_some() {
            len += 1;
        }
        if self.is_unlock.is_some() {
            len += 1;
        }
        if self.buy_normal_pas.is_some() {
            len += 1;
        }
        if self.buy_prime_pass.is_some() {
            len += 1;
        }
        if !self.award.is_empty() {
            len += 1;
        }
        if self.is_valid.is_some() {
            len += 1;
        }
        if self.is_sended_mail.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BattlePass", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if let Some(v) = self.curexp.as_ref() {
            struct_ser.serialize_field("Curexp", v)?;
        }
        if let Some(v) = self.week_exp.as_ref() {
            struct_ser.serialize_field("WeekExp", v)?;
        }
        if let Some(v) = self.exp_last_time.as_ref() {
            struct_ser.serialize_field("ExpLastTime", v)?;
        }
        if let Some(v) = self.is_unlock.as_ref() {
            struct_ser.serialize_field("IsUnlock", v)?;
        }
        if let Some(v) = self.buy_normal_pas.as_ref() {
            struct_ser.serialize_field("BuyNormalPas", v)?;
        }
        if let Some(v) = self.buy_prime_pass.as_ref() {
            struct_ser.serialize_field("BuyPrimePass", v)?;
        }
        if !self.award.is_empty() {
            struct_ser.serialize_field("Award", &self.award)?;
        }
        if let Some(v) = self.is_valid.as_ref() {
            struct_ser.serialize_field("IsValid", v)?;
        }
        if let Some(v) = self.is_sended_mail.as_ref() {
            struct_ser.serialize_field("IsSendedMail", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BattlePass {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Level",
            "Curexp",
            "WeekExp",
            "ExpLastTime",
            "IsUnlock",
            "BuyNormalPas",
            "BuyPrimePass",
            "Award",
            "IsValid",
            "IsSendedMail",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Level,
            Curexp,
            WeekExp,
            ExpLastTime,
            IsUnlock,
            BuyNormalPas,
            BuyPrimePass,
            Award,
            IsValid,
            IsSendedMail,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Level" => Ok(GeneratedField::Level),
                            "Curexp" => Ok(GeneratedField::Curexp),
                            "WeekExp" => Ok(GeneratedField::WeekExp),
                            "ExpLastTime" => Ok(GeneratedField::ExpLastTime),
                            "IsUnlock" => Ok(GeneratedField::IsUnlock),
                            "BuyNormalPas" => Ok(GeneratedField::BuyNormalPas),
                            "BuyPrimePass" => Ok(GeneratedField::BuyPrimePass),
                            "Award" => Ok(GeneratedField::Award),
                            "IsValid" => Ok(GeneratedField::IsValid),
                            "IsSendedMail" => Ok(GeneratedField::IsSendedMail),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BattlePass;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BattlePass")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BattlePass, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut level__ = None;
                let mut curexp__ = None;
                let mut week_exp__ = None;
                let mut exp_last_time__ = None;
                let mut is_unlock__ = None;
                let mut buy_normal_pas__ = None;
                let mut buy_prime_pass__ = None;
                let mut award__ = None;
                let mut is_valid__ = None;
                let mut is_sended_mail__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Curexp => {
                            if curexp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Curexp"));
                            }
                            curexp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WeekExp => {
                            if week_exp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WeekExp"));
                            }
                            week_exp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExpLastTime => {
                            if exp_last_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExpLastTime"));
                            }
                            exp_last_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsUnlock => {
                            if is_unlock__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsUnlock"));
                            }
                            is_unlock__ = map_.next_value()?;
                        }
                        GeneratedField::BuyNormalPas => {
                            if buy_normal_pas__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuyNormalPas"));
                            }
                            buy_normal_pas__ = map_.next_value()?;
                        }
                        GeneratedField::BuyPrimePass => {
                            if buy_prime_pass__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuyPrimePass"));
                            }
                            buy_prime_pass__ = map_.next_value()?;
                        }
                        GeneratedField::Award => {
                            if award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Award"));
                            }
                            award__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::IsValid => {
                            if is_valid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsValid"));
                            }
                            is_valid__ = map_.next_value()?;
                        }
                        GeneratedField::IsSendedMail => {
                            if is_sended_mail__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsSendedMail"));
                            }
                            is_sended_mail__ = map_.next_value()?;
                        }
                    }
                }
                Ok(BattlePass {
                    id: id__,
                    level: level__,
                    curexp: curexp__,
                    week_exp: week_exp__,
                    exp_last_time: exp_last_time__,
                    is_unlock: is_unlock__,
                    buy_normal_pas: buy_normal_pas__,
                    buy_prime_pass: buy_prime_pass__,
                    award: award__.unwrap_or_default(),
                    is_valid: is_valid__,
                    is_sended_mail: is_sended_mail__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BattlePass", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BattlePassAwardInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.free_award.is_some() {
            len += 1;
        }
        if self.paid_award.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BattlePassAwardInfo", len)?;
        if let Some(v) = self.free_award.as_ref() {
            struct_ser.serialize_field("FreeAward", v)?;
        }
        if let Some(v) = self.paid_award.as_ref() {
            struct_ser.serialize_field("PaidAward", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BattlePassAwardInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FreeAward",
            "PaidAward",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FreeAward,
            PaidAward,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FreeAward" => Ok(GeneratedField::FreeAward),
                            "PaidAward" => Ok(GeneratedField::PaidAward),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BattlePassAwardInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BattlePassAwardInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BattlePassAwardInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut free_award__ = None;
                let mut paid_award__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FreeAward => {
                            if free_award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FreeAward"));
                            }
                            free_award__ = map_.next_value()?;
                        }
                        GeneratedField::PaidAward => {
                            if paid_award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PaidAward"));
                            }
                            paid_award__ = map_.next_value()?;
                        }
                    }
                }
                Ok(BattlePassAwardInfo {
                    free_award: free_award__,
                    paid_award: paid_award__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BattlePassAwardInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BattlePassData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.battle_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BattlePassData", len)?;
        if !self.battle_map.is_empty() {
            struct_ser.serialize_field("BattleMap", &self.battle_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BattlePassData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BattleMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BattleMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BattleMap" => Ok(GeneratedField::BattleMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BattlePassData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BattlePassData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BattlePassData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut battle_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BattleMap => {
                            if battle_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BattleMap"));
                            }
                            battle_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(BattlePassData {
                    battle_map: battle_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BattlePassData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BodyPartState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Default => "BodyPartStateDefault",
            Self::Injury => "BodyPartStateInjury",
            Self::Dead => "BodyPartStateDead",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for BodyPartState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BodyPartStateDefault",
            "BodyPartStateInjury",
            "BodyPartStateDead",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BodyPartState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "BodyPartStateDefault" => Ok(BodyPartState::Default),
                    "BodyPartStateInjury" => Ok(BodyPartState::Injury),
                    "BodyPartStateDead" => Ok(BodyPartState::Dead),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for BossProgress {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.total_award_cnt.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BossProgress", len)?;
        if let Some(v) = self.total_award_cnt.as_ref() {
            struct_ser.serialize_field("TotalAwardCnt", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BossProgress {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TotalAwardCnt",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TotalAwardCnt,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TotalAwardCnt" => Ok(GeneratedField::TotalAwardCnt),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BossProgress;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BossProgress")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BossProgress, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut total_award_cnt__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TotalAwardCnt => {
                            if total_award_cnt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TotalAwardCnt"));
                            }
                            total_award_cnt__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BossProgress {
                    total_award_cnt: total_award_cnt__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BossProgress", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BotActiveTrigger {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.trigger_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BotActiveTrigger", len)?;
        if let Some(v) = self.trigger_id.as_ref() {
            struct_ser.serialize_field("TriggerId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BotActiveTrigger {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TriggerId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TriggerId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TriggerId" => Ok(GeneratedField::TriggerId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BotActiveTrigger;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BotActiveTrigger")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BotActiveTrigger, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut trigger_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TriggerId => {
                            if trigger_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TriggerId"));
                            }
                            trigger_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BotActiveTrigger {
                    trigger_id: trigger_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BotActiveTrigger", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BotAddBuff {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.actor_id.is_some() {
            len += 1;
        }
        if self.buff_id.is_some() {
            len += 1;
        }
        if self.layer.is_some() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BotAddBuff", len)?;
        if let Some(v) = self.actor_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ActorId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.buff_id.as_ref() {
            struct_ser.serialize_field("BuffId", v)?;
        }
        if let Some(v) = self.layer.as_ref() {
            struct_ser.serialize_field("Layer", v)?;
        }
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("Duration", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BotAddBuff {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ActorId",
            "BuffId",
            "Layer",
            "Duration",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ActorId,
            BuffId,
            Layer,
            Duration,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ActorId" => Ok(GeneratedField::ActorId),
                            "BuffId" => Ok(GeneratedField::BuffId),
                            "Layer" => Ok(GeneratedField::Layer),
                            "Duration" => Ok(GeneratedField::Duration),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BotAddBuff;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BotAddBuff")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BotAddBuff, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut actor_id__ = None;
                let mut buff_id__ = None;
                let mut layer__ = None;
                let mut duration__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ActorId => {
                            if actor_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActorId"));
                            }
                            actor_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BuffId => {
                            if buff_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffId"));
                            }
                            buff_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Layer => {
                            if layer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Layer"));
                            }
                            layer__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BotAddBuff {
                    actor_id: actor_id__,
                    buff_id: buff_id__,
                    layer: layer__,
                    duration: duration__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BotAddBuff", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BotMoveInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.dest_pos.is_some() {
            len += 1;
        }
        if self.move_type.is_some() {
            len += 1;
        }
        if self.is_set_dir.is_some() {
            len += 1;
        }
        if self.cur_move_flag.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BotMoveInfo", len)?;
        if let Some(v) = self.dest_pos.as_ref() {
            struct_ser.serialize_field("DestPos", v)?;
        }
        if let Some(v) = self.move_type.as_ref() {
            let v = EMoveType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("MoveType", &v)?;
        }
        if let Some(v) = self.is_set_dir.as_ref() {
            struct_ser.serialize_field("IsSetDir", v)?;
        }
        if let Some(v) = self.cur_move_flag.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CurMoveFlag", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BotMoveInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DestPos",
            "MoveType",
            "IsSetDir",
            "CurMoveFlag",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DestPos,
            MoveType,
            IsSetDir,
            CurMoveFlag,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DestPos" => Ok(GeneratedField::DestPos),
                            "MoveType" => Ok(GeneratedField::MoveType),
                            "IsSetDir" => Ok(GeneratedField::IsSetDir),
                            "CurMoveFlag" => Ok(GeneratedField::CurMoveFlag),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BotMoveInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BotMoveInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BotMoveInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dest_pos__ = None;
                let mut move_type__ = None;
                let mut is_set_dir__ = None;
                let mut cur_move_flag__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DestPos => {
                            if dest_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DestPos"));
                            }
                            dest_pos__ = map_.next_value()?;
                        }
                        GeneratedField::MoveType => {
                            if move_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MoveType"));
                            }
                            move_type__ = map_.next_value::<::std::option::Option<EMoveType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::IsSetDir => {
                            if is_set_dir__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsSetDir"));
                            }
                            is_set_dir__ = map_.next_value()?;
                        }
                        GeneratedField::CurMoveFlag => {
                            if cur_move_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurMoveFlag"));
                            }
                            cur_move_flag__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BotMoveInfo {
                    dest_pos: dest_pos__,
                    move_type: move_type__,
                    is_set_dir: is_set_dir__,
                    cur_move_flag: cur_move_flag__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BotMoveInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BotPlayActionParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.action_id.is_some() {
            len += 1;
        }
        if self.action_source.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BotPlayActionParam", len)?;
        if let Some(v) = self.action_id.as_ref() {
            struct_ser.serialize_field("ActionId", v)?;
        }
        if let Some(v) = self.action_source.as_ref() {
            struct_ser.serialize_field("ActionSource", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BotPlayActionParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ActionId",
            "ActionSource",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ActionId,
            ActionSource,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ActionId" => Ok(GeneratedField::ActionId),
                            "ActionSource" => Ok(GeneratedField::ActionSource),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BotPlayActionParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BotPlayActionParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BotPlayActionParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut action_id__ = None;
                let mut action_source__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ActionId => {
                            if action_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActionId"));
                            }
                            action_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ActionSource => {
                            if action_source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActionSource"));
                            }
                            action_source__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BotPlayActionParam {
                    action_id: action_id__,
                    action_source: action_source__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BotPlayActionParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BotRemoveBuff {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.buff_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BotRemoveBuff", len)?;
        if let Some(v) = self.buff_id.as_ref() {
            struct_ser.serialize_field("BuffId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BotRemoveBuff {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BuffId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BuffId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BuffId" => Ok(GeneratedField::BuffId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BotRemoveBuff;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BotRemoveBuff")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BotRemoveBuff, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut buff_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BuffId => {
                            if buff_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffId"));
                            }
                            buff_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BotRemoveBuff {
                    buff_id: buff_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BotRemoveBuff", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BotResurrectionParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target_id.is_some() {
            len += 1;
        }
        if self.revive_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BotResurrectionParam", len)?;
        if let Some(v) = self.target_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.revive_id.as_ref() {
            struct_ser.serialize_field("ReviveId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BotResurrectionParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetId",
            "ReviveId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetId,
            ReviveId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetId" => Ok(GeneratedField::TargetId),
                            "ReviveId" => Ok(GeneratedField::ReviveId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BotResurrectionParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BotResurrectionParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BotResurrectionParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_id__ = None;
                let mut revive_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetId => {
                            if target_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetId"));
                            }
                            target_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReviveId => {
                            if revive_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReviveId"));
                            }
                            revive_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BotResurrectionParam {
                    target_id: target_id__,
                    revive_id: revive_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BotResurrectionParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BotSendChitChatMsgReq {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.emoji_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BotSendChitChatMsgReq", len)?;
        if let Some(v) = self.emoji_id.as_ref() {
            struct_ser.serialize_field("EmojiId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BotSendChitChatMsgReq {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EmojiId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EmojiId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EmojiId" => Ok(GeneratedField::EmojiId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BotSendChitChatMsgReq;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BotSendChitChatMsgReq")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BotSendChitChatMsgReq, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut emoji_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EmojiId => {
                            if emoji_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EmojiId"));
                            }
                            emoji_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BotSendChitChatMsgReq {
                    emoji_id: emoji_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BotSendChitChatMsgReq", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BotStartRideParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.ride_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BotStartRideParam", len)?;
        if let Some(v) = self.ride_id.as_ref() {
            struct_ser.serialize_field("RideId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BotStartRideParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RideId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RideId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RideId" => Ok(GeneratedField::RideId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BotStartRideParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BotStartRideParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BotStartRideParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ride_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RideId => {
                            if ride_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RideId"));
                            }
                            ride_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BotStartRideParam {
                    ride_id: ride_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BotStartRideParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BotTeleportParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.actor_id.is_some() {
            len += 1;
        }
        if self.pos.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BotTeleportParam", len)?;
        if let Some(v) = self.actor_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ActorId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.pos.as_ref() {
            struct_ser.serialize_field("Pos", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BotTeleportParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ActorId",
            "Pos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ActorId,
            Pos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ActorId" => Ok(GeneratedField::ActorId),
                            "Pos" => Ok(GeneratedField::Pos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BotTeleportParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BotTeleportParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BotTeleportParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut actor_id__ = None;
                let mut pos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ActorId => {
                            if actor_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActorId"));
                            }
                            actor_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Pos => {
                            if pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Pos"));
                            }
                            pos__ = map_.next_value()?;
                        }
                    }
                }
                Ok(BotTeleportParam {
                    actor_id: actor_id__,
                    pos: pos__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BotTeleportParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BotUseSkillInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.actor_id.is_some() {
            len += 1;
        }
        if self.skill_id.is_some() {
            len += 1;
        }
        if self.begin_time.is_some() {
            len += 1;
        }
        if self.target_uuid.is_some() {
            len += 1;
        }
        if self.target_pos.is_some() {
            len += 1;
        }
        if self.dmg_target_pos.is_some() {
            len += 1;
        }
        if self.face_target_pos.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BotUseSkillInfo", len)?;
        if let Some(v) = self.actor_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ActorId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.skill_id.as_ref() {
            struct_ser.serialize_field("SkillId", v)?;
        }
        if let Some(v) = self.begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.target_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.target_pos.as_ref() {
            struct_ser.serialize_field("TargetPos", v)?;
        }
        if let Some(v) = self.dmg_target_pos.as_ref() {
            struct_ser.serialize_field("DmgTargetPos", v)?;
        }
        if let Some(v) = self.face_target_pos.as_ref() {
            struct_ser.serialize_field("FaceTargetPos", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BotUseSkillInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ActorId",
            "SkillId",
            "BeginTime",
            "TargetUuid",
            "TargetPos",
            "DmgTargetPos",
            "FaceTargetPos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ActorId,
            SkillId,
            BeginTime,
            TargetUuid,
            TargetPos,
            DmgTargetPos,
            FaceTargetPos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ActorId" => Ok(GeneratedField::ActorId),
                            "SkillId" => Ok(GeneratedField::SkillId),
                            "BeginTime" => Ok(GeneratedField::BeginTime),
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            "TargetPos" => Ok(GeneratedField::TargetPos),
                            "DmgTargetPos" => Ok(GeneratedField::DmgTargetPos),
                            "FaceTargetPos" => Ok(GeneratedField::FaceTargetPos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BotUseSkillInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BotUseSkillInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BotUseSkillInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut actor_id__ = None;
                let mut skill_id__ = None;
                let mut begin_time__ = None;
                let mut target_uuid__ = None;
                let mut target_pos__ = None;
                let mut dmg_target_pos__ = None;
                let mut face_target_pos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ActorId => {
                            if actor_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActorId"));
                            }
                            actor_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillId => {
                            if skill_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillId"));
                            }
                            skill_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BeginTime => {
                            if begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeginTime"));
                            }
                            begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetPos => {
                            if target_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetPos"));
                            }
                            target_pos__ = map_.next_value()?;
                        }
                        GeneratedField::DmgTargetPos => {
                            if dmg_target_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DmgTargetPos"));
                            }
                            dmg_target_pos__ = map_.next_value()?;
                        }
                        GeneratedField::FaceTargetPos => {
                            if face_target_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FaceTargetPos"));
                            }
                            face_target_pos__ = map_.next_value()?;
                        }
                    }
                }
                Ok(BotUseSkillInfo {
                    actor_id: actor_id__,
                    skill_id: skill_id__,
                    begin_time: begin_time__,
                    target_uuid: target_uuid__,
                    target_pos: target_pos__,
                    dmg_target_pos: dmg_target_pos__,
                    face_target_pos: face_target_pos__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BotUseSkillInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BounceJump {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.bounce_jump_id.is_some() {
            len += 1;
        }
        if self.axis_ref_uuid.is_some() {
            len += 1;
        }
        if self.vel_dir_x.is_some() {
            len += 1;
        }
        if self.vel_dir_y.is_some() {
            len += 1;
        }
        if self.vel_dir_z.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BounceJump", len)?;
        if let Some(v) = self.bounce_jump_id.as_ref() {
            struct_ser.serialize_field("BounceJumpId", v)?;
        }
        if let Some(v) = self.axis_ref_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("AxisRefUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.vel_dir_x.as_ref() {
            struct_ser.serialize_field("VelDirX", v)?;
        }
        if let Some(v) = self.vel_dir_y.as_ref() {
            struct_ser.serialize_field("VelDirY", v)?;
        }
        if let Some(v) = self.vel_dir_z.as_ref() {
            struct_ser.serialize_field("VelDirZ", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BounceJump {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BounceJumpId",
            "AxisRefUuid",
            "VelDirX",
            "VelDirY",
            "VelDirZ",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BounceJumpId,
            AxisRefUuid,
            VelDirX,
            VelDirY,
            VelDirZ,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BounceJumpId" => Ok(GeneratedField::BounceJumpId),
                            "AxisRefUuid" => Ok(GeneratedField::AxisRefUuid),
                            "VelDirX" => Ok(GeneratedField::VelDirX),
                            "VelDirY" => Ok(GeneratedField::VelDirY),
                            "VelDirZ" => Ok(GeneratedField::VelDirZ),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BounceJump;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BounceJump")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BounceJump, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bounce_jump_id__ = None;
                let mut axis_ref_uuid__ = None;
                let mut vel_dir_x__ = None;
                let mut vel_dir_y__ = None;
                let mut vel_dir_z__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BounceJumpId => {
                            if bounce_jump_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BounceJumpId"));
                            }
                            bounce_jump_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AxisRefUuid => {
                            if axis_ref_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AxisRefUuid"));
                            }
                            axis_ref_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VelDirX => {
                            if vel_dir_x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VelDirX"));
                            }
                            vel_dir_x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VelDirY => {
                            if vel_dir_y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VelDirY"));
                            }
                            vel_dir_y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VelDirZ => {
                            if vel_dir_z__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VelDirZ"));
                            }
                            vel_dir_z__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BounceJump {
                    bounce_jump_id: bounce_jump_id__,
                    axis_ref_uuid: axis_ref_uuid__,
                    vel_dir_x: vel_dir_x__,
                    vel_dir_y: vel_dir_y__,
                    vel_dir_z: vel_dir_z__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BounceJump", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BubbleActData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.bubble_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BubbleActData", len)?;
        if !self.bubble_info.is_empty() {
            struct_ser.serialize_field("BubbleInfo", &self.bubble_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BubbleActData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BubbleInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BubbleInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BubbleInfo" => Ok(GeneratedField::BubbleInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BubbleActData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BubbleActData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BubbleActData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bubble_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BubbleInfo => {
                            if bubble_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BubbleInfo"));
                            }
                            bubble_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(BubbleActData {
                    bubble_info: bubble_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BubbleActData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BubbleInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.bubble_score.is_some() {
            len += 1;
        }
        if self.bubble_award_count.is_some() {
            len += 1;
        }
        if !self.additional_target_uuid_list.is_empty() {
            len += 1;
        }
        if self.last_refresh_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BubbleInfo", len)?;
        if let Some(v) = self.bubble_score.as_ref() {
            struct_ser.serialize_field("BubbleScore", v)?;
        }
        if let Some(v) = self.bubble_award_count.as_ref() {
            struct_ser.serialize_field("BubbleAwardCount", v)?;
        }
        if !self.additional_target_uuid_list.is_empty() {
            struct_ser.serialize_field("AdditionalTargetUuidList", &self.additional_target_uuid_list.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if let Some(v) = self.last_refresh_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastRefreshTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BubbleInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BubbleScore",
            "BubbleAwardCount",
            "AdditionalTargetUuidList",
            "LastRefreshTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BubbleScore,
            BubbleAwardCount,
            AdditionalTargetUuidList,
            LastRefreshTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BubbleScore" => Ok(GeneratedField::BubbleScore),
                            "BubbleAwardCount" => Ok(GeneratedField::BubbleAwardCount),
                            "AdditionalTargetUuidList" => Ok(GeneratedField::AdditionalTargetUuidList),
                            "LastRefreshTime" => Ok(GeneratedField::LastRefreshTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BubbleInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BubbleInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BubbleInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bubble_score__ = None;
                let mut bubble_award_count__ = None;
                let mut additional_target_uuid_list__ = None;
                let mut last_refresh_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BubbleScore => {
                            if bubble_score__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BubbleScore"));
                            }
                            bubble_score__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BubbleAwardCount => {
                            if bubble_award_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BubbleAwardCount"));
                            }
                            bubble_award_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AdditionalTargetUuidList => {
                            if additional_target_uuid_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AdditionalTargetUuidList"));
                            }
                            additional_target_uuid_list__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::LastRefreshTime => {
                            if last_refresh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastRefreshTime"));
                            }
                            last_refresh_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BubbleInfo {
                    bubble_score: bubble_score__,
                    bubble_award_count: bubble_award_count__,
                    additional_target_uuid_list: additional_target_uuid_list__.unwrap_or_default(),
                    last_refresh_time: last_refresh_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BubbleInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BuffAttrEffect {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.attr_show_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BuffAttrEffect", len)?;
        if !self.attr_show_info.is_empty() {
            struct_ser.serialize_field("AttrShowInfo", &self.attr_show_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BuffAttrEffect {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AttrShowInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AttrShowInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AttrShowInfo" => Ok(GeneratedField::AttrShowInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BuffAttrEffect;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BuffAttrEffect")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BuffAttrEffect, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut attr_show_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AttrShowInfo => {
                            if attr_show_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AttrShowInfo"));
                            }
                            attr_show_info__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BuffAttrEffect {
                    attr_show_info: attr_show_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BuffAttrEffect", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BuffAttrShowInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.is_gain.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BuffAttrShowInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.is_gain.as_ref() {
            struct_ser.serialize_field("IsGain", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BuffAttrShowInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "IsGain",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            IsGain,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "IsGain" => Ok(GeneratedField::IsGain),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BuffAttrShowInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BuffAttrShowInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BuffAttrShowInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut is_gain__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsGain => {
                            if is_gain__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsGain"));
                            }
                            is_gain__ = map_.next_value()?;
                        }
                    }
                }
                Ok(BuffAttrShowInfo {
                    id: id__,
                    is_gain: is_gain__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BuffAttrShowInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BuffDbData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.buff_uuid.is_some() {
            len += 1;
        }
        if self.firer_id.is_some() {
            len += 1;
        }
        if self.buff_config_id.is_some() {
            len += 1;
        }
        if self.base_id.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        if self.layer.is_some() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        if self.count.is_some() {
            len += 1;
        }
        if self.create_time.is_some() {
            len += 1;
        }
        if self.part_id.is_some() {
            len += 1;
        }
        if self.create_scene_id.is_some() {
            len += 1;
        }
        if !self.custom_params_key.is_empty() {
            len += 1;
        }
        if !self.custom_params.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BuffDBData", len)?;
        if let Some(v) = self.buff_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BuffUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.firer_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("FirerId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.buff_config_id.as_ref() {
            struct_ser.serialize_field("BuffConfigId", v)?;
        }
        if let Some(v) = self.base_id.as_ref() {
            struct_ser.serialize_field("BaseId", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if let Some(v) = self.layer.as_ref() {
            struct_ser.serialize_field("Layer", v)?;
        }
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("Duration", v)?;
        }
        if let Some(v) = self.count.as_ref() {
            struct_ser.serialize_field("Count", v)?;
        }
        if let Some(v) = self.create_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CreateTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.part_id.as_ref() {
            struct_ser.serialize_field("PartId", v)?;
        }
        if let Some(v) = self.create_scene_id.as_ref() {
            struct_ser.serialize_field("CreateSceneId", v)?;
        }
        if !self.custom_params_key.is_empty() {
            struct_ser.serialize_field("CustomParamsKey", &self.custom_params_key)?;
        }
        if !self.custom_params.is_empty() {
            struct_ser.serialize_field("CustomParams", &self.custom_params)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BuffDbData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BuffUuid",
            "FirerId",
            "BuffConfigId",
            "BaseId",
            "Level",
            "Layer",
            "Duration",
            "Count",
            "CreateTime",
            "PartId",
            "CreateSceneId",
            "CustomParamsKey",
            "CustomParams",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BuffUuid,
            FirerId,
            BuffConfigId,
            BaseId,
            Level,
            Layer,
            Duration,
            Count,
            CreateTime,
            PartId,
            CreateSceneId,
            CustomParamsKey,
            CustomParams,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BuffUuid" => Ok(GeneratedField::BuffUuid),
                            "FirerId" => Ok(GeneratedField::FirerId),
                            "BuffConfigId" => Ok(GeneratedField::BuffConfigId),
                            "BaseId" => Ok(GeneratedField::BaseId),
                            "Level" => Ok(GeneratedField::Level),
                            "Layer" => Ok(GeneratedField::Layer),
                            "Duration" => Ok(GeneratedField::Duration),
                            "Count" => Ok(GeneratedField::Count),
                            "CreateTime" => Ok(GeneratedField::CreateTime),
                            "PartId" => Ok(GeneratedField::PartId),
                            "CreateSceneId" => Ok(GeneratedField::CreateSceneId),
                            "CustomParamsKey" => Ok(GeneratedField::CustomParamsKey),
                            "CustomParams" => Ok(GeneratedField::CustomParams),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BuffDbData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BuffDBData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BuffDbData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut buff_uuid__ = None;
                let mut firer_id__ = None;
                let mut buff_config_id__ = None;
                let mut base_id__ = None;
                let mut level__ = None;
                let mut layer__ = None;
                let mut duration__ = None;
                let mut count__ = None;
                let mut create_time__ = None;
                let mut part_id__ = None;
                let mut create_scene_id__ = None;
                let mut custom_params_key__ = None;
                let mut custom_params__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BuffUuid => {
                            if buff_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffUuid"));
                            }
                            buff_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FirerId => {
                            if firer_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FirerId"));
                            }
                            firer_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BuffConfigId => {
                            if buff_config_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffConfigId"));
                            }
                            buff_config_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BaseId => {
                            if base_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BaseId"));
                            }
                            base_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Layer => {
                            if layer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Layer"));
                            }
                            layer__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Count"));
                            }
                            count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CreateTime => {
                            if create_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateTime"));
                            }
                            create_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PartId => {
                            if part_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartId"));
                            }
                            part_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CreateSceneId => {
                            if create_scene_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateSceneId"));
                            }
                            create_scene_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CustomParamsKey => {
                            if custom_params_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CustomParamsKey"));
                            }
                            custom_params_key__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CustomParams => {
                            if custom_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CustomParams"));
                            }
                            custom_params__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(BuffDbData {
                    buff_uuid: buff_uuid__,
                    firer_id: firer_id__,
                    buff_config_id: buff_config_id__,
                    base_id: base_id__,
                    level: level__,
                    layer: layer__,
                    duration: duration__,
                    count: count__,
                    create_time: create_time__,
                    part_id: part_id__,
                    create_scene_id: create_scene_id__,
                    custom_params_key: custom_params_key__.unwrap_or_default(),
                    custom_params: custom_params__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BuffDBData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BuffDbInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.max_id.is_some() {
            len += 1;
        }
        if !self.all_buff_db_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BuffDBInfo", len)?;
        if let Some(v) = self.max_id.as_ref() {
            struct_ser.serialize_field("MaxID", v)?;
        }
        if !self.all_buff_db_data.is_empty() {
            struct_ser.serialize_field("AllBuffDbData", &self.all_buff_db_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BuffDbInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MaxID",
            "AllBuffDbData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MaxId,
            AllBuffDbData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MaxID" => Ok(GeneratedField::MaxId),
                            "AllBuffDbData" => Ok(GeneratedField::AllBuffDbData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BuffDbInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BuffDBInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BuffDbInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut max_id__ = None;
                let mut all_buff_db_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MaxId => {
                            if max_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaxID"));
                            }
                            max_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AllBuffDbData => {
                            if all_buff_db_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AllBuffDbData"));
                            }
                            all_buff_db_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(BuffDbInfo {
                    max_id: max_id__,
                    all_buff_db_data: all_buff_db_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BuffDBInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BuffEffect {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.buff_uuid.is_some() {
            len += 1;
        }
        if self.host_uuid.is_some() {
            len += 1;
        }
        if self.trigger_time.is_some() {
            len += 1;
        }
        if !self.logic_effect.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BuffEffect", len)?;
        if let Some(v) = self.r#type.as_ref() {
            let v = EBuffEventType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Type", &v)?;
        }
        if let Some(v) = self.buff_uuid.as_ref() {
            struct_ser.serialize_field("BuffUuid", v)?;
        }
        if let Some(v) = self.host_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HostUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.trigger_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TriggerTime", ToString::to_string(&v).as_str())?;
        }
        if !self.logic_effect.is_empty() {
            struct_ser.serialize_field("LogicEffect", &self.logic_effect)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BuffEffect {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Type",
            "BuffUuid",
            "HostUuid",
            "TriggerTime",
            "LogicEffect",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            BuffUuid,
            HostUuid,
            TriggerTime,
            LogicEffect,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Type" => Ok(GeneratedField::Type),
                            "BuffUuid" => Ok(GeneratedField::BuffUuid),
                            "HostUuid" => Ok(GeneratedField::HostUuid),
                            "TriggerTime" => Ok(GeneratedField::TriggerTime),
                            "LogicEffect" => Ok(GeneratedField::LogicEffect),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BuffEffect;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BuffEffect")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BuffEffect, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut buff_uuid__ = None;
                let mut host_uuid__ = None;
                let mut trigger_time__ = None;
                let mut logic_effect__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<EBuffEventType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::BuffUuid => {
                            if buff_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffUuid"));
                            }
                            buff_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HostUuid => {
                            if host_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HostUuid"));
                            }
                            host_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TriggerTime => {
                            if trigger_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TriggerTime"));
                            }
                            trigger_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LogicEffect => {
                            if logic_effect__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LogicEffect"));
                            }
                            logic_effect__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BuffEffect {
                    r#type: r#type__,
                    buff_uuid: buff_uuid__,
                    host_uuid: host_uuid__,
                    trigger_time: trigger_time__,
                    logic_effect: logic_effect__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BuffEffect", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BuffEffectLogicInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.effect_type.is_some() {
            len += 1;
        }
        if self.raw_data.is_some() {
            len += 1;
        }
        if self.is_loop.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BuffEffectLogicInfo", len)?;
        if let Some(v) = self.effect_type.as_ref() {
            let v = EBuffEffectLogicPbType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("EffectType", &v)?;
        }
        if let Some(v) = self.raw_data.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RawData", pbjson::private::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.is_loop.as_ref() {
            struct_ser.serialize_field("IsLoop", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BuffEffectLogicInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EffectType",
            "RawData",
            "IsLoop",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EffectType,
            RawData,
            IsLoop,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EffectType" => Ok(GeneratedField::EffectType),
                            "RawData" => Ok(GeneratedField::RawData),
                            "IsLoop" => Ok(GeneratedField::IsLoop),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BuffEffectLogicInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BuffEffectLogicInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BuffEffectLogicInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut effect_type__ = None;
                let mut raw_data__ = None;
                let mut is_loop__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EffectType => {
                            if effect_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EffectType"));
                            }
                            effect_type__ = map_.next_value::<::std::option::Option<EBuffEffectLogicPbType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::RawData => {
                            if raw_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RawData"));
                            }
                            raw_data__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsLoop => {
                            if is_loop__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsLoop"));
                            }
                            is_loop__ = map_.next_value()?;
                        }
                    }
                }
                Ok(BuffEffectLogicInfo {
                    effect_type: effect_type__,
                    raw_data: raw_data__,
                    is_loop: is_loop__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BuffEffectLogicInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BuffEffectLogicTension {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target_uuid.is_some() {
            len += 1;
        }
        if !self.strength.is_empty() {
            len += 1;
        }
        if self.strength_length.is_some() {
            len += 1;
        }
        if self.max_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BuffEffectLogicTension", len)?;
        if let Some(v) = self.target_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetUuid", ToString::to_string(&v).as_str())?;
        }
        if !self.strength.is_empty() {
            struct_ser.serialize_field("Strength", &self.strength)?;
        }
        if let Some(v) = self.strength_length.as_ref() {
            struct_ser.serialize_field("StrengthLength", v)?;
        }
        if let Some(v) = self.max_length.as_ref() {
            struct_ser.serialize_field("MaxLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BuffEffectLogicTension {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetUuid",
            "Strength",
            "StrengthLength",
            "MaxLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetUuid,
            Strength,
            StrengthLength,
            MaxLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            "Strength" => Ok(GeneratedField::Strength),
                            "StrengthLength" => Ok(GeneratedField::StrengthLength),
                            "MaxLength" => Ok(GeneratedField::MaxLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BuffEffectLogicTension;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BuffEffectLogicTension")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BuffEffectLogicTension, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_uuid__ = None;
                let mut strength__ = None;
                let mut strength_length__ = None;
                let mut max_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Strength => {
                            if strength__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Strength"));
                            }
                            strength__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::StrengthLength => {
                            if strength_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StrengthLength"));
                            }
                            strength_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxLength => {
                            if max_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaxLength"));
                            }
                            max_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BuffEffectLogicTension {
                    target_uuid: target_uuid__,
                    strength: strength__.unwrap_or_default(),
                    strength_length: strength_length__,
                    max_length: max_length__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BuffEffectLogicTension", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BuffEffectSync {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if !self.buff_effects.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BuffEffectSync", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if !self.buff_effects.is_empty() {
            struct_ser.serialize_field("BuffEffects", &self.buff_effects)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BuffEffectSync {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "BuffEffects",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            BuffEffects,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "BuffEffects" => Ok(GeneratedField::BuffEffects),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BuffEffectSync;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BuffEffectSync")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BuffEffectSync, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut buff_effects__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BuffEffects => {
                            if buff_effects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffEffects"));
                            }
                            buff_effects__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BuffEffectSync {
                    uuid: uuid__,
                    buff_effects: buff_effects__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BuffEffectSync", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BuffInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.buff_uuid.is_some() {
            len += 1;
        }
        if self.base_id.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        if self.host_uuid.is_some() {
            len += 1;
        }
        if self.table_uuid.is_some() {
            len += 1;
        }
        if self.create_time.is_some() {
            len += 1;
        }
        if self.fire_uuid.is_some() {
            len += 1;
        }
        if self.layer.is_some() {
            len += 1;
        }
        if self.part_id.is_some() {
            len += 1;
        }
        if self.count.is_some() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        if self.fight_source_info.is_some() {
            len += 1;
        }
        if !self.logic_effect.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BuffInfo", len)?;
        if let Some(v) = self.buff_uuid.as_ref() {
            struct_ser.serialize_field("BuffUuid", v)?;
        }
        if let Some(v) = self.base_id.as_ref() {
            struct_ser.serialize_field("BaseId", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if let Some(v) = self.host_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HostUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.table_uuid.as_ref() {
            struct_ser.serialize_field("TableUuid", v)?;
        }
        if let Some(v) = self.create_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CreateTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.fire_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("FireUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.layer.as_ref() {
            struct_ser.serialize_field("Layer", v)?;
        }
        if let Some(v) = self.part_id.as_ref() {
            struct_ser.serialize_field("PartId", v)?;
        }
        if let Some(v) = self.count.as_ref() {
            struct_ser.serialize_field("Count", v)?;
        }
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("Duration", v)?;
        }
        if let Some(v) = self.fight_source_info.as_ref() {
            struct_ser.serialize_field("FightSourceInfo", v)?;
        }
        if !self.logic_effect.is_empty() {
            struct_ser.serialize_field("LogicEffect", &self.logic_effect)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BuffInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BuffUuid",
            "BaseId",
            "Level",
            "HostUuid",
            "TableUuid",
            "CreateTime",
            "FireUuid",
            "Layer",
            "PartId",
            "Count",
            "Duration",
            "FightSourceInfo",
            "LogicEffect",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BuffUuid,
            BaseId,
            Level,
            HostUuid,
            TableUuid,
            CreateTime,
            FireUuid,
            Layer,
            PartId,
            Count,
            Duration,
            FightSourceInfo,
            LogicEffect,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BuffUuid" => Ok(GeneratedField::BuffUuid),
                            "BaseId" => Ok(GeneratedField::BaseId),
                            "Level" => Ok(GeneratedField::Level),
                            "HostUuid" => Ok(GeneratedField::HostUuid),
                            "TableUuid" => Ok(GeneratedField::TableUuid),
                            "CreateTime" => Ok(GeneratedField::CreateTime),
                            "FireUuid" => Ok(GeneratedField::FireUuid),
                            "Layer" => Ok(GeneratedField::Layer),
                            "PartId" => Ok(GeneratedField::PartId),
                            "Count" => Ok(GeneratedField::Count),
                            "Duration" => Ok(GeneratedField::Duration),
                            "FightSourceInfo" => Ok(GeneratedField::FightSourceInfo),
                            "LogicEffect" => Ok(GeneratedField::LogicEffect),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BuffInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BuffInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BuffInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut buff_uuid__ = None;
                let mut base_id__ = None;
                let mut level__ = None;
                let mut host_uuid__ = None;
                let mut table_uuid__ = None;
                let mut create_time__ = None;
                let mut fire_uuid__ = None;
                let mut layer__ = None;
                let mut part_id__ = None;
                let mut count__ = None;
                let mut duration__ = None;
                let mut fight_source_info__ = None;
                let mut logic_effect__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BuffUuid => {
                            if buff_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffUuid"));
                            }
                            buff_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BaseId => {
                            if base_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BaseId"));
                            }
                            base_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HostUuid => {
                            if host_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HostUuid"));
                            }
                            host_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TableUuid => {
                            if table_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TableUuid"));
                            }
                            table_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CreateTime => {
                            if create_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateTime"));
                            }
                            create_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FireUuid => {
                            if fire_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FireUuid"));
                            }
                            fire_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Layer => {
                            if layer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Layer"));
                            }
                            layer__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PartId => {
                            if part_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartId"));
                            }
                            part_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Count"));
                            }
                            count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FightSourceInfo => {
                            if fight_source_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FightSourceInfo"));
                            }
                            fight_source_info__ = map_.next_value()?;
                        }
                        GeneratedField::LogicEffect => {
                            if logic_effect__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LogicEffect"));
                            }
                            logic_effect__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BuffInfo {
                    buff_uuid: buff_uuid__,
                    base_id: base_id__,
                    level: level__,
                    host_uuid: host_uuid__,
                    table_uuid: table_uuid__,
                    create_time: create_time__,
                    fire_uuid: fire_uuid__,
                    layer: layer__,
                    part_id: part_id__,
                    count: count__,
                    duration: duration__,
                    fight_source_info: fight_source_info__,
                    logic_effect: logic_effect__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BuffInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BuffInfoSync {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if !self.buff_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BuffInfoSync", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if !self.buff_infos.is_empty() {
            struct_ser.serialize_field("BuffInfos", &self.buff_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BuffInfoSync {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "BuffInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            BuffInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "BuffInfos" => Ok(GeneratedField::BuffInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BuffInfoSync;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BuffInfoSync")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BuffInfoSync, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut buff_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BuffInfos => {
                            if buff_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffInfos"));
                            }
                            buff_infos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BuffInfoSync {
                    uuid: uuid__,
                    buff_infos: buff_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BuffInfoSync", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BuffProfessionEffectData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.profession_type.is_some() {
            len += 1;
        }
        if !self.profession_point.is_empty() {
            len += 1;
        }
        if !self.profession_switch.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BuffProfessionEffectData", len)?;
        if let Some(v) = self.profession_type.as_ref() {
            struct_ser.serialize_field("ProfessionType", v)?;
        }
        if !self.profession_point.is_empty() {
            struct_ser.serialize_field("ProfessionPoint", &self.profession_point)?;
        }
        if !self.profession_switch.is_empty() {
            struct_ser.serialize_field("ProfessionSwitch", &self.profession_switch)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BuffProfessionEffectData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ProfessionType",
            "ProfessionPoint",
            "ProfessionSwitch",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ProfessionType,
            ProfessionPoint,
            ProfessionSwitch,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ProfessionType" => Ok(GeneratedField::ProfessionType),
                            "ProfessionPoint" => Ok(GeneratedField::ProfessionPoint),
                            "ProfessionSwitch" => Ok(GeneratedField::ProfessionSwitch),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BuffProfessionEffectData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BuffProfessionEffectData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BuffProfessionEffectData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut profession_type__ = None;
                let mut profession_point__ = None;
                let mut profession_switch__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ProfessionType => {
                            if profession_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfessionType"));
                            }
                            profession_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ProfessionPoint => {
                            if profession_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfessionPoint"));
                            }
                            profession_point__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::ProfessionSwitch => {
                            if profession_switch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfessionSwitch"));
                            }
                            profession_switch__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(BuffProfessionEffectData {
                    profession_type: profession_type__,
                    profession_point: profession_point__.unwrap_or_default(),
                    profession_switch: profession_switch__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BuffProfessionEffectData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BufferStream {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.buffer.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BufferStream", len)?;
        if let Some(v) = self.buffer.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Buffer", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BufferStream {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Buffer",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Buffer,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Buffer" => Ok(GeneratedField::Buffer),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BufferStream;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BufferStream")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BufferStream, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut buffer__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Buffer => {
                            if buffer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Buffer"));
                            }
                            buffer__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BufferStream {
                    buffer: buffer__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BufferStream", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BuildFurnitureOpType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::BuildFurnitureOpAdd => "BuildFurnitureOpAdd",
            Self::BuildFurnitureOpUpdate => "BuildFurnitureOpUpdate",
            Self::BuildFurnitureOpDelete => "BuildFurnitureOpDelete",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for BuildFurnitureOpType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BuildFurnitureOpAdd",
            "BuildFurnitureOpUpdate",
            "BuildFurnitureOpDelete",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BuildFurnitureOpType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "BuildFurnitureOpAdd" => Ok(BuildFurnitureOpType::BuildFurnitureOpAdd),
                    "BuildFurnitureOpUpdate" => Ok(BuildFurnitureOpType::BuildFurnitureOpUpdate),
                    "BuildFurnitureOpDelete" => Ok(BuildFurnitureOpType::BuildFurnitureOpDelete),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for BulletEvent {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if self.enter_stage_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.BulletEvent", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.enter_stage_id.as_ref() {
            struct_ser.serialize_field("EnterStageId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BulletEvent {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "EnterStageId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            EnterStageId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "EnterStageId" => Ok(GeneratedField::EnterStageId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BulletEvent;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.BulletEvent")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BulletEvent, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut enter_stage_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EnterStageId => {
                            if enter_stage_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnterStageId"));
                            }
                            enter_stage_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(BulletEvent {
                    uuid: uuid__,
                    enter_stage_id: enter_stage_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.BulletEvent", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CameraPatternType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Default => "Default",
            Self::SelfPhoto => "SelfPhoto",
            Self::Ar => "AR",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for CameraPatternType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Default",
            "SelfPhoto",
            "AR",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CameraPatternType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "Default" => Ok(CameraPatternType::Default),
                    "SelfPhoto" => Ok(CameraPatternType::SelfPhoto),
                    "AR" => Ok(CameraPatternType::Ar),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CameraSchemeType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::DefaultScheme => "DefaultScheme",
            Self::CustomScheme => "CustomScheme",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for CameraSchemeType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DefaultScheme",
            "CustomScheme",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CameraSchemeType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DefaultScheme" => Ok(CameraSchemeType::DefaultScheme),
                    "CustomScheme" => Ok(CameraSchemeType::CustomScheme),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ChallengeDungeonInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dungeon_info.is_empty() {
            len += 1;
        }
        if !self.dungeon_target_award.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ChallengeDungeonInfo", len)?;
        if !self.dungeon_info.is_empty() {
            struct_ser.serialize_field("DungeonInfo", &self.dungeon_info)?;
        }
        if !self.dungeon_target_award.is_empty() {
            struct_ser.serialize_field("DungeonTargetAward", &self.dungeon_target_award)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ChallengeDungeonInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonInfo",
            "DungeonTargetAward",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DungeonInfo,
            DungeonTargetAward,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DungeonInfo" => Ok(GeneratedField::DungeonInfo),
                            "DungeonTargetAward" => Ok(GeneratedField::DungeonTargetAward),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ChallengeDungeonInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ChallengeDungeonInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ChallengeDungeonInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dungeon_info__ = None;
                let mut dungeon_target_award__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DungeonInfo => {
                            if dungeon_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonInfo"));
                            }
                            dungeon_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::DungeonTargetAward => {
                            if dungeon_target_award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonTargetAward"));
                            }
                            dungeon_target_award__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ChallengeDungeonInfo {
                    dungeon_info: dungeon_info__.unwrap_or_default(),
                    dungeon_target_award: dungeon_target_award__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ChallengeDungeonInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ChangeCharFunctionState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.state_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ChangeCharFunctionState", len)?;
        if let Some(v) = self.state_type.as_ref() {
            let v = EActorState::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("StateType", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ChangeCharFunctionState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "StateType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StateType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "StateType" => Ok(GeneratedField::StateType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ChangeCharFunctionState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ChangeCharFunctionState")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ChangeCharFunctionState, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut state_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StateType => {
                            if state_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StateType"));
                            }
                            state_type__ = map_.next_value::<::std::option::Option<EActorState>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(ChangeCharFunctionState {
                    state_type: state_type__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ChangeCharFunctionState", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ChannelingEnd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_uuid.is_some() {
            len += 1;
        }
        if self.time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ChannelingEnd", len)?;
        if let Some(v) = self.skill_uuid.as_ref() {
            struct_ser.serialize_field("SkillUuid", v)?;
        }
        if let Some(v) = self.time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Time", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ChannelingEnd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillUuid",
            "Time",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillUuid,
            Time,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillUuid" => Ok(GeneratedField::SkillUuid),
                            "Time" => Ok(GeneratedField::Time),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ChannelingEnd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ChannelingEnd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ChannelingEnd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_uuid__ = None;
                let mut time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillUuid => {
                            if skill_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillUuid"));
                            }
                            skill_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Time"));
                            }
                            time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ChannelingEnd {
                    skill_uuid: skill_uuid__,
                    time: time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ChannelingEnd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CharBaseInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.char_id.is_some() {
            len += 1;
        }
        if self.account_id.is_some() {
            len += 1;
        }
        if self.show_id.is_some() {
            len += 1;
        }
        if self.server_id.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if self.gender.is_some() {
            len += 1;
        }
        if self.is_deleted.is_some() {
            len += 1;
        }
        if self.is_forbid.is_some() {
            len += 1;
        }
        if self.is_mute.is_some() {
            len += 1;
        }
        if self.x.is_some() {
            len += 1;
        }
        if self.y.is_some() {
            len += 1;
        }
        if self.z.is_some() {
            len += 1;
        }
        if self.dir.is_some() {
            len += 1;
        }
        if self.face_data.is_some() {
            len += 1;
        }
        if self.card_id.is_some() {
            len += 1;
        }
        if self.create_time.is_some() {
            len += 1;
        }
        if self.online_time.is_some() {
            len += 1;
        }
        if self.offline_time.is_some() {
            len += 1;
        }
        if self.profile_info.is_some() {
            len += 1;
        }
        if self.team_info.is_some() {
            len += 1;
        }
        if self.char_state.is_some() {
            len += 1;
        }
        if self.body_size.is_some() {
            len += 1;
        }
        if self.union_info.is_some() {
            len += 1;
        }
        if !self.personal_state.is_empty() {
            len += 1;
        }
        if self.avatar_info.is_some() {
            len += 1;
        }
        if self.total_online_time.is_some() {
            len += 1;
        }
        if self.open_id.is_some() {
            len += 1;
        }
        if self.sdk_type.is_some() {
            len += 1;
        }
        if self.os.is_some() {
            len += 1;
        }
        if self.init_profession_id.is_some() {
            len += 1;
        }
        if self.last_cal_total_time.is_some() {
            len += 1;
        }
        if self.area_id.is_some() {
            len += 1;
        }
        if self.client_version.is_some() {
            len += 1;
        }
        if self.fight_point.is_some() {
            len += 1;
        }
        if self.sum_save.is_some() {
            len += 1;
        }
        if self.client_resource_version.is_some() {
            len += 1;
        }
        if self.last_offline_time.is_some() {
            len += 1;
        }
        if self.day_acc_dur_time.is_some() {
            len += 1;
        }
        if self.last_acc_dur_timestamp.is_some() {
            len += 1;
        }
        if self.save_serial.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CharBaseInfo", len)?;
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.account_id.as_ref() {
            struct_ser.serialize_field("AccountId", v)?;
        }
        if let Some(v) = self.show_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ShowId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.server_id.as_ref() {
            struct_ser.serialize_field("ServerId", v)?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("Name", v)?;
        }
        if let Some(v) = self.gender.as_ref() {
            let v = EGender::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Gender", &v)?;
        }
        if let Some(v) = self.is_deleted.as_ref() {
            struct_ser.serialize_field("IsDeleted", v)?;
        }
        if let Some(v) = self.is_forbid.as_ref() {
            struct_ser.serialize_field("IsForbid", v)?;
        }
        if let Some(v) = self.is_mute.as_ref() {
            struct_ser.serialize_field("IsMute", v)?;
        }
        if let Some(v) = self.x.as_ref() {
            struct_ser.serialize_field("X", v)?;
        }
        if let Some(v) = self.y.as_ref() {
            struct_ser.serialize_field("Y", v)?;
        }
        if let Some(v) = self.z.as_ref() {
            struct_ser.serialize_field("Z", v)?;
        }
        if let Some(v) = self.dir.as_ref() {
            struct_ser.serialize_field("Dir", v)?;
        }
        if let Some(v) = self.face_data.as_ref() {
            struct_ser.serialize_field("FaceData", v)?;
        }
        if let Some(v) = self.card_id.as_ref() {
            struct_ser.serialize_field("CardId", v)?;
        }
        if let Some(v) = self.create_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CreateTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.online_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("OnlineTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.offline_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("OfflineTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.profile_info.as_ref() {
            struct_ser.serialize_field("ProfileInfo", v)?;
        }
        if let Some(v) = self.team_info.as_ref() {
            struct_ser.serialize_field("TeamInfo", v)?;
        }
        if let Some(v) = self.char_state.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharState", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.body_size.as_ref() {
            let v = EBodySize::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("BodySize", &v)?;
        }
        if let Some(v) = self.union_info.as_ref() {
            struct_ser.serialize_field("UnionInfo", v)?;
        }
        if !self.personal_state.is_empty() {
            struct_ser.serialize_field("PersonalState", &self.personal_state)?;
        }
        if let Some(v) = self.avatar_info.as_ref() {
            struct_ser.serialize_field("AvatarInfo", v)?;
        }
        if let Some(v) = self.total_online_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TotalOnlineTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.open_id.as_ref() {
            struct_ser.serialize_field("OpenId", v)?;
        }
        if let Some(v) = self.sdk_type.as_ref() {
            struct_ser.serialize_field("SdkType", v)?;
        }
        if let Some(v) = self.os.as_ref() {
            struct_ser.serialize_field("Os", v)?;
        }
        if let Some(v) = self.init_profession_id.as_ref() {
            struct_ser.serialize_field("InitProfessionId", v)?;
        }
        if let Some(v) = self.last_cal_total_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastCalTotalTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.area_id.as_ref() {
            struct_ser.serialize_field("AreaId", v)?;
        }
        if let Some(v) = self.client_version.as_ref() {
            struct_ser.serialize_field("ClientVersion", v)?;
        }
        if let Some(v) = self.fight_point.as_ref() {
            struct_ser.serialize_field("FightPoint", v)?;
        }
        if let Some(v) = self.sum_save.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SumSave", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.client_resource_version.as_ref() {
            struct_ser.serialize_field("ClientResourceVersion", v)?;
        }
        if let Some(v) = self.last_offline_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastOfflineTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.day_acc_dur_time.as_ref() {
            struct_ser.serialize_field("DayAccDurTime", v)?;
        }
        if let Some(v) = self.last_acc_dur_timestamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastAccDurTimestamp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.save_serial.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SaveSerial", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CharBaseInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CharId",
            "AccountId",
            "ShowId",
            "ServerId",
            "Name",
            "Gender",
            "IsDeleted",
            "IsForbid",
            "IsMute",
            "X",
            "Y",
            "Z",
            "Dir",
            "FaceData",
            "CardId",
            "CreateTime",
            "OnlineTime",
            "OfflineTime",
            "ProfileInfo",
            "TeamInfo",
            "CharState",
            "BodySize",
            "UnionInfo",
            "PersonalState",
            "AvatarInfo",
            "TotalOnlineTime",
            "OpenId",
            "SdkType",
            "Os",
            "InitProfessionId",
            "LastCalTotalTime",
            "AreaId",
            "ClientVersion",
            "FightPoint",
            "SumSave",
            "ClientResourceVersion",
            "LastOfflineTime",
            "DayAccDurTime",
            "LastAccDurTimestamp",
            "SaveSerial",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CharId,
            AccountId,
            ShowId,
            ServerId,
            Name,
            Gender,
            IsDeleted,
            IsForbid,
            IsMute,
            X,
            Y,
            Z,
            Dir,
            FaceData,
            CardId,
            CreateTime,
            OnlineTime,
            OfflineTime,
            ProfileInfo,
            TeamInfo,
            CharState,
            BodySize,
            UnionInfo,
            PersonalState,
            AvatarInfo,
            TotalOnlineTime,
            OpenId,
            SdkType,
            Os,
            InitProfessionId,
            LastCalTotalTime,
            AreaId,
            ClientVersion,
            FightPoint,
            SumSave,
            ClientResourceVersion,
            LastOfflineTime,
            DayAccDurTime,
            LastAccDurTimestamp,
            SaveSerial,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CharId" => Ok(GeneratedField::CharId),
                            "AccountId" => Ok(GeneratedField::AccountId),
                            "ShowId" => Ok(GeneratedField::ShowId),
                            "ServerId" => Ok(GeneratedField::ServerId),
                            "Name" => Ok(GeneratedField::Name),
                            "Gender" => Ok(GeneratedField::Gender),
                            "IsDeleted" => Ok(GeneratedField::IsDeleted),
                            "IsForbid" => Ok(GeneratedField::IsForbid),
                            "IsMute" => Ok(GeneratedField::IsMute),
                            "X" => Ok(GeneratedField::X),
                            "Y" => Ok(GeneratedField::Y),
                            "Z" => Ok(GeneratedField::Z),
                            "Dir" => Ok(GeneratedField::Dir),
                            "FaceData" => Ok(GeneratedField::FaceData),
                            "CardId" => Ok(GeneratedField::CardId),
                            "CreateTime" => Ok(GeneratedField::CreateTime),
                            "OnlineTime" => Ok(GeneratedField::OnlineTime),
                            "OfflineTime" => Ok(GeneratedField::OfflineTime),
                            "ProfileInfo" => Ok(GeneratedField::ProfileInfo),
                            "TeamInfo" => Ok(GeneratedField::TeamInfo),
                            "CharState" => Ok(GeneratedField::CharState),
                            "BodySize" => Ok(GeneratedField::BodySize),
                            "UnionInfo" => Ok(GeneratedField::UnionInfo),
                            "PersonalState" => Ok(GeneratedField::PersonalState),
                            "AvatarInfo" => Ok(GeneratedField::AvatarInfo),
                            "TotalOnlineTime" => Ok(GeneratedField::TotalOnlineTime),
                            "OpenId" => Ok(GeneratedField::OpenId),
                            "SdkType" => Ok(GeneratedField::SdkType),
                            "Os" => Ok(GeneratedField::Os),
                            "InitProfessionId" => Ok(GeneratedField::InitProfessionId),
                            "LastCalTotalTime" => Ok(GeneratedField::LastCalTotalTime),
                            "AreaId" => Ok(GeneratedField::AreaId),
                            "ClientVersion" => Ok(GeneratedField::ClientVersion),
                            "FightPoint" => Ok(GeneratedField::FightPoint),
                            "SumSave" => Ok(GeneratedField::SumSave),
                            "ClientResourceVersion" => Ok(GeneratedField::ClientResourceVersion),
                            "LastOfflineTime" => Ok(GeneratedField::LastOfflineTime),
                            "DayAccDurTime" => Ok(GeneratedField::DayAccDurTime),
                            "LastAccDurTimestamp" => Ok(GeneratedField::LastAccDurTimestamp),
                            "SaveSerial" => Ok(GeneratedField::SaveSerial),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CharBaseInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CharBaseInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CharBaseInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut char_id__ = None;
                let mut account_id__ = None;
                let mut show_id__ = None;
                let mut server_id__ = None;
                let mut name__ = None;
                let mut gender__ = None;
                let mut is_deleted__ = None;
                let mut is_forbid__ = None;
                let mut is_mute__ = None;
                let mut x__ = None;
                let mut y__ = None;
                let mut z__ = None;
                let mut dir__ = None;
                let mut face_data__ = None;
                let mut card_id__ = None;
                let mut create_time__ = None;
                let mut online_time__ = None;
                let mut offline_time__ = None;
                let mut profile_info__ = None;
                let mut team_info__ = None;
                let mut char_state__ = None;
                let mut body_size__ = None;
                let mut union_info__ = None;
                let mut personal_state__ = None;
                let mut avatar_info__ = None;
                let mut total_online_time__ = None;
                let mut open_id__ = None;
                let mut sdk_type__ = None;
                let mut os__ = None;
                let mut init_profession_id__ = None;
                let mut last_cal_total_time__ = None;
                let mut area_id__ = None;
                let mut client_version__ = None;
                let mut fight_point__ = None;
                let mut sum_save__ = None;
                let mut client_resource_version__ = None;
                let mut last_offline_time__ = None;
                let mut day_acc_dur_time__ = None;
                let mut last_acc_dur_timestamp__ = None;
                let mut save_serial__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AccountId => {
                            if account_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccountId"));
                            }
                            account_id__ = map_.next_value()?;
                        }
                        GeneratedField::ShowId => {
                            if show_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShowId"));
                            }
                            show_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ServerId => {
                            if server_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ServerId"));
                            }
                            server_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Gender => {
                            if gender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Gender"));
                            }
                            gender__ = map_.next_value::<::std::option::Option<EGender>>()?.map(|x| x as i32);
                        }
                        GeneratedField::IsDeleted => {
                            if is_deleted__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsDeleted"));
                            }
                            is_deleted__ = map_.next_value()?;
                        }
                        GeneratedField::IsForbid => {
                            if is_forbid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsForbid"));
                            }
                            is_forbid__ = map_.next_value()?;
                        }
                        GeneratedField::IsMute => {
                            if is_mute__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsMute"));
                            }
                            is_mute__ = map_.next_value()?;
                        }
                        GeneratedField::X => {
                            if x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("X"));
                            }
                            x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Y => {
                            if y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Y"));
                            }
                            y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Z => {
                            if z__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Z"));
                            }
                            z__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Dir => {
                            if dir__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Dir"));
                            }
                            dir__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FaceData => {
                            if face_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FaceData"));
                            }
                            face_data__ = map_.next_value()?;
                        }
                        GeneratedField::CardId => {
                            if card_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CardId"));
                            }
                            card_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CreateTime => {
                            if create_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateTime"));
                            }
                            create_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OnlineTime => {
                            if online_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OnlineTime"));
                            }
                            online_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OfflineTime => {
                            if offline_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OfflineTime"));
                            }
                            offline_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ProfileInfo => {
                            if profile_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfileInfo"));
                            }
                            profile_info__ = map_.next_value()?;
                        }
                        GeneratedField::TeamInfo => {
                            if team_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TeamInfo"));
                            }
                            team_info__ = map_.next_value()?;
                        }
                        GeneratedField::CharState => {
                            if char_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharState"));
                            }
                            char_state__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BodySize => {
                            if body_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BodySize"));
                            }
                            body_size__ = map_.next_value::<::std::option::Option<EBodySize>>()?.map(|x| x as i32);
                        }
                        GeneratedField::UnionInfo => {
                            if union_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnionInfo"));
                            }
                            union_info__ = map_.next_value()?;
                        }
                        GeneratedField::PersonalState => {
                            if personal_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PersonalState"));
                            }
                            personal_state__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::AvatarInfo => {
                            if avatar_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AvatarInfo"));
                            }
                            avatar_info__ = map_.next_value()?;
                        }
                        GeneratedField::TotalOnlineTime => {
                            if total_online_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TotalOnlineTime"));
                            }
                            total_online_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OpenId => {
                            if open_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OpenId"));
                            }
                            open_id__ = map_.next_value()?;
                        }
                        GeneratedField::SdkType => {
                            if sdk_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SdkType"));
                            }
                            sdk_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Os => {
                            if os__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Os"));
                            }
                            os__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::InitProfessionId => {
                            if init_profession_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InitProfessionId"));
                            }
                            init_profession_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastCalTotalTime => {
                            if last_cal_total_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastCalTotalTime"));
                            }
                            last_cal_total_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AreaId => {
                            if area_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AreaId"));
                            }
                            area_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ClientVersion => {
                            if client_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ClientVersion"));
                            }
                            client_version__ = map_.next_value()?;
                        }
                        GeneratedField::FightPoint => {
                            if fight_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FightPoint"));
                            }
                            fight_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SumSave => {
                            if sum_save__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SumSave"));
                            }
                            sum_save__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ClientResourceVersion => {
                            if client_resource_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ClientResourceVersion"));
                            }
                            client_resource_version__ = map_.next_value()?;
                        }
                        GeneratedField::LastOfflineTime => {
                            if last_offline_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastOfflineTime"));
                            }
                            last_offline_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DayAccDurTime => {
                            if day_acc_dur_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DayAccDurTime"));
                            }
                            day_acc_dur_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastAccDurTimestamp => {
                            if last_acc_dur_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastAccDurTimestamp"));
                            }
                            last_acc_dur_timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SaveSerial => {
                            if save_serial__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SaveSerial"));
                            }
                            save_serial__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CharBaseInfo {
                    char_id: char_id__,
                    account_id: account_id__,
                    show_id: show_id__,
                    server_id: server_id__,
                    name: name__,
                    gender: gender__,
                    is_deleted: is_deleted__,
                    is_forbid: is_forbid__,
                    is_mute: is_mute__,
                    x: x__,
                    y: y__,
                    z: z__,
                    dir: dir__,
                    face_data: face_data__,
                    card_id: card_id__,
                    create_time: create_time__,
                    online_time: online_time__,
                    offline_time: offline_time__,
                    profile_info: profile_info__,
                    team_info: team_info__,
                    char_state: char_state__,
                    body_size: body_size__,
                    union_info: union_info__,
                    personal_state: personal_state__.unwrap_or_default(),
                    avatar_info: avatar_info__,
                    total_online_time: total_online_time__,
                    open_id: open_id__,
                    sdk_type: sdk_type__,
                    os: os__,
                    init_profession_id: init_profession_id__,
                    last_cal_total_time: last_cal_total_time__,
                    area_id: area_id__,
                    client_version: client_version__,
                    fight_point: fight_point__,
                    sum_save: sum_save__,
                    client_resource_version: client_resource_version__,
                    last_offline_time: last_offline_time__,
                    day_acc_dur_time: day_acc_dur_time__,
                    last_acc_dur_timestamp: last_acc_dur_timestamp__,
                    save_serial: save_serial__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CharBaseInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CharSerialize {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.char_id.is_some() {
            len += 1;
        }
        if self.char_base.is_some() {
            len += 1;
        }
        if self.scene_data.is_some() {
            len += 1;
        }
        if self.scene_lua_data.is_some() {
            len += 1;
        }
        if self.pioneer_data.is_some() {
            len += 1;
        }
        if self.buff_info.is_some() {
            len += 1;
        }
        if self.item_package.is_some() {
            len += 1;
        }
        if self.quest_list.is_some() {
            len += 1;
        }
        if self.setting_data.is_some() {
            len += 1;
        }
        if self.misc_info.is_some() {
            len += 1;
        }
        if self.exchange_items.is_some() {
            len += 1;
        }
        if self.equip.is_some() {
            len += 1;
        }
        if self.energy_item.is_some() {
            len += 1;
        }
        if self.map_data.is_some() {
            len += 1;
        }
        if self.dungeon_list.is_some() {
            len += 1;
        }
        if self.attr.is_some() {
            len += 1;
        }
        if self.fashion.is_some() {
            len += 1;
        }
        if self.profile_list.is_some() {
            len += 1;
        }
        if self.help.is_some() {
            len += 1;
        }
        if self.counter_list.is_some() {
            len += 1;
        }
        if self.personal_obj.is_some() {
            len += 1;
        }
        if self.role_level.is_some() {
            len += 1;
        }
        if self.pivot.is_some() {
            len += 1;
        }
        if self.transfer_point.is_some() {
            len += 1;
        }
        if self.planet_memory.is_some() {
            len += 1;
        }
        if self.planet_memory_target.is_some() {
            len += 1;
        }
        if self.red_dot.is_some() {
            len += 1;
        }
        if self.resonance.is_some() {
            len += 1;
        }
        if self.cuts_state.is_some() {
            len += 1;
        }
        if self.investigate_list.is_some() {
            len += 1;
        }
        if self.records.is_some() {
            len += 1;
        }
        if self.interaction.is_some() {
            len += 1;
        }
        if self.season_quest_list.is_some() {
            len += 1;
        }
        if self.role_face.is_some() {
            len += 1;
        }
        if self.map_book_list.is_some() {
            len += 1;
        }
        if self.function_data.is_some() {
            len += 1;
        }
        if self.anti_info.is_some() {
            len += 1;
        }
        if self.monster_explore_list.is_some() {
            len += 1;
        }
        if self.show_piece_data.is_some() {
            len += 1;
        }
        if self.collection_book.is_some() {
            len += 1;
        }
        if self.not_get_proceed_award_times.is_some() {
            len += 1;
        }
        if self.cook_list.is_some() {
            len += 1;
        }
        if self.refresh_data_list.is_some() {
            len += 1;
        }
        if self.challenge_dungeon_info.is_some() {
            len += 1;
        }
        if self.sync_award_data.is_some() {
            len += 1;
        }
        if self.season_achievement_list.is_some() {
            len += 1;
        }
        if self.season_rank_list.is_some() {
            len += 1;
        }
        if self.season_center.is_some() {
            len += 1;
        }
        if self.personal_zone.is_some() {
            len += 1;
        }
        if self.season_medal_info.is_some() {
            len += 1;
        }
        if self.community_home_info.is_some() {
            len += 1;
        }
        if self.season_activation.is_some() {
            len += 1;
        }
        if self.slots.is_some() {
            len += 1;
        }
        if self.monster_hunt_info.is_some() {
            len += 1;
        }
        if self.r#mod.is_some() {
            len += 1;
        }
        if self.world_event_map.is_some() {
            len += 1;
        }
        if self.fish_setting.is_some() {
            len += 1;
        }
        if self.freight_data.is_some() {
            len += 1;
        }
        if self.profession_list.is_some() {
            len += 1;
        }
        if self.trial_road.is_some() {
            len += 1;
        }
        if self.gasha_data.is_some() {
            len += 1;
        }
        if self.shop_data.is_some() {
            len += 1;
        }
        if self.personal_world_boss_info.is_some() {
            len += 1;
        }
        if self.craft_energy.is_some() {
            len += 1;
        }
        if self.weekly_tower.is_some() {
            len += 1;
        }
        if self.cut_scene_infos.is_some() {
            len += 1;
        }
        if self.recommend_play_data.is_some() {
            len += 1;
        }
        if self.ride_list.is_some() {
            len += 1;
        }
        if self.pay_order_list.is_some() {
            len += 1;
        }
        if self.life_profession.is_some() {
            len += 1;
        }
        if self.life_profession_work.is_some() {
            len += 1;
        }
        if self.user_activity_list.is_some() {
            len += 1;
        }
        if self.player_record.is_some() {
            len += 1;
        }
        if self.drop_container.is_some() {
            len += 1;
        }
        if self.monthly_card.is_some() {
            len += 1;
        }
        if self.fashion_benefit.is_some() {
            len += 1;
        }
        if self.item_currency.is_some() {
            len += 1;
        }
        if self.privilege_effect_data.is_some() {
            len += 1;
        }
        if self.treasure.is_some() {
            len += 1;
        }
        if self.unlock_emoji_data.is_some() {
            len += 1;
        }
        if self.player_order_comtainer_info.is_some() {
            len += 1;
        }
        if self.player_box.is_some() {
            len += 1;
        }
        if self.launch_privilege_data.is_some() {
            len += 1;
        }
        if self.battle_pass_data.is_some() {
            len += 1;
        }
        if self.recharge_data.is_some() {
            len += 1;
        }
        if self.lucky_value_mgr.is_some() {
            len += 1;
        }
        if self.handbook_data.is_some() {
            len += 1;
        }
        if self.master_mode_dungeon_info.is_some() {
            len += 1;
        }
        if self.statistics_data.is_some() {
            len += 1;
        }
        if self.compenstion_statistics.is_some() {
            len += 1;
        }
        if self.bubble_act_data.is_some() {
            len += 1;
        }
        if self.mail_claimed_info.is_some() {
            len += 1;
        }
        if self.newbie_data.is_some() {
            len += 1;
        }
        if self.fight_point.is_some() {
            len += 1;
        }
        if self.sign.is_some() {
            len += 1;
        }
        if self.char_statistics_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CharSerialize", len)?;
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.char_base.as_ref() {
            struct_ser.serialize_field("CharBase", v)?;
        }
        if let Some(v) = self.scene_data.as_ref() {
            struct_ser.serialize_field("SceneData", v)?;
        }
        if let Some(v) = self.scene_lua_data.as_ref() {
            struct_ser.serialize_field("SceneLuaData", v)?;
        }
        if let Some(v) = self.pioneer_data.as_ref() {
            struct_ser.serialize_field("PioneerData", v)?;
        }
        if let Some(v) = self.buff_info.as_ref() {
            struct_ser.serialize_field("BuffInfo", v)?;
        }
        if let Some(v) = self.item_package.as_ref() {
            struct_ser.serialize_field("ItemPackage", v)?;
        }
        if let Some(v) = self.quest_list.as_ref() {
            struct_ser.serialize_field("QuestList", v)?;
        }
        if let Some(v) = self.setting_data.as_ref() {
            struct_ser.serialize_field("SettingData", v)?;
        }
        if let Some(v) = self.misc_info.as_ref() {
            struct_ser.serialize_field("MiscInfo", v)?;
        }
        if let Some(v) = self.exchange_items.as_ref() {
            struct_ser.serialize_field("ExchangeItems", v)?;
        }
        if let Some(v) = self.equip.as_ref() {
            struct_ser.serialize_field("Equip", v)?;
        }
        if let Some(v) = self.energy_item.as_ref() {
            struct_ser.serialize_field("EnergyItem", v)?;
        }
        if let Some(v) = self.map_data.as_ref() {
            struct_ser.serialize_field("MapData", v)?;
        }
        if let Some(v) = self.dungeon_list.as_ref() {
            struct_ser.serialize_field("DungeonList", v)?;
        }
        if let Some(v) = self.attr.as_ref() {
            struct_ser.serialize_field("Attr", v)?;
        }
        if let Some(v) = self.fashion.as_ref() {
            struct_ser.serialize_field("Fashion", v)?;
        }
        if let Some(v) = self.profile_list.as_ref() {
            struct_ser.serialize_field("ProfileList", v)?;
        }
        if let Some(v) = self.help.as_ref() {
            struct_ser.serialize_field("Help", v)?;
        }
        if let Some(v) = self.counter_list.as_ref() {
            struct_ser.serialize_field("CounterList", v)?;
        }
        if let Some(v) = self.personal_obj.as_ref() {
            struct_ser.serialize_field("PersonalObj", v)?;
        }
        if let Some(v) = self.role_level.as_ref() {
            struct_ser.serialize_field("RoleLevel", v)?;
        }
        if let Some(v) = self.pivot.as_ref() {
            struct_ser.serialize_field("Pivot", v)?;
        }
        if let Some(v) = self.transfer_point.as_ref() {
            struct_ser.serialize_field("TransferPoint", v)?;
        }
        if let Some(v) = self.planet_memory.as_ref() {
            struct_ser.serialize_field("PlanetMemory", v)?;
        }
        if let Some(v) = self.planet_memory_target.as_ref() {
            struct_ser.serialize_field("PlanetMemoryTarget", v)?;
        }
        if let Some(v) = self.red_dot.as_ref() {
            struct_ser.serialize_field("RedDot", v)?;
        }
        if let Some(v) = self.resonance.as_ref() {
            struct_ser.serialize_field("Resonance", v)?;
        }
        if let Some(v) = self.cuts_state.as_ref() {
            struct_ser.serialize_field("CutsState", v)?;
        }
        if let Some(v) = self.investigate_list.as_ref() {
            struct_ser.serialize_field("InvestigateList", v)?;
        }
        if let Some(v) = self.records.as_ref() {
            struct_ser.serialize_field("Records", v)?;
        }
        if let Some(v) = self.interaction.as_ref() {
            struct_ser.serialize_field("Interaction", v)?;
        }
        if let Some(v) = self.season_quest_list.as_ref() {
            struct_ser.serialize_field("SeasonQuestList", v)?;
        }
        if let Some(v) = self.role_face.as_ref() {
            struct_ser.serialize_field("RoleFace", v)?;
        }
        if let Some(v) = self.map_book_list.as_ref() {
            struct_ser.serialize_field("MapBookList", v)?;
        }
        if let Some(v) = self.function_data.as_ref() {
            struct_ser.serialize_field("FunctionData", v)?;
        }
        if let Some(v) = self.anti_info.as_ref() {
            struct_ser.serialize_field("AntiInfo", v)?;
        }
        if let Some(v) = self.monster_explore_list.as_ref() {
            struct_ser.serialize_field("MonsterExploreList", v)?;
        }
        if let Some(v) = self.show_piece_data.as_ref() {
            struct_ser.serialize_field("ShowPieceData", v)?;
        }
        if let Some(v) = self.collection_book.as_ref() {
            struct_ser.serialize_field("CollectionBook", v)?;
        }
        if let Some(v) = self.not_get_proceed_award_times.as_ref() {
            struct_ser.serialize_field("NotGetProceedAwardTimes", v)?;
        }
        if let Some(v) = self.cook_list.as_ref() {
            struct_ser.serialize_field("CookList", v)?;
        }
        if let Some(v) = self.refresh_data_list.as_ref() {
            struct_ser.serialize_field("RefreshDataList", v)?;
        }
        if let Some(v) = self.challenge_dungeon_info.as_ref() {
            struct_ser.serialize_field("ChallengeDungeonInfo", v)?;
        }
        if let Some(v) = self.sync_award_data.as_ref() {
            struct_ser.serialize_field("SyncAwardData", v)?;
        }
        if let Some(v) = self.season_achievement_list.as_ref() {
            struct_ser.serialize_field("SeasonAchievementList", v)?;
        }
        if let Some(v) = self.season_rank_list.as_ref() {
            struct_ser.serialize_field("SeasonRankList", v)?;
        }
        if let Some(v) = self.season_center.as_ref() {
            struct_ser.serialize_field("SeasonCenter", v)?;
        }
        if let Some(v) = self.personal_zone.as_ref() {
            struct_ser.serialize_field("PersonalZone", v)?;
        }
        if let Some(v) = self.season_medal_info.as_ref() {
            struct_ser.serialize_field("SeasonMedalInfo", v)?;
        }
        if let Some(v) = self.community_home_info.as_ref() {
            struct_ser.serialize_field("CommunityHomeInfo", v)?;
        }
        if let Some(v) = self.season_activation.as_ref() {
            struct_ser.serialize_field("SeasonActivation", v)?;
        }
        if let Some(v) = self.slots.as_ref() {
            struct_ser.serialize_field("Slots", v)?;
        }
        if let Some(v) = self.monster_hunt_info.as_ref() {
            struct_ser.serialize_field("MonsterHuntInfo", v)?;
        }
        if let Some(v) = self.r#mod.as_ref() {
            struct_ser.serialize_field("Mod", v)?;
        }
        if let Some(v) = self.world_event_map.as_ref() {
            struct_ser.serialize_field("WorldEventMap", v)?;
        }
        if let Some(v) = self.fish_setting.as_ref() {
            struct_ser.serialize_field("FishSetting", v)?;
        }
        if let Some(v) = self.freight_data.as_ref() {
            struct_ser.serialize_field("FreightData", v)?;
        }
        if let Some(v) = self.profession_list.as_ref() {
            struct_ser.serialize_field("ProfessionList", v)?;
        }
        if let Some(v) = self.trial_road.as_ref() {
            struct_ser.serialize_field("TrialRoad", v)?;
        }
        if let Some(v) = self.gasha_data.as_ref() {
            struct_ser.serialize_field("GashaData", v)?;
        }
        if let Some(v) = self.shop_data.as_ref() {
            struct_ser.serialize_field("ShopData", v)?;
        }
        if let Some(v) = self.personal_world_boss_info.as_ref() {
            struct_ser.serialize_field("PersonalWorldBossInfo", v)?;
        }
        if let Some(v) = self.craft_energy.as_ref() {
            struct_ser.serialize_field("CraftEnergy", v)?;
        }
        if let Some(v) = self.weekly_tower.as_ref() {
            struct_ser.serialize_field("WeeklyTower", v)?;
        }
        if let Some(v) = self.cut_scene_infos.as_ref() {
            struct_ser.serialize_field("CutSceneInfos", v)?;
        }
        if let Some(v) = self.recommend_play_data.as_ref() {
            struct_ser.serialize_field("RecommendPlayData", v)?;
        }
        if let Some(v) = self.ride_list.as_ref() {
            struct_ser.serialize_field("RideList", v)?;
        }
        if let Some(v) = self.pay_order_list.as_ref() {
            struct_ser.serialize_field("PayOrderList", v)?;
        }
        if let Some(v) = self.life_profession.as_ref() {
            struct_ser.serialize_field("LifeProfession", v)?;
        }
        if let Some(v) = self.life_profession_work.as_ref() {
            struct_ser.serialize_field("LifeProfessionWork", v)?;
        }
        if let Some(v) = self.user_activity_list.as_ref() {
            struct_ser.serialize_field("UserActivityList", v)?;
        }
        if let Some(v) = self.player_record.as_ref() {
            struct_ser.serialize_field("PlayerRecord", v)?;
        }
        if let Some(v) = self.drop_container.as_ref() {
            struct_ser.serialize_field("DropContainer", v)?;
        }
        if let Some(v) = self.monthly_card.as_ref() {
            struct_ser.serialize_field("MonthlyCard", v)?;
        }
        if let Some(v) = self.fashion_benefit.as_ref() {
            struct_ser.serialize_field("FashionBenefit", v)?;
        }
        if let Some(v) = self.item_currency.as_ref() {
            struct_ser.serialize_field("ItemCurrency", v)?;
        }
        if let Some(v) = self.privilege_effect_data.as_ref() {
            struct_ser.serialize_field("PrivilegeEffectData", v)?;
        }
        if let Some(v) = self.treasure.as_ref() {
            struct_ser.serialize_field("Treasure", v)?;
        }
        if let Some(v) = self.unlock_emoji_data.as_ref() {
            struct_ser.serialize_field("UnlockEmojiData", v)?;
        }
        if let Some(v) = self.player_order_comtainer_info.as_ref() {
            struct_ser.serialize_field("PlayerOrderComtainerInfo", v)?;
        }
        if let Some(v) = self.player_box.as_ref() {
            struct_ser.serialize_field("PlayerBox", v)?;
        }
        if let Some(v) = self.launch_privilege_data.as_ref() {
            struct_ser.serialize_field("LaunchPrivilegeData", v)?;
        }
        if let Some(v) = self.battle_pass_data.as_ref() {
            struct_ser.serialize_field("BattlePassData", v)?;
        }
        if let Some(v) = self.recharge_data.as_ref() {
            struct_ser.serialize_field("RechargeData", v)?;
        }
        if let Some(v) = self.lucky_value_mgr.as_ref() {
            struct_ser.serialize_field("LuckyValueMgr", v)?;
        }
        if let Some(v) = self.handbook_data.as_ref() {
            struct_ser.serialize_field("HandbookData", v)?;
        }
        if let Some(v) = self.master_mode_dungeon_info.as_ref() {
            struct_ser.serialize_field("MasterModeDungeonInfo", v)?;
        }
        if let Some(v) = self.statistics_data.as_ref() {
            struct_ser.serialize_field("StatisticsData", v)?;
        }
        if let Some(v) = self.compenstion_statistics.as_ref() {
            struct_ser.serialize_field("CompenstionStatistics", v)?;
        }
        if let Some(v) = self.bubble_act_data.as_ref() {
            struct_ser.serialize_field("BubbleActData", v)?;
        }
        if let Some(v) = self.mail_claimed_info.as_ref() {
            struct_ser.serialize_field("MailClaimedInfo", v)?;
        }
        if let Some(v) = self.newbie_data.as_ref() {
            struct_ser.serialize_field("NewbieData", v)?;
        }
        if let Some(v) = self.fight_point.as_ref() {
            struct_ser.serialize_field("FightPoint", v)?;
        }
        if let Some(v) = self.sign.as_ref() {
            struct_ser.serialize_field("Sign", v)?;
        }
        if let Some(v) = self.char_statistics_data.as_ref() {
            struct_ser.serialize_field("CharStatisticsData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CharSerialize {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CharId",
            "CharBase",
            "SceneData",
            "SceneLuaData",
            "PioneerData",
            "BuffInfo",
            "ItemPackage",
            "QuestList",
            "SettingData",
            "MiscInfo",
            "ExchangeItems",
            "Equip",
            "EnergyItem",
            "MapData",
            "DungeonList",
            "Attr",
            "Fashion",
            "ProfileList",
            "Help",
            "CounterList",
            "PersonalObj",
            "RoleLevel",
            "Pivot",
            "TransferPoint",
            "PlanetMemory",
            "PlanetMemoryTarget",
            "RedDot",
            "Resonance",
            "CutsState",
            "InvestigateList",
            "Records",
            "Interaction",
            "SeasonQuestList",
            "RoleFace",
            "MapBookList",
            "FunctionData",
            "AntiInfo",
            "MonsterExploreList",
            "ShowPieceData",
            "CollectionBook",
            "NotGetProceedAwardTimes",
            "CookList",
            "RefreshDataList",
            "ChallengeDungeonInfo",
            "SyncAwardData",
            "SeasonAchievementList",
            "SeasonRankList",
            "SeasonCenter",
            "PersonalZone",
            "SeasonMedalInfo",
            "CommunityHomeInfo",
            "SeasonActivation",
            "Slots",
            "MonsterHuntInfo",
            "Mod",
            "WorldEventMap",
            "FishSetting",
            "FreightData",
            "ProfessionList",
            "TrialRoad",
            "GashaData",
            "ShopData",
            "PersonalWorldBossInfo",
            "CraftEnergy",
            "WeeklyTower",
            "CutSceneInfos",
            "RecommendPlayData",
            "RideList",
            "PayOrderList",
            "LifeProfession",
            "LifeProfessionWork",
            "UserActivityList",
            "PlayerRecord",
            "DropContainer",
            "MonthlyCard",
            "FashionBenefit",
            "ItemCurrency",
            "PrivilegeEffectData",
            "Treasure",
            "UnlockEmojiData",
            "PlayerOrderComtainerInfo",
            "PlayerBox",
            "LaunchPrivilegeData",
            "BattlePassData",
            "RechargeData",
            "LuckyValueMgr",
            "HandbookData",
            "MasterModeDungeonInfo",
            "StatisticsData",
            "CompenstionStatistics",
            "BubbleActData",
            "MailClaimedInfo",
            "NewbieData",
            "FightPoint",
            "Sign",
            "CharStatisticsData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CharId,
            CharBase,
            SceneData,
            SceneLuaData,
            PioneerData,
            BuffInfo,
            ItemPackage,
            QuestList,
            SettingData,
            MiscInfo,
            ExchangeItems,
            Equip,
            EnergyItem,
            MapData,
            DungeonList,
            Attr,
            Fashion,
            ProfileList,
            Help,
            CounterList,
            PersonalObj,
            RoleLevel,
            Pivot,
            TransferPoint,
            PlanetMemory,
            PlanetMemoryTarget,
            RedDot,
            Resonance,
            CutsState,
            InvestigateList,
            Records,
            Interaction,
            SeasonQuestList,
            RoleFace,
            MapBookList,
            FunctionData,
            AntiInfo,
            MonsterExploreList,
            ShowPieceData,
            CollectionBook,
            NotGetProceedAwardTimes,
            CookList,
            RefreshDataList,
            ChallengeDungeonInfo,
            SyncAwardData,
            SeasonAchievementList,
            SeasonRankList,
            SeasonCenter,
            PersonalZone,
            SeasonMedalInfo,
            CommunityHomeInfo,
            SeasonActivation,
            Slots,
            MonsterHuntInfo,
            Mod,
            WorldEventMap,
            FishSetting,
            FreightData,
            ProfessionList,
            TrialRoad,
            GashaData,
            ShopData,
            PersonalWorldBossInfo,
            CraftEnergy,
            WeeklyTower,
            CutSceneInfos,
            RecommendPlayData,
            RideList,
            PayOrderList,
            LifeProfession,
            LifeProfessionWork,
            UserActivityList,
            PlayerRecord,
            DropContainer,
            MonthlyCard,
            FashionBenefit,
            ItemCurrency,
            PrivilegeEffectData,
            Treasure,
            UnlockEmojiData,
            PlayerOrderComtainerInfo,
            PlayerBox,
            LaunchPrivilegeData,
            BattlePassData,
            RechargeData,
            LuckyValueMgr,
            HandbookData,
            MasterModeDungeonInfo,
            StatisticsData,
            CompenstionStatistics,
            BubbleActData,
            MailClaimedInfo,
            NewbieData,
            FightPoint,
            Sign,
            CharStatisticsData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CharId" => Ok(GeneratedField::CharId),
                            "CharBase" => Ok(GeneratedField::CharBase),
                            "SceneData" => Ok(GeneratedField::SceneData),
                            "SceneLuaData" => Ok(GeneratedField::SceneLuaData),
                            "PioneerData" => Ok(GeneratedField::PioneerData),
                            "BuffInfo" => Ok(GeneratedField::BuffInfo),
                            "ItemPackage" => Ok(GeneratedField::ItemPackage),
                            "QuestList" => Ok(GeneratedField::QuestList),
                            "SettingData" => Ok(GeneratedField::SettingData),
                            "MiscInfo" => Ok(GeneratedField::MiscInfo),
                            "ExchangeItems" => Ok(GeneratedField::ExchangeItems),
                            "Equip" => Ok(GeneratedField::Equip),
                            "EnergyItem" => Ok(GeneratedField::EnergyItem),
                            "MapData" => Ok(GeneratedField::MapData),
                            "DungeonList" => Ok(GeneratedField::DungeonList),
                            "Attr" => Ok(GeneratedField::Attr),
                            "Fashion" => Ok(GeneratedField::Fashion),
                            "ProfileList" => Ok(GeneratedField::ProfileList),
                            "Help" => Ok(GeneratedField::Help),
                            "CounterList" => Ok(GeneratedField::CounterList),
                            "PersonalObj" => Ok(GeneratedField::PersonalObj),
                            "RoleLevel" => Ok(GeneratedField::RoleLevel),
                            "Pivot" => Ok(GeneratedField::Pivot),
                            "TransferPoint" => Ok(GeneratedField::TransferPoint),
                            "PlanetMemory" => Ok(GeneratedField::PlanetMemory),
                            "PlanetMemoryTarget" => Ok(GeneratedField::PlanetMemoryTarget),
                            "RedDot" => Ok(GeneratedField::RedDot),
                            "Resonance" => Ok(GeneratedField::Resonance),
                            "CutsState" => Ok(GeneratedField::CutsState),
                            "InvestigateList" => Ok(GeneratedField::InvestigateList),
                            "Records" => Ok(GeneratedField::Records),
                            "Interaction" => Ok(GeneratedField::Interaction),
                            "SeasonQuestList" => Ok(GeneratedField::SeasonQuestList),
                            "RoleFace" => Ok(GeneratedField::RoleFace),
                            "MapBookList" => Ok(GeneratedField::MapBookList),
                            "FunctionData" => Ok(GeneratedField::FunctionData),
                            "AntiInfo" => Ok(GeneratedField::AntiInfo),
                            "MonsterExploreList" => Ok(GeneratedField::MonsterExploreList),
                            "ShowPieceData" => Ok(GeneratedField::ShowPieceData),
                            "CollectionBook" => Ok(GeneratedField::CollectionBook),
                            "NotGetProceedAwardTimes" => Ok(GeneratedField::NotGetProceedAwardTimes),
                            "CookList" => Ok(GeneratedField::CookList),
                            "RefreshDataList" => Ok(GeneratedField::RefreshDataList),
                            "ChallengeDungeonInfo" => Ok(GeneratedField::ChallengeDungeonInfo),
                            "SyncAwardData" => Ok(GeneratedField::SyncAwardData),
                            "SeasonAchievementList" => Ok(GeneratedField::SeasonAchievementList),
                            "SeasonRankList" => Ok(GeneratedField::SeasonRankList),
                            "SeasonCenter" => Ok(GeneratedField::SeasonCenter),
                            "PersonalZone" => Ok(GeneratedField::PersonalZone),
                            "SeasonMedalInfo" => Ok(GeneratedField::SeasonMedalInfo),
                            "CommunityHomeInfo" => Ok(GeneratedField::CommunityHomeInfo),
                            "SeasonActivation" => Ok(GeneratedField::SeasonActivation),
                            "Slots" => Ok(GeneratedField::Slots),
                            "MonsterHuntInfo" => Ok(GeneratedField::MonsterHuntInfo),
                            "Mod" => Ok(GeneratedField::Mod),
                            "WorldEventMap" => Ok(GeneratedField::WorldEventMap),
                            "FishSetting" => Ok(GeneratedField::FishSetting),
                            "FreightData" => Ok(GeneratedField::FreightData),
                            "ProfessionList" => Ok(GeneratedField::ProfessionList),
                            "TrialRoad" => Ok(GeneratedField::TrialRoad),
                            "GashaData" => Ok(GeneratedField::GashaData),
                            "ShopData" => Ok(GeneratedField::ShopData),
                            "PersonalWorldBossInfo" => Ok(GeneratedField::PersonalWorldBossInfo),
                            "CraftEnergy" => Ok(GeneratedField::CraftEnergy),
                            "WeeklyTower" => Ok(GeneratedField::WeeklyTower),
                            "CutSceneInfos" => Ok(GeneratedField::CutSceneInfos),
                            "RecommendPlayData" => Ok(GeneratedField::RecommendPlayData),
                            "RideList" => Ok(GeneratedField::RideList),
                            "PayOrderList" => Ok(GeneratedField::PayOrderList),
                            "LifeProfession" => Ok(GeneratedField::LifeProfession),
                            "LifeProfessionWork" => Ok(GeneratedField::LifeProfessionWork),
                            "UserActivityList" => Ok(GeneratedField::UserActivityList),
                            "PlayerRecord" => Ok(GeneratedField::PlayerRecord),
                            "DropContainer" => Ok(GeneratedField::DropContainer),
                            "MonthlyCard" => Ok(GeneratedField::MonthlyCard),
                            "FashionBenefit" => Ok(GeneratedField::FashionBenefit),
                            "ItemCurrency" => Ok(GeneratedField::ItemCurrency),
                            "PrivilegeEffectData" => Ok(GeneratedField::PrivilegeEffectData),
                            "Treasure" => Ok(GeneratedField::Treasure),
                            "UnlockEmojiData" => Ok(GeneratedField::UnlockEmojiData),
                            "PlayerOrderComtainerInfo" => Ok(GeneratedField::PlayerOrderComtainerInfo),
                            "PlayerBox" => Ok(GeneratedField::PlayerBox),
                            "LaunchPrivilegeData" => Ok(GeneratedField::LaunchPrivilegeData),
                            "BattlePassData" => Ok(GeneratedField::BattlePassData),
                            "RechargeData" => Ok(GeneratedField::RechargeData),
                            "LuckyValueMgr" => Ok(GeneratedField::LuckyValueMgr),
                            "HandbookData" => Ok(GeneratedField::HandbookData),
                            "MasterModeDungeonInfo" => Ok(GeneratedField::MasterModeDungeonInfo),
                            "StatisticsData" => Ok(GeneratedField::StatisticsData),
                            "CompenstionStatistics" => Ok(GeneratedField::CompenstionStatistics),
                            "BubbleActData" => Ok(GeneratedField::BubbleActData),
                            "MailClaimedInfo" => Ok(GeneratedField::MailClaimedInfo),
                            "NewbieData" => Ok(GeneratedField::NewbieData),
                            "FightPoint" => Ok(GeneratedField::FightPoint),
                            "Sign" => Ok(GeneratedField::Sign),
                            "CharStatisticsData" => Ok(GeneratedField::CharStatisticsData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CharSerialize;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CharSerialize")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CharSerialize, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut char_id__ = None;
                let mut char_base__ = None;
                let mut scene_data__ = None;
                let mut scene_lua_data__ = None;
                let mut pioneer_data__ = None;
                let mut buff_info__ = None;
                let mut item_package__ = None;
                let mut quest_list__ = None;
                let mut setting_data__ = None;
                let mut misc_info__ = None;
                let mut exchange_items__ = None;
                let mut equip__ = None;
                let mut energy_item__ = None;
                let mut map_data__ = None;
                let mut dungeon_list__ = None;
                let mut attr__ = None;
                let mut fashion__ = None;
                let mut profile_list__ = None;
                let mut help__ = None;
                let mut counter_list__ = None;
                let mut personal_obj__ = None;
                let mut role_level__ = None;
                let mut pivot__ = None;
                let mut transfer_point__ = None;
                let mut planet_memory__ = None;
                let mut planet_memory_target__ = None;
                let mut red_dot__ = None;
                let mut resonance__ = None;
                let mut cuts_state__ = None;
                let mut investigate_list__ = None;
                let mut records__ = None;
                let mut interaction__ = None;
                let mut season_quest_list__ = None;
                let mut role_face__ = None;
                let mut map_book_list__ = None;
                let mut function_data__ = None;
                let mut anti_info__ = None;
                let mut monster_explore_list__ = None;
                let mut show_piece_data__ = None;
                let mut collection_book__ = None;
                let mut not_get_proceed_award_times__ = None;
                let mut cook_list__ = None;
                let mut refresh_data_list__ = None;
                let mut challenge_dungeon_info__ = None;
                let mut sync_award_data__ = None;
                let mut season_achievement_list__ = None;
                let mut season_rank_list__ = None;
                let mut season_center__ = None;
                let mut personal_zone__ = None;
                let mut season_medal_info__ = None;
                let mut community_home_info__ = None;
                let mut season_activation__ = None;
                let mut slots__ = None;
                let mut monster_hunt_info__ = None;
                let mut r#mod__ = None;
                let mut world_event_map__ = None;
                let mut fish_setting__ = None;
                let mut freight_data__ = None;
                let mut profession_list__ = None;
                let mut trial_road__ = None;
                let mut gasha_data__ = None;
                let mut shop_data__ = None;
                let mut personal_world_boss_info__ = None;
                let mut craft_energy__ = None;
                let mut weekly_tower__ = None;
                let mut cut_scene_infos__ = None;
                let mut recommend_play_data__ = None;
                let mut ride_list__ = None;
                let mut pay_order_list__ = None;
                let mut life_profession__ = None;
                let mut life_profession_work__ = None;
                let mut user_activity_list__ = None;
                let mut player_record__ = None;
                let mut drop_container__ = None;
                let mut monthly_card__ = None;
                let mut fashion_benefit__ = None;
                let mut item_currency__ = None;
                let mut privilege_effect_data__ = None;
                let mut treasure__ = None;
                let mut unlock_emoji_data__ = None;
                let mut player_order_comtainer_info__ = None;
                let mut player_box__ = None;
                let mut launch_privilege_data__ = None;
                let mut battle_pass_data__ = None;
                let mut recharge_data__ = None;
                let mut lucky_value_mgr__ = None;
                let mut handbook_data__ = None;
                let mut master_mode_dungeon_info__ = None;
                let mut statistics_data__ = None;
                let mut compenstion_statistics__ = None;
                let mut bubble_act_data__ = None;
                let mut mail_claimed_info__ = None;
                let mut newbie_data__ = None;
                let mut fight_point__ = None;
                let mut sign__ = None;
                let mut char_statistics_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CharBase => {
                            if char_base__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharBase"));
                            }
                            char_base__ = map_.next_value()?;
                        }
                        GeneratedField::SceneData => {
                            if scene_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneData"));
                            }
                            scene_data__ = map_.next_value()?;
                        }
                        GeneratedField::SceneLuaData => {
                            if scene_lua_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneLuaData"));
                            }
                            scene_lua_data__ = map_.next_value()?;
                        }
                        GeneratedField::PioneerData => {
                            if pioneer_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PioneerData"));
                            }
                            pioneer_data__ = map_.next_value()?;
                        }
                        GeneratedField::BuffInfo => {
                            if buff_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffInfo"));
                            }
                            buff_info__ = map_.next_value()?;
                        }
                        GeneratedField::ItemPackage => {
                            if item_package__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ItemPackage"));
                            }
                            item_package__ = map_.next_value()?;
                        }
                        GeneratedField::QuestList => {
                            if quest_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("QuestList"));
                            }
                            quest_list__ = map_.next_value()?;
                        }
                        GeneratedField::SettingData => {
                            if setting_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SettingData"));
                            }
                            setting_data__ = map_.next_value()?;
                        }
                        GeneratedField::MiscInfo => {
                            if misc_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MiscInfo"));
                            }
                            misc_info__ = map_.next_value()?;
                        }
                        GeneratedField::ExchangeItems => {
                            if exchange_items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExchangeItems"));
                            }
                            exchange_items__ = map_.next_value()?;
                        }
                        GeneratedField::Equip => {
                            if equip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Equip"));
                            }
                            equip__ = map_.next_value()?;
                        }
                        GeneratedField::EnergyItem => {
                            if energy_item__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnergyItem"));
                            }
                            energy_item__ = map_.next_value()?;
                        }
                        GeneratedField::MapData => {
                            if map_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MapData"));
                            }
                            map_data__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonList => {
                            if dungeon_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonList"));
                            }
                            dungeon_list__ = map_.next_value()?;
                        }
                        GeneratedField::Attr => {
                            if attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Attr"));
                            }
                            attr__ = map_.next_value()?;
                        }
                        GeneratedField::Fashion => {
                            if fashion__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Fashion"));
                            }
                            fashion__ = map_.next_value()?;
                        }
                        GeneratedField::ProfileList => {
                            if profile_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfileList"));
                            }
                            profile_list__ = map_.next_value()?;
                        }
                        GeneratedField::Help => {
                            if help__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Help"));
                            }
                            help__ = map_.next_value()?;
                        }
                        GeneratedField::CounterList => {
                            if counter_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CounterList"));
                            }
                            counter_list__ = map_.next_value()?;
                        }
                        GeneratedField::PersonalObj => {
                            if personal_obj__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PersonalObj"));
                            }
                            personal_obj__ = map_.next_value()?;
                        }
                        GeneratedField::RoleLevel => {
                            if role_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RoleLevel"));
                            }
                            role_level__ = map_.next_value()?;
                        }
                        GeneratedField::Pivot => {
                            if pivot__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Pivot"));
                            }
                            pivot__ = map_.next_value()?;
                        }
                        GeneratedField::TransferPoint => {
                            if transfer_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TransferPoint"));
                            }
                            transfer_point__ = map_.next_value()?;
                        }
                        GeneratedField::PlanetMemory => {
                            if planet_memory__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlanetMemory"));
                            }
                            planet_memory__ = map_.next_value()?;
                        }
                        GeneratedField::PlanetMemoryTarget => {
                            if planet_memory_target__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlanetMemoryTarget"));
                            }
                            planet_memory_target__ = map_.next_value()?;
                        }
                        GeneratedField::RedDot => {
                            if red_dot__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RedDot"));
                            }
                            red_dot__ = map_.next_value()?;
                        }
                        GeneratedField::Resonance => {
                            if resonance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Resonance"));
                            }
                            resonance__ = map_.next_value()?;
                        }
                        GeneratedField::CutsState => {
                            if cuts_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CutsState"));
                            }
                            cuts_state__ = map_.next_value()?;
                        }
                        GeneratedField::InvestigateList => {
                            if investigate_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InvestigateList"));
                            }
                            investigate_list__ = map_.next_value()?;
                        }
                        GeneratedField::Records => {
                            if records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Records"));
                            }
                            records__ = map_.next_value()?;
                        }
                        GeneratedField::Interaction => {
                            if interaction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Interaction"));
                            }
                            interaction__ = map_.next_value()?;
                        }
                        GeneratedField::SeasonQuestList => {
                            if season_quest_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonQuestList"));
                            }
                            season_quest_list__ = map_.next_value()?;
                        }
                        GeneratedField::RoleFace => {
                            if role_face__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RoleFace"));
                            }
                            role_face__ = map_.next_value()?;
                        }
                        GeneratedField::MapBookList => {
                            if map_book_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MapBookList"));
                            }
                            map_book_list__ = map_.next_value()?;
                        }
                        GeneratedField::FunctionData => {
                            if function_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FunctionData"));
                            }
                            function_data__ = map_.next_value()?;
                        }
                        GeneratedField::AntiInfo => {
                            if anti_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AntiInfo"));
                            }
                            anti_info__ = map_.next_value()?;
                        }
                        GeneratedField::MonsterExploreList => {
                            if monster_explore_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MonsterExploreList"));
                            }
                            monster_explore_list__ = map_.next_value()?;
                        }
                        GeneratedField::ShowPieceData => {
                            if show_piece_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShowPieceData"));
                            }
                            show_piece_data__ = map_.next_value()?;
                        }
                        GeneratedField::CollectionBook => {
                            if collection_book__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CollectionBook"));
                            }
                            collection_book__ = map_.next_value()?;
                        }
                        GeneratedField::NotGetProceedAwardTimes => {
                            if not_get_proceed_award_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NotGetProceedAwardTimes"));
                            }
                            not_get_proceed_award_times__ = map_.next_value()?;
                        }
                        GeneratedField::CookList => {
                            if cook_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CookList"));
                            }
                            cook_list__ = map_.next_value()?;
                        }
                        GeneratedField::RefreshDataList => {
                            if refresh_data_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshDataList"));
                            }
                            refresh_data_list__ = map_.next_value()?;
                        }
                        GeneratedField::ChallengeDungeonInfo => {
                            if challenge_dungeon_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ChallengeDungeonInfo"));
                            }
                            challenge_dungeon_info__ = map_.next_value()?;
                        }
                        GeneratedField::SyncAwardData => {
                            if sync_award_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SyncAwardData"));
                            }
                            sync_award_data__ = map_.next_value()?;
                        }
                        GeneratedField::SeasonAchievementList => {
                            if season_achievement_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonAchievementList"));
                            }
                            season_achievement_list__ = map_.next_value()?;
                        }
                        GeneratedField::SeasonRankList => {
                            if season_rank_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonRankList"));
                            }
                            season_rank_list__ = map_.next_value()?;
                        }
                        GeneratedField::SeasonCenter => {
                            if season_center__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonCenter"));
                            }
                            season_center__ = map_.next_value()?;
                        }
                        GeneratedField::PersonalZone => {
                            if personal_zone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PersonalZone"));
                            }
                            personal_zone__ = map_.next_value()?;
                        }
                        GeneratedField::SeasonMedalInfo => {
                            if season_medal_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonMedalInfo"));
                            }
                            season_medal_info__ = map_.next_value()?;
                        }
                        GeneratedField::CommunityHomeInfo => {
                            if community_home_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CommunityHomeInfo"));
                            }
                            community_home_info__ = map_.next_value()?;
                        }
                        GeneratedField::SeasonActivation => {
                            if season_activation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonActivation"));
                            }
                            season_activation__ = map_.next_value()?;
                        }
                        GeneratedField::Slots => {
                            if slots__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Slots"));
                            }
                            slots__ = map_.next_value()?;
                        }
                        GeneratedField::MonsterHuntInfo => {
                            if monster_hunt_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MonsterHuntInfo"));
                            }
                            monster_hunt_info__ = map_.next_value()?;
                        }
                        GeneratedField::Mod => {
                            if r#mod__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Mod"));
                            }
                            r#mod__ = map_.next_value()?;
                        }
                        GeneratedField::WorldEventMap => {
                            if world_event_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WorldEventMap"));
                            }
                            world_event_map__ = map_.next_value()?;
                        }
                        GeneratedField::FishSetting => {
                            if fish_setting__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FishSetting"));
                            }
                            fish_setting__ = map_.next_value()?;
                        }
                        GeneratedField::FreightData => {
                            if freight_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FreightData"));
                            }
                            freight_data__ = map_.next_value()?;
                        }
                        GeneratedField::ProfessionList => {
                            if profession_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfessionList"));
                            }
                            profession_list__ = map_.next_value()?;
                        }
                        GeneratedField::TrialRoad => {
                            if trial_road__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TrialRoad"));
                            }
                            trial_road__ = map_.next_value()?;
                        }
                        GeneratedField::GashaData => {
                            if gasha_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GashaData"));
                            }
                            gasha_data__ = map_.next_value()?;
                        }
                        GeneratedField::ShopData => {
                            if shop_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShopData"));
                            }
                            shop_data__ = map_.next_value()?;
                        }
                        GeneratedField::PersonalWorldBossInfo => {
                            if personal_world_boss_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PersonalWorldBossInfo"));
                            }
                            personal_world_boss_info__ = map_.next_value()?;
                        }
                        GeneratedField::CraftEnergy => {
                            if craft_energy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CraftEnergy"));
                            }
                            craft_energy__ = map_.next_value()?;
                        }
                        GeneratedField::WeeklyTower => {
                            if weekly_tower__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WeeklyTower"));
                            }
                            weekly_tower__ = map_.next_value()?;
                        }
                        GeneratedField::CutSceneInfos => {
                            if cut_scene_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CutSceneInfos"));
                            }
                            cut_scene_infos__ = map_.next_value()?;
                        }
                        GeneratedField::RecommendPlayData => {
                            if recommend_play_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RecommendPlayData"));
                            }
                            recommend_play_data__ = map_.next_value()?;
                        }
                        GeneratedField::RideList => {
                            if ride_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RideList"));
                            }
                            ride_list__ = map_.next_value()?;
                        }
                        GeneratedField::PayOrderList => {
                            if pay_order_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PayOrderList"));
                            }
                            pay_order_list__ = map_.next_value()?;
                        }
                        GeneratedField::LifeProfession => {
                            if life_profession__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LifeProfession"));
                            }
                            life_profession__ = map_.next_value()?;
                        }
                        GeneratedField::LifeProfessionWork => {
                            if life_profession_work__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LifeProfessionWork"));
                            }
                            life_profession_work__ = map_.next_value()?;
                        }
                        GeneratedField::UserActivityList => {
                            if user_activity_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UserActivityList"));
                            }
                            user_activity_list__ = map_.next_value()?;
                        }
                        GeneratedField::PlayerRecord => {
                            if player_record__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayerRecord"));
                            }
                            player_record__ = map_.next_value()?;
                        }
                        GeneratedField::DropContainer => {
                            if drop_container__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DropContainer"));
                            }
                            drop_container__ = map_.next_value()?;
                        }
                        GeneratedField::MonthlyCard => {
                            if monthly_card__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MonthlyCard"));
                            }
                            monthly_card__ = map_.next_value()?;
                        }
                        GeneratedField::FashionBenefit => {
                            if fashion_benefit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionBenefit"));
                            }
                            fashion_benefit__ = map_.next_value()?;
                        }
                        GeneratedField::ItemCurrency => {
                            if item_currency__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ItemCurrency"));
                            }
                            item_currency__ = map_.next_value()?;
                        }
                        GeneratedField::PrivilegeEffectData => {
                            if privilege_effect_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PrivilegeEffectData"));
                            }
                            privilege_effect_data__ = map_.next_value()?;
                        }
                        GeneratedField::Treasure => {
                            if treasure__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Treasure"));
                            }
                            treasure__ = map_.next_value()?;
                        }
                        GeneratedField::UnlockEmojiData => {
                            if unlock_emoji_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockEmojiData"));
                            }
                            unlock_emoji_data__ = map_.next_value()?;
                        }
                        GeneratedField::PlayerOrderComtainerInfo => {
                            if player_order_comtainer_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayerOrderComtainerInfo"));
                            }
                            player_order_comtainer_info__ = map_.next_value()?;
                        }
                        GeneratedField::PlayerBox => {
                            if player_box__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayerBox"));
                            }
                            player_box__ = map_.next_value()?;
                        }
                        GeneratedField::LaunchPrivilegeData => {
                            if launch_privilege_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LaunchPrivilegeData"));
                            }
                            launch_privilege_data__ = map_.next_value()?;
                        }
                        GeneratedField::BattlePassData => {
                            if battle_pass_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BattlePassData"));
                            }
                            battle_pass_data__ = map_.next_value()?;
                        }
                        GeneratedField::RechargeData => {
                            if recharge_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RechargeData"));
                            }
                            recharge_data__ = map_.next_value()?;
                        }
                        GeneratedField::LuckyValueMgr => {
                            if lucky_value_mgr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LuckyValueMgr"));
                            }
                            lucky_value_mgr__ = map_.next_value()?;
                        }
                        GeneratedField::HandbookData => {
                            if handbook_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HandbookData"));
                            }
                            handbook_data__ = map_.next_value()?;
                        }
                        GeneratedField::MasterModeDungeonInfo => {
                            if master_mode_dungeon_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MasterModeDungeonInfo"));
                            }
                            master_mode_dungeon_info__ = map_.next_value()?;
                        }
                        GeneratedField::StatisticsData => {
                            if statistics_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StatisticsData"));
                            }
                            statistics_data__ = map_.next_value()?;
                        }
                        GeneratedField::CompenstionStatistics => {
                            if compenstion_statistics__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CompenstionStatistics"));
                            }
                            compenstion_statistics__ = map_.next_value()?;
                        }
                        GeneratedField::BubbleActData => {
                            if bubble_act_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BubbleActData"));
                            }
                            bubble_act_data__ = map_.next_value()?;
                        }
                        GeneratedField::MailClaimedInfo => {
                            if mail_claimed_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MailClaimedInfo"));
                            }
                            mail_claimed_info__ = map_.next_value()?;
                        }
                        GeneratedField::NewbieData => {
                            if newbie_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NewbieData"));
                            }
                            newbie_data__ = map_.next_value()?;
                        }
                        GeneratedField::FightPoint => {
                            if fight_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FightPoint"));
                            }
                            fight_point__ = map_.next_value()?;
                        }
                        GeneratedField::Sign => {
                            if sign__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Sign"));
                            }
                            sign__ = map_.next_value()?;
                        }
                        GeneratedField::CharStatisticsData => {
                            if char_statistics_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharStatisticsData"));
                            }
                            char_statistics_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CharSerialize {
                    char_id: char_id__,
                    char_base: char_base__,
                    scene_data: scene_data__,
                    scene_lua_data: scene_lua_data__,
                    pioneer_data: pioneer_data__,
                    buff_info: buff_info__,
                    item_package: item_package__,
                    quest_list: quest_list__,
                    setting_data: setting_data__,
                    misc_info: misc_info__,
                    exchange_items: exchange_items__,
                    equip: equip__,
                    energy_item: energy_item__,
                    map_data: map_data__,
                    dungeon_list: dungeon_list__,
                    attr: attr__,
                    fashion: fashion__,
                    profile_list: profile_list__,
                    help: help__,
                    counter_list: counter_list__,
                    personal_obj: personal_obj__,
                    role_level: role_level__,
                    pivot: pivot__,
                    transfer_point: transfer_point__,
                    planet_memory: planet_memory__,
                    planet_memory_target: planet_memory_target__,
                    red_dot: red_dot__,
                    resonance: resonance__,
                    cuts_state: cuts_state__,
                    investigate_list: investigate_list__,
                    records: records__,
                    interaction: interaction__,
                    season_quest_list: season_quest_list__,
                    role_face: role_face__,
                    map_book_list: map_book_list__,
                    function_data: function_data__,
                    anti_info: anti_info__,
                    monster_explore_list: monster_explore_list__,
                    show_piece_data: show_piece_data__,
                    collection_book: collection_book__,
                    not_get_proceed_award_times: not_get_proceed_award_times__,
                    cook_list: cook_list__,
                    refresh_data_list: refresh_data_list__,
                    challenge_dungeon_info: challenge_dungeon_info__,
                    sync_award_data: sync_award_data__,
                    season_achievement_list: season_achievement_list__,
                    season_rank_list: season_rank_list__,
                    season_center: season_center__,
                    personal_zone: personal_zone__,
                    season_medal_info: season_medal_info__,
                    community_home_info: community_home_info__,
                    season_activation: season_activation__,
                    slots: slots__,
                    monster_hunt_info: monster_hunt_info__,
                    r#mod: r#mod__,
                    world_event_map: world_event_map__,
                    fish_setting: fish_setting__,
                    freight_data: freight_data__,
                    profession_list: profession_list__,
                    trial_road: trial_road__,
                    gasha_data: gasha_data__,
                    shop_data: shop_data__,
                    personal_world_boss_info: personal_world_boss_info__,
                    craft_energy: craft_energy__,
                    weekly_tower: weekly_tower__,
                    cut_scene_infos: cut_scene_infos__,
                    recommend_play_data: recommend_play_data__,
                    ride_list: ride_list__,
                    pay_order_list: pay_order_list__,
                    life_profession: life_profession__,
                    life_profession_work: life_profession_work__,
                    user_activity_list: user_activity_list__,
                    player_record: player_record__,
                    drop_container: drop_container__,
                    monthly_card: monthly_card__,
                    fashion_benefit: fashion_benefit__,
                    item_currency: item_currency__,
                    privilege_effect_data: privilege_effect_data__,
                    treasure: treasure__,
                    unlock_emoji_data: unlock_emoji_data__,
                    player_order_comtainer_info: player_order_comtainer_info__,
                    player_box: player_box__,
                    launch_privilege_data: launch_privilege_data__,
                    battle_pass_data: battle_pass_data__,
                    recharge_data: recharge_data__,
                    lucky_value_mgr: lucky_value_mgr__,
                    handbook_data: handbook_data__,
                    master_mode_dungeon_info: master_mode_dungeon_info__,
                    statistics_data: statistics_data__,
                    compenstion_statistics: compenstion_statistics__,
                    bubble_act_data: bubble_act_data__,
                    mail_claimed_info: mail_claimed_info__,
                    newbie_data: newbie_data__,
                    fight_point: fight_point__,
                    sign: sign__,
                    char_statistics_data: char_statistics_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CharSerialize", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CharStatisticsData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.login_days.is_some() {
            len += 1;
        }
        if self.last_login_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CharStatisticsData", len)?;
        if let Some(v) = self.login_days.as_ref() {
            struct_ser.serialize_field("LoginDays", v)?;
        }
        if let Some(v) = self.last_login_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastLoginTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CharStatisticsData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LoginDays",
            "LastLoginTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LoginDays,
            LastLoginTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LoginDays" => Ok(GeneratedField::LoginDays),
                            "LastLoginTime" => Ok(GeneratedField::LastLoginTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CharStatisticsData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CharStatisticsData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CharStatisticsData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut login_days__ = None;
                let mut last_login_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LoginDays => {
                            if login_days__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LoginDays"));
                            }
                            login_days__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastLoginTime => {
                            if last_login_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastLoginTime"));
                            }
                            last_login_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CharStatisticsData {
                    login_days: login_days__,
                    last_login_time: last_login_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CharStatisticsData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CharTeam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.team_id.is_some() {
            len += 1;
        }
        if self.leader_id.is_some() {
            len += 1;
        }
        if self.team_target_id.is_some() {
            len += 1;
        }
        if self.team_num.is_some() {
            len += 1;
        }
        if !self.char_ids.is_empty() {
            len += 1;
        }
        if self.is_matching.is_some() {
            len += 1;
        }
        if self.char_team_version.is_some() {
            len += 1;
        }
        if !self.team_member_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CharTeam", len)?;
        if let Some(v) = self.team_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TeamId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.leader_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LeaderId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.team_target_id.as_ref() {
            struct_ser.serialize_field("TeamTargetId", v)?;
        }
        if let Some(v) = self.team_num.as_ref() {
            struct_ser.serialize_field("TeamNum", v)?;
        }
        if !self.char_ids.is_empty() {
            struct_ser.serialize_field("CharIds", &self.char_ids.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if let Some(v) = self.is_matching.as_ref() {
            struct_ser.serialize_field("IsMatching", v)?;
        }
        if let Some(v) = self.char_team_version.as_ref() {
            struct_ser.serialize_field("CharTeamVersion", v)?;
        }
        if !self.team_member_data.is_empty() {
            struct_ser.serialize_field("TeamMemberData", &self.team_member_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CharTeam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TeamId",
            "LeaderId",
            "TeamTargetId",
            "TeamNum",
            "CharIds",
            "IsMatching",
            "CharTeamVersion",
            "TeamMemberData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TeamId,
            LeaderId,
            TeamTargetId,
            TeamNum,
            CharIds,
            IsMatching,
            CharTeamVersion,
            TeamMemberData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TeamId" => Ok(GeneratedField::TeamId),
                            "LeaderId" => Ok(GeneratedField::LeaderId),
                            "TeamTargetId" => Ok(GeneratedField::TeamTargetId),
                            "TeamNum" => Ok(GeneratedField::TeamNum),
                            "CharIds" => Ok(GeneratedField::CharIds),
                            "IsMatching" => Ok(GeneratedField::IsMatching),
                            "CharTeamVersion" => Ok(GeneratedField::CharTeamVersion),
                            "TeamMemberData" => Ok(GeneratedField::TeamMemberData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CharTeam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CharTeam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CharTeam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut team_id__ = None;
                let mut leader_id__ = None;
                let mut team_target_id__ = None;
                let mut team_num__ = None;
                let mut char_ids__ = None;
                let mut is_matching__ = None;
                let mut char_team_version__ = None;
                let mut team_member_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TeamId => {
                            if team_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TeamId"));
                            }
                            team_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LeaderId => {
                            if leader_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LeaderId"));
                            }
                            leader_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TeamTargetId => {
                            if team_target_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TeamTargetId"));
                            }
                            team_target_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TeamNum => {
                            if team_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TeamNum"));
                            }
                            team_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CharIds => {
                            if char_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharIds"));
                            }
                            char_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::IsMatching => {
                            if is_matching__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsMatching"));
                            }
                            is_matching__ = map_.next_value()?;
                        }
                        GeneratedField::CharTeamVersion => {
                            if char_team_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharTeamVersion"));
                            }
                            char_team_version__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TeamMemberData => {
                            if team_member_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TeamMemberData"));
                            }
                            team_member_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(CharTeam {
                    team_id: team_id__,
                    leader_id: leader_id__,
                    team_target_id: team_target_id__,
                    team_num: team_num__,
                    char_ids: char_ids__.unwrap_or_default(),
                    is_matching: is_matching__,
                    char_team_version: char_team_version__,
                    team_member_data: team_member_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CharTeam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClientBreakState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_operator.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ClientBreakState", len)?;
        if let Some(v) = self.v_operator.as_ref() {
            struct_ser.serialize_field("VOperator", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClientBreakState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VOperator",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VOperator,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VOperator" => Ok(GeneratedField::VOperator),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClientBreakState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ClientBreakState")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ClientBreakState, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_operator__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VOperator => {
                            if v_operator__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VOperator"));
                            }
                            v_operator__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ClientBreakState {
                    v_operator: v_operator__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ClientBreakState", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClientHitInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.source_type.is_some() {
            len += 1;
        }
        if self.uuid.is_some() {
            len += 1;
        }
        if self.id.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        if self.stage.is_some() {
            len += 1;
        }
        if self.event_id.is_some() {
            len += 1;
        }
        if self.attack_time.is_some() {
            len += 1;
        }
        if self.attack_uuid.is_some() {
            len += 1;
        }
        if self.target_uuid.is_some() {
            len += 1;
        }
        if self.attack_pos.is_some() {
            len += 1;
        }
        if self.target_pos.is_some() {
            len += 1;
        }
        if self.damage_pos.is_some() {
            len += 1;
        }
        if !self.part_infos.is_empty() {
            len += 1;
        }
        if self.is_dodge_success.is_some() {
            len += 1;
        }
        if self.skill_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ClientHitInfo", len)?;
        if let Some(v) = self.source_type.as_ref() {
            let v = EDamageSource::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("SourceType", &v)?;
        }
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if let Some(v) = self.stage.as_ref() {
            struct_ser.serialize_field("Stage", v)?;
        }
        if let Some(v) = self.event_id.as_ref() {
            struct_ser.serialize_field("EventId", v)?;
        }
        if let Some(v) = self.attack_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("AttackTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.attack_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("AttackUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.target_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.attack_pos.as_ref() {
            struct_ser.serialize_field("AttackPos", v)?;
        }
        if let Some(v) = self.target_pos.as_ref() {
            struct_ser.serialize_field("TargetPos", v)?;
        }
        if let Some(v) = self.damage_pos.as_ref() {
            struct_ser.serialize_field("DamagePos", v)?;
        }
        if !self.part_infos.is_empty() {
            struct_ser.serialize_field("PartInfos", &self.part_infos)?;
        }
        if let Some(v) = self.is_dodge_success.as_ref() {
            struct_ser.serialize_field("IsDodgeSuccess", v)?;
        }
        if let Some(v) = self.skill_uuid.as_ref() {
            struct_ser.serialize_field("SkillUuid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClientHitInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SourceType",
            "Uuid",
            "Id",
            "Level",
            "Stage",
            "EventId",
            "AttackTime",
            "AttackUuid",
            "TargetUuid",
            "AttackPos",
            "TargetPos",
            "DamagePos",
            "PartInfos",
            "IsDodgeSuccess",
            "SkillUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SourceType,
            Uuid,
            Id,
            Level,
            Stage,
            EventId,
            AttackTime,
            AttackUuid,
            TargetUuid,
            AttackPos,
            TargetPos,
            DamagePos,
            PartInfos,
            IsDodgeSuccess,
            SkillUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SourceType" => Ok(GeneratedField::SourceType),
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "Id" => Ok(GeneratedField::Id),
                            "Level" => Ok(GeneratedField::Level),
                            "Stage" => Ok(GeneratedField::Stage),
                            "EventId" => Ok(GeneratedField::EventId),
                            "AttackTime" => Ok(GeneratedField::AttackTime),
                            "AttackUuid" => Ok(GeneratedField::AttackUuid),
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            "AttackPos" => Ok(GeneratedField::AttackPos),
                            "TargetPos" => Ok(GeneratedField::TargetPos),
                            "DamagePos" => Ok(GeneratedField::DamagePos),
                            "PartInfos" => Ok(GeneratedField::PartInfos),
                            "IsDodgeSuccess" => Ok(GeneratedField::IsDodgeSuccess),
                            "SkillUuid" => Ok(GeneratedField::SkillUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClientHitInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ClientHitInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ClientHitInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut source_type__ = None;
                let mut uuid__ = None;
                let mut id__ = None;
                let mut level__ = None;
                let mut stage__ = None;
                let mut event_id__ = None;
                let mut attack_time__ = None;
                let mut attack_uuid__ = None;
                let mut target_uuid__ = None;
                let mut attack_pos__ = None;
                let mut target_pos__ = None;
                let mut damage_pos__ = None;
                let mut part_infos__ = None;
                let mut is_dodge_success__ = None;
                let mut skill_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SourceType => {
                            if source_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SourceType"));
                            }
                            source_type__ = map_.next_value::<::std::option::Option<EDamageSource>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Stage => {
                            if stage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Stage"));
                            }
                            stage__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EventId => {
                            if event_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EventId"));
                            }
                            event_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AttackTime => {
                            if attack_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AttackTime"));
                            }
                            attack_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AttackUuid => {
                            if attack_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AttackUuid"));
                            }
                            attack_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AttackPos => {
                            if attack_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AttackPos"));
                            }
                            attack_pos__ = map_.next_value()?;
                        }
                        GeneratedField::TargetPos => {
                            if target_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetPos"));
                            }
                            target_pos__ = map_.next_value()?;
                        }
                        GeneratedField::DamagePos => {
                            if damage_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DamagePos"));
                            }
                            damage_pos__ = map_.next_value()?;
                        }
                        GeneratedField::PartInfos => {
                            if part_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartInfos"));
                            }
                            part_infos__ = Some(map_.next_value()?);
                        }
                        GeneratedField::IsDodgeSuccess => {
                            if is_dodge_success__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsDodgeSuccess"));
                            }
                            is_dodge_success__ = map_.next_value()?;
                        }
                        GeneratedField::SkillUuid => {
                            if skill_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillUuid"));
                            }
                            skill_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ClientHitInfo {
                    source_type: source_type__,
                    uuid: uuid__,
                    id: id__,
                    level: level__,
                    stage: stage__,
                    event_id: event_id__,
                    attack_time: attack_time__,
                    attack_uuid: attack_uuid__,
                    target_uuid: target_uuid__,
                    attack_pos: attack_pos__,
                    target_pos: target_pos__,
                    damage_pos: damage_pos__,
                    part_infos: part_infos__.unwrap_or_default(),
                    is_dodge_success: is_dodge_success__,
                    skill_uuid: skill_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ClientHitInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClientHitPartInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.part_id.is_some() {
            len += 1;
        }
        if self.damage_pos.is_some() {
            len += 1;
        }
        if self.damage_val.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ClientHitPartInfo", len)?;
        if let Some(v) = self.part_id.as_ref() {
            struct_ser.serialize_field("PartId", v)?;
        }
        if let Some(v) = self.damage_pos.as_ref() {
            struct_ser.serialize_field("DamagePos", v)?;
        }
        if let Some(v) = self.damage_val.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("DamageVal", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClientHitPartInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PartId",
            "DamagePos",
            "DamageVal",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PartId,
            DamagePos,
            DamageVal,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PartId" => Ok(GeneratedField::PartId),
                            "DamagePos" => Ok(GeneratedField::DamagePos),
                            "DamageVal" => Ok(GeneratedField::DamageVal),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClientHitPartInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ClientHitPartInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ClientHitPartInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut part_id__ = None;
                let mut damage_pos__ = None;
                let mut damage_val__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PartId => {
                            if part_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartId"));
                            }
                            part_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DamagePos => {
                            if damage_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DamagePos"));
                            }
                            damage_pos__ = map_.next_value()?;
                        }
                        GeneratedField::DamageVal => {
                            if damage_val__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DamageVal"));
                            }
                            damage_val__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ClientHitPartInfo {
                    part_id: part_id__,
                    damage_pos: damage_pos__,
                    damage_val: damage_val__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ClientHitPartInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClientStageEnd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cur_stage_index.is_some() {
            len += 1;
        }
        if self.next_stage_index.is_some() {
            len += 1;
        }
        if self.time.is_some() {
            len += 1;
        }
        if self.condition_id.is_some() {
            len += 1;
        }
        if self.skill_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ClientStageEnd", len)?;
        if let Some(v) = self.cur_stage_index.as_ref() {
            struct_ser.serialize_field("CurStageIndex", v)?;
        }
        if let Some(v) = self.next_stage_index.as_ref() {
            struct_ser.serialize_field("NextStageIndex", v)?;
        }
        if let Some(v) = self.time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Time", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.condition_id.as_ref() {
            struct_ser.serialize_field("ConditionId", v)?;
        }
        if let Some(v) = self.skill_uuid.as_ref() {
            struct_ser.serialize_field("SkillUuid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClientStageEnd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CurStageIndex",
            "NextStageIndex",
            "Time",
            "ConditionId",
            "SkillUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CurStageIndex,
            NextStageIndex,
            Time,
            ConditionId,
            SkillUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CurStageIndex" => Ok(GeneratedField::CurStageIndex),
                            "NextStageIndex" => Ok(GeneratedField::NextStageIndex),
                            "Time" => Ok(GeneratedField::Time),
                            "ConditionId" => Ok(GeneratedField::ConditionId),
                            "SkillUuid" => Ok(GeneratedField::SkillUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClientStageEnd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ClientStageEnd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ClientStageEnd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cur_stage_index__ = None;
                let mut next_stage_index__ = None;
                let mut time__ = None;
                let mut condition_id__ = None;
                let mut skill_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CurStageIndex => {
                            if cur_stage_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurStageIndex"));
                            }
                            cur_stage_index__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextStageIndex => {
                            if next_stage_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NextStageIndex"));
                            }
                            next_stage_index__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Time"));
                            }
                            time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ConditionId => {
                            if condition_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConditionId"));
                            }
                            condition_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillUuid => {
                            if skill_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillUuid"));
                            }
                            skill_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ClientStageEnd {
                    cur_stage_index: cur_stage_index__,
                    next_stage_index: next_stage_index__,
                    time: time__,
                    condition_id: condition_id__,
                    skill_uuid: skill_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ClientStageEnd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClientTargetChange {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skillid.is_some() {
            len += 1;
        }
        if self.skill_level.is_some() {
            len += 1;
        }
        if self.cur_stage_index.is_some() {
            len += 1;
        }
        if self.target_uuid.is_some() {
            len += 1;
        }
        if self.target_pos.is_some() {
            len += 1;
        }
        if self.cur_pos.is_some() {
            len += 1;
        }
        if self.target_part_id.is_some() {
            len += 1;
        }
        if self.target_part_pos.is_some() {
            len += 1;
        }
        if self.skill_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ClientTargetChange", len)?;
        if let Some(v) = self.skillid.as_ref() {
            struct_ser.serialize_field("Skillid", v)?;
        }
        if let Some(v) = self.skill_level.as_ref() {
            struct_ser.serialize_field("SkillLevel", v)?;
        }
        if let Some(v) = self.cur_stage_index.as_ref() {
            struct_ser.serialize_field("CurStageIndex", v)?;
        }
        if let Some(v) = self.target_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.target_pos.as_ref() {
            struct_ser.serialize_field("TargetPos", v)?;
        }
        if let Some(v) = self.cur_pos.as_ref() {
            struct_ser.serialize_field("CurPos", v)?;
        }
        if let Some(v) = self.target_part_id.as_ref() {
            struct_ser.serialize_field("TargetPartId", v)?;
        }
        if let Some(v) = self.target_part_pos.as_ref() {
            struct_ser.serialize_field("TargetPartPos", v)?;
        }
        if let Some(v) = self.skill_uuid.as_ref() {
            struct_ser.serialize_field("SkillUuid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClientTargetChange {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Skillid",
            "SkillLevel",
            "CurStageIndex",
            "TargetUuid",
            "TargetPos",
            "CurPos",
            "TargetPartId",
            "TargetPartPos",
            "SkillUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Skillid,
            SkillLevel,
            CurStageIndex,
            TargetUuid,
            TargetPos,
            CurPos,
            TargetPartId,
            TargetPartPos,
            SkillUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Skillid" => Ok(GeneratedField::Skillid),
                            "SkillLevel" => Ok(GeneratedField::SkillLevel),
                            "CurStageIndex" => Ok(GeneratedField::CurStageIndex),
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            "TargetPos" => Ok(GeneratedField::TargetPos),
                            "CurPos" => Ok(GeneratedField::CurPos),
                            "TargetPartId" => Ok(GeneratedField::TargetPartId),
                            "TargetPartPos" => Ok(GeneratedField::TargetPartPos),
                            "SkillUuid" => Ok(GeneratedField::SkillUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClientTargetChange;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ClientTargetChange")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ClientTargetChange, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skillid__ = None;
                let mut skill_level__ = None;
                let mut cur_stage_index__ = None;
                let mut target_uuid__ = None;
                let mut target_pos__ = None;
                let mut cur_pos__ = None;
                let mut target_part_id__ = None;
                let mut target_part_pos__ = None;
                let mut skill_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Skillid => {
                            if skillid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Skillid"));
                            }
                            skillid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillLevel => {
                            if skill_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillLevel"));
                            }
                            skill_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurStageIndex => {
                            if cur_stage_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurStageIndex"));
                            }
                            cur_stage_index__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetPos => {
                            if target_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetPos"));
                            }
                            target_pos__ = map_.next_value()?;
                        }
                        GeneratedField::CurPos => {
                            if cur_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurPos"));
                            }
                            cur_pos__ = map_.next_value()?;
                        }
                        GeneratedField::TargetPartId => {
                            if target_part_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetPartId"));
                            }
                            target_part_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetPartPos => {
                            if target_part_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetPartPos"));
                            }
                            target_part_pos__ = map_.next_value()?;
                        }
                        GeneratedField::SkillUuid => {
                            if skill_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillUuid"));
                            }
                            skill_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ClientTargetChange {
                    skillid: skillid__,
                    skill_level: skill_level__,
                    cur_stage_index: cur_stage_index__,
                    target_uuid: target_uuid__,
                    target_pos: target_pos__,
                    cur_pos: cur_pos__,
                    target_part_id: target_part_id__,
                    target_part_pos: target_part_pos__,
                    skill_uuid: skill_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ClientTargetChange", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Clutter {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if self.config_id.is_some() {
            len += 1;
        }
        if self.position_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Clutter", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.config_id.as_ref() {
            struct_ser.serialize_field("ConfigId", v)?;
        }
        if let Some(v) = self.position_id.as_ref() {
            struct_ser.serialize_field("PositionId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Clutter {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "ConfigId",
            "PositionId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            ConfigId,
            PositionId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "ConfigId" => Ok(GeneratedField::ConfigId),
                            "PositionId" => Ok(GeneratedField::PositionId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Clutter;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Clutter")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Clutter, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut config_id__ = None;
                let mut position_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ConfigId => {
                            if config_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConfigId"));
                            }
                            config_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PositionId => {
                            if position_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PositionId"));
                            }
                            position_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Clutter {
                    uuid: uuid__,
                    config_id: config_id__,
                    position_id: position_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Clutter", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ClutterGenerationRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.generated.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ClutterGenerationRecord", len)?;
        if let Some(v) = self.generated.as_ref() {
            struct_ser.serialize_field("Generated", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ClutterGenerationRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Generated",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Generated,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Generated" => Ok(GeneratedField::Generated),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ClutterGenerationRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ClutterGenerationRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ClutterGenerationRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut generated__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Generated => {
                            if generated__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Generated"));
                            }
                            generated__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ClutterGenerationRecord {
                    generated: generated__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ClutterGenerationRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CollectingItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.item_id.is_some() {
            len += 1;
        }
        if self.collected_num.is_some() {
            len += 1;
        }
        if self.collect_price.is_some() {
            len += 1;
        }
        if self.is_high.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CollectingItem", len)?;
        if let Some(v) = self.item_id.as_ref() {
            struct_ser.serialize_field("ItemId", v)?;
        }
        if let Some(v) = self.collected_num.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CollectedNum", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.collect_price.as_ref() {
            struct_ser.serialize_field("CollectPrice", v)?;
        }
        if let Some(v) = self.is_high.as_ref() {
            struct_ser.serialize_field("IsHigh", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CollectingItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ItemId",
            "CollectedNum",
            "CollectPrice",
            "IsHigh",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ItemId,
            CollectedNum,
            CollectPrice,
            IsHigh,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ItemId" => Ok(GeneratedField::ItemId),
                            "CollectedNum" => Ok(GeneratedField::CollectedNum),
                            "CollectPrice" => Ok(GeneratedField::CollectPrice),
                            "IsHigh" => Ok(GeneratedField::IsHigh),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CollectingItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CollectingItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CollectingItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut item_id__ = None;
                let mut collected_num__ = None;
                let mut collect_price__ = None;
                let mut is_high__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ItemId => {
                            if item_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ItemId"));
                            }
                            item_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CollectedNum => {
                            if collected_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CollectedNum"));
                            }
                            collected_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CollectPrice => {
                            if collect_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CollectPrice"));
                            }
                            collect_price__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsHigh => {
                            if is_high__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsHigh"));
                            }
                            is_high__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CollectingItem {
                    item_id: item_id__,
                    collected_num: collected_num__,
                    collect_price: collect_price__,
                    is_high: is_high__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CollectingItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CollectionBook {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.mod_book_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CollectionBook", len)?;
        if !self.mod_book_map.is_empty() {
            struct_ser.serialize_field("ModBookMap", &self.mod_book_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CollectionBook {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ModBookMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ModBookMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ModBookMap" => Ok(GeneratedField::ModBookMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CollectionBook;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CollectionBook")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CollectionBook, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut mod_book_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ModBookMap => {
                            if mod_book_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ModBookMap"));
                            }
                            mod_book_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(CollectionBook {
                    mod_book_map: mod_book_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CollectionBook", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommonAwardInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.award_status.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommonAwardInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.award_status.as_ref() {
            let v = EReceiveRewardStatus::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("AwardStatus", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommonAwardInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "AwardStatus",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            AwardStatus,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "AwardStatus" => Ok(GeneratedField::AwardStatus),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommonAwardInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommonAwardInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommonAwardInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut award_status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AwardStatus => {
                            if award_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardStatus"));
                            }
                            award_status__ = map_.next_value::<::std::option::Option<EReceiveRewardStatus>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(CommonAwardInfo {
                    id: id__,
                    award_status: award_status__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommonAwardInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityAuthorityInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.authority.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityAuthorityInfo", len)?;
        if !self.authority.is_empty() {
            struct_ser.serialize_field("Authority", &self.authority)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityAuthorityInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Authority",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Authority,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Authority" => Ok(GeneratedField::Authority),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityAuthorityInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityAuthorityInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityAuthorityInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut authority__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Authority => {
                            if authority__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Authority"));
                            }
                            authority__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(CommunityAuthorityInfo {
                    authority: authority__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityAuthorityInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityBuildFurnitureInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.build_uuid.is_some() {
            len += 1;
        }
        if self.furniture_id.is_some() {
            len += 1;
        }
        if self.furniture_count.is_some() {
            len += 1;
        }
        if self.char_id.is_some() {
            len += 1;
        }
        if self.start_time.is_some() {
            len += 1;
        }
        if self.end_time.is_some() {
            len += 1;
        }
        if self.accelerate_count.is_some() {
            len += 1;
        }
        if !self.accelerate_items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityBuildFurnitureInfo", len)?;
        if let Some(v) = self.build_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BuildUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.furniture_id.as_ref() {
            struct_ser.serialize_field("FurnitureId", v)?;
        }
        if let Some(v) = self.furniture_count.as_ref() {
            struct_ser.serialize_field("FurnitureCount", v)?;
        }
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.start_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("StartTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.end_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("EndTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.accelerate_count.as_ref() {
            struct_ser.serialize_field("AccelerateCount", v)?;
        }
        if !self.accelerate_items.is_empty() {
            struct_ser.serialize_field("AccelerateItems", &self.accelerate_items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityBuildFurnitureInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BuildUuid",
            "FurnitureId",
            "FurnitureCount",
            "CharId",
            "StartTime",
            "EndTime",
            "AccelerateCount",
            "AccelerateItems",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BuildUuid,
            FurnitureId,
            FurnitureCount,
            CharId,
            StartTime,
            EndTime,
            AccelerateCount,
            AccelerateItems,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BuildUuid" => Ok(GeneratedField::BuildUuid),
                            "FurnitureId" => Ok(GeneratedField::FurnitureId),
                            "FurnitureCount" => Ok(GeneratedField::FurnitureCount),
                            "CharId" => Ok(GeneratedField::CharId),
                            "StartTime" => Ok(GeneratedField::StartTime),
                            "EndTime" => Ok(GeneratedField::EndTime),
                            "AccelerateCount" => Ok(GeneratedField::AccelerateCount),
                            "AccelerateItems" => Ok(GeneratedField::AccelerateItems),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityBuildFurnitureInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityBuildFurnitureInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityBuildFurnitureInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut build_uuid__ = None;
                let mut furniture_id__ = None;
                let mut furniture_count__ = None;
                let mut char_id__ = None;
                let mut start_time__ = None;
                let mut end_time__ = None;
                let mut accelerate_count__ = None;
                let mut accelerate_items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BuildUuid => {
                            if build_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuildUuid"));
                            }
                            build_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FurnitureId => {
                            if furniture_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FurnitureId"));
                            }
                            furniture_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FurnitureCount => {
                            if furniture_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FurnitureCount"));
                            }
                            furniture_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StartTime => {
                            if start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StartTime"));
                            }
                            start_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EndTime"));
                            }
                            end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AccelerateCount => {
                            if accelerate_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccelerateCount"));
                            }
                            accelerate_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AccelerateItems => {
                            if accelerate_items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccelerateItems"));
                            }
                            accelerate_items__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(CommunityBuildFurnitureInfo {
                    build_uuid: build_uuid__,
                    furniture_id: furniture_id__,
                    furniture_count: furniture_count__,
                    char_id: char_id__,
                    start_time: start_time__,
                    end_time: end_time__,
                    accelerate_count: accelerate_count__,
                    accelerate_items: accelerate_items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityBuildFurnitureInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityCharBasicData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.basic_data.is_some() {
            len += 1;
        }
        if self.avatar_info.is_some() {
            len += 1;
        }
        if self.profession_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityCharBasicData", len)?;
        if let Some(v) = self.basic_data.as_ref() {
            struct_ser.serialize_field("BasicData", v)?;
        }
        if let Some(v) = self.avatar_info.as_ref() {
            struct_ser.serialize_field("AvatarInfo", v)?;
        }
        if let Some(v) = self.profession_data.as_ref() {
            struct_ser.serialize_field("ProfessionData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityCharBasicData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BasicData",
            "AvatarInfo",
            "ProfessionData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BasicData,
            AvatarInfo,
            ProfessionData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BasicData" => Ok(GeneratedField::BasicData),
                            "AvatarInfo" => Ok(GeneratedField::AvatarInfo),
                            "ProfessionData" => Ok(GeneratedField::ProfessionData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityCharBasicData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityCharBasicData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityCharBasicData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut basic_data__ = None;
                let mut avatar_info__ = None;
                let mut profession_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BasicData => {
                            if basic_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BasicData"));
                            }
                            basic_data__ = map_.next_value()?;
                        }
                        GeneratedField::AvatarInfo => {
                            if avatar_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AvatarInfo"));
                            }
                            avatar_info__ = map_.next_value()?;
                        }
                        GeneratedField::ProfessionData => {
                            if profession_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfessionData"));
                            }
                            profession_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CommunityCharBasicData {
                    basic_data: basic_data__,
                    avatar_info: avatar_info__,
                    profession_data: profession_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityCharBasicData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.community_id.is_some() {
            len += 1;
        }
        if self.homeland_id.is_some() {
            len += 1;
        }
        if !self.cohabitant_ids.is_empty() {
            len += 1;
        }
        if self.last_exit_cohabitation_time.is_some() {
            len += 1;
        }
        if self.buy_count.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityData", len)?;
        if let Some(v) = self.community_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CommunityId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.homeland_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HomelandId", ToString::to_string(&v).as_str())?;
        }
        if !self.cohabitant_ids.is_empty() {
            struct_ser.serialize_field("CohabitantIds", &self.cohabitant_ids.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if let Some(v) = self.last_exit_cohabitation_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastExitCohabitationTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.buy_count.as_ref() {
            struct_ser.serialize_field("BuyCount", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CommunityId",
            "HomelandId",
            "CohabitantIds",
            "LastExitCohabitationTime",
            "BuyCount",
            "Level",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CommunityId,
            HomelandId,
            CohabitantIds,
            LastExitCohabitationTime,
            BuyCount,
            Level,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CommunityId" => Ok(GeneratedField::CommunityId),
                            "HomelandId" => Ok(GeneratedField::HomelandId),
                            "CohabitantIds" => Ok(GeneratedField::CohabitantIds),
                            "LastExitCohabitationTime" => Ok(GeneratedField::LastExitCohabitationTime),
                            "BuyCount" => Ok(GeneratedField::BuyCount),
                            "Level" => Ok(GeneratedField::Level),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut community_id__ = None;
                let mut homeland_id__ = None;
                let mut cohabitant_ids__ = None;
                let mut last_exit_cohabitation_time__ = None;
                let mut buy_count__ = None;
                let mut level__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CommunityId => {
                            if community_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CommunityId"));
                            }
                            community_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HomelandId => {
                            if homeland_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomelandId"));
                            }
                            homeland_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CohabitantIds => {
                            if cohabitant_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CohabitantIds"));
                            }
                            cohabitant_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::LastExitCohabitationTime => {
                            if last_exit_cohabitation_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastExitCohabitationTime"));
                            }
                            last_exit_cohabitation_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BuyCount => {
                            if buy_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuyCount"));
                            }
                            buy_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CommunityData {
                    community_id: community_id__,
                    homeland_id: homeland_id__,
                    cohabitant_ids: cohabitant_ids__.unwrap_or_default(),
                    last_exit_cohabitation_time: last_exit_cohabitation_time__,
                    buy_count: buy_count__,
                    level: level__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityGetHomeLandBaseInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityGetHomeLandBaseInfo", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityGetHomeLandBaseInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityGetHomeLandBaseInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityGetHomeLandBaseInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityGetHomeLandBaseInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CommunityGetHomeLandBaseInfo {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityGetHomeLandBaseInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityGetHomeLandBaseInfoReply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.homeland_base_info.is_some() {
            len += 1;
        }
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityGetHomeLandBaseInfoReply", len)?;
        if let Some(v) = self.homeland_base_info.as_ref() {
            struct_ser.serialize_field("HomelandBaseInfo", v)?;
        }
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityGetHomeLandBaseInfoReply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HomelandBaseInfo",
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HomelandBaseInfo,
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "HomelandBaseInfo" => Ok(GeneratedField::HomelandBaseInfo),
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityGetHomeLandBaseInfoReply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityGetHomeLandBaseInfoReply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityGetHomeLandBaseInfoReply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut homeland_base_info__ = None;
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HomelandBaseInfo => {
                            if homeland_base_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomelandBaseInfo"));
                            }
                            homeland_base_info__ = map_.next_value()?;
                        }
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(CommunityGetHomeLandBaseInfoReply {
                    homeland_base_info: homeland_base_info__,
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityGetHomeLandBaseInfoReply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityGetHomeLandBaseInfoRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.community_id.is_some() {
            len += 1;
        }
        if self.homeland_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityGetHomeLandBaseInfoRequest", len)?;
        if let Some(v) = self.community_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CommunityId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.homeland_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HomelandId", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityGetHomeLandBaseInfoRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CommunityId",
            "HomelandId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CommunityId,
            HomelandId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CommunityId" => Ok(GeneratedField::CommunityId),
                            "HomelandId" => Ok(GeneratedField::HomelandId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityGetHomeLandBaseInfoRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityGetHomeLandBaseInfoRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityGetHomeLandBaseInfoRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut community_id__ = None;
                let mut homeland_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CommunityId => {
                            if community_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CommunityId"));
                            }
                            community_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HomelandId => {
                            if homeland_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomelandId"));
                            }
                            homeland_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CommunityGetHomeLandBaseInfoRequest {
                    community_id: community_id__,
                    homeland_id: homeland_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityGetHomeLandBaseInfoRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityGrainUpdateStructureReply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.err_code.is_some() {
            len += 1;
        }
        if !self.structures.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityGrainUpdateStructureReply", len)?;
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        if !self.structures.is_empty() {
            struct_ser.serialize_field("Structures", &self.structures)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityGrainUpdateStructureReply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ErrCode",
            "Structures",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ErrCode,
            Structures,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            "Structures" => Ok(GeneratedField::Structures),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityGrainUpdateStructureReply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityGrainUpdateStructureReply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityGrainUpdateStructureReply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut err_code__ = None;
                let mut structures__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Structures => {
                            if structures__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Structures"));
                            }
                            structures__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(CommunityGrainUpdateStructureReply {
                    err_code: err_code__,
                    structures: structures__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityGrainUpdateStructureReply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityHomeData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.community_id.is_some() {
            len += 1;
        }
        if self.homeland_id.is_some() {
            len += 1;
        }
        if self.buy_count.is_some() {
            len += 1;
        }
        if !self.unlocked_recipes.is_empty() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityHomeData", len)?;
        if let Some(v) = self.community_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CommunityId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.homeland_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HomelandId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.buy_count.as_ref() {
            struct_ser.serialize_field("BuyCount", v)?;
        }
        if !self.unlocked_recipes.is_empty() {
            struct_ser.serialize_field("UnlockedRecipes", &self.unlocked_recipes)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityHomeData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CommunityId",
            "HomelandId",
            "BuyCount",
            "UnlockedRecipes",
            "Level",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CommunityId,
            HomelandId,
            BuyCount,
            UnlockedRecipes,
            Level,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CommunityId" => Ok(GeneratedField::CommunityId),
                            "HomelandId" => Ok(GeneratedField::HomelandId),
                            "BuyCount" => Ok(GeneratedField::BuyCount),
                            "UnlockedRecipes" => Ok(GeneratedField::UnlockedRecipes),
                            "Level" => Ok(GeneratedField::Level),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityHomeData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityHomeData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityHomeData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut community_id__ = None;
                let mut homeland_id__ = None;
                let mut buy_count__ = None;
                let mut unlocked_recipes__ = None;
                let mut level__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CommunityId => {
                            if community_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CommunityId"));
                            }
                            community_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HomelandId => {
                            if homeland_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomelandId"));
                            }
                            homeland_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BuyCount => {
                            if buy_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuyCount"));
                            }
                            buy_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::UnlockedRecipes => {
                            if unlocked_recipes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockedRecipes"));
                            }
                            unlocked_recipes__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CommunityHomeData {
                    community_id: community_id__,
                    homeland_id: homeland_id__,
                    buy_count: buy_count__,
                    unlocked_recipes: unlocked_recipes__.unwrap_or_default(),
                    level: level__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityHomeData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityHomelandRecipe {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityHomelandRecipe", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityHomelandRecipe {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityHomelandRecipe;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityHomelandRecipe")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityHomelandRecipe, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CommunityHomelandRecipe {
                    id: id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityHomelandRecipe", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityPlayerAuthorityInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.authority.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityPlayerAuthorityInfo", len)?;
        if !self.authority.is_empty() {
            struct_ser.serialize_field("Authority", &self.authority)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityPlayerAuthorityInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Authority",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Authority,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Authority" => Ok(GeneratedField::Authority),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityPlayerAuthorityInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityPlayerAuthorityInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityPlayerAuthorityInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut authority__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Authority => {
                            if authority__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Authority"));
                            }
                            authority__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(CommunityPlayerAuthorityInfo {
                    authority: authority__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityPlayerAuthorityInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityPlayerInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.community_char.is_some() {
            len += 1;
        }
        if self.player_authority_info.is_some() {
            len += 1;
        }
        if self.quit_cohabitant.is_some() {
            len += 1;
        }
        if self.home_land_player_task_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityPlayerInfo", len)?;
        if let Some(v) = self.community_char.as_ref() {
            struct_ser.serialize_field("CommunityChar", v)?;
        }
        if let Some(v) = self.player_authority_info.as_ref() {
            struct_ser.serialize_field("PlayerAuthorityInfo", v)?;
        }
        if let Some(v) = self.quit_cohabitant.as_ref() {
            struct_ser.serialize_field("QuitCohabitant", v)?;
        }
        if let Some(v) = self.home_land_player_task_info.as_ref() {
            struct_ser.serialize_field("HomeLandPlayerTaskInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityPlayerInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CommunityChar",
            "PlayerAuthorityInfo",
            "QuitCohabitant",
            "HomeLandPlayerTaskInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CommunityChar,
            PlayerAuthorityInfo,
            QuitCohabitant,
            HomeLandPlayerTaskInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CommunityChar" => Ok(GeneratedField::CommunityChar),
                            "PlayerAuthorityInfo" => Ok(GeneratedField::PlayerAuthorityInfo),
                            "QuitCohabitant" => Ok(GeneratedField::QuitCohabitant),
                            "HomeLandPlayerTaskInfo" => Ok(GeneratedField::HomeLandPlayerTaskInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityPlayerInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityPlayerInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityPlayerInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut community_char__ = None;
                let mut player_authority_info__ = None;
                let mut quit_cohabitant__ = None;
                let mut home_land_player_task_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CommunityChar => {
                            if community_char__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CommunityChar"));
                            }
                            community_char__ = map_.next_value()?;
                        }
                        GeneratedField::PlayerAuthorityInfo => {
                            if player_authority_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayerAuthorityInfo"));
                            }
                            player_authority_info__ = map_.next_value()?;
                        }
                        GeneratedField::QuitCohabitant => {
                            if quit_cohabitant__.is_some() {
                                return Err(serde::de::Error::duplicate_field("QuitCohabitant"));
                            }
                            quit_cohabitant__ = map_.next_value()?;
                        }
                        GeneratedField::HomeLandPlayerTaskInfo => {
                            if home_land_player_task_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomeLandPlayerTaskInfo"));
                            }
                            home_land_player_task_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CommunityPlayerInfo {
                    community_char: community_char__,
                    player_authority_info: player_authority_info__,
                    quit_cohabitant: quit_cohabitant__,
                    home_land_player_task_info: home_land_player_task_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityPlayerInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityQuitCohabitant {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_initiative_quit.is_some() {
            len += 1;
        }
        if self.time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityQuitCohabitant", len)?;
        if let Some(v) = self.is_initiative_quit.as_ref() {
            struct_ser.serialize_field("IsInitiativeQuit", v)?;
        }
        if let Some(v) = self.time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Time", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityQuitCohabitant {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsInitiativeQuit",
            "Time",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsInitiativeQuit,
            Time,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsInitiativeQuit" => Ok(GeneratedField::IsInitiativeQuit),
                            "Time" => Ok(GeneratedField::Time),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityQuitCohabitant;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityQuitCohabitant")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityQuitCohabitant, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_initiative_quit__ = None;
                let mut time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsInitiativeQuit => {
                            if is_initiative_quit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsInitiativeQuit"));
                            }
                            is_initiative_quit__ = map_.next_value()?;
                        }
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Time"));
                            }
                            time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CommunityQuitCohabitant {
                    is_initiative_quit: is_initiative_quit__,
                    time: time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityQuitCohabitant", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityTransfer {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.char_id.is_some() {
            len += 1;
        }
        if self.time.is_some() {
            len += 1;
        }
        if self.last_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityTransfer", len)?;
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Time", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.last_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityTransfer {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CharId",
            "Time",
            "LastTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CharId,
            Time,
            LastTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CharId" => Ok(GeneratedField::CharId),
                            "Time" => Ok(GeneratedField::Time),
                            "LastTime" => Ok(GeneratedField::LastTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityTransfer;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityTransfer")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityTransfer, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut char_id__ = None;
                let mut time__ = None;
                let mut last_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Time"));
                            }
                            time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastTime => {
                            if last_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastTime"));
                            }
                            last_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CommunityTransfer {
                    char_id: char_id__,
                    time: time__,
                    last_time: last_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityTransfer", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommunityUpdateStructureReplyOpt {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.err_code.is_some() {
            len += 1;
        }
        if self.structure_op.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CommunityUpdateStructureReplyOpt", len)?;
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        if let Some(v) = self.structure_op.as_ref() {
            struct_ser.serialize_field("StructureOp", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommunityUpdateStructureReplyOpt {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ErrCode",
            "StructureOp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ErrCode,
            StructureOp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            "StructureOp" => Ok(GeneratedField::StructureOp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommunityUpdateStructureReplyOpt;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CommunityUpdateStructureReplyOpt")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommunityUpdateStructureReplyOpt, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut err_code__ = None;
                let mut structure_op__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                        GeneratedField::StructureOp => {
                            if structure_op__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StructureOp"));
                            }
                            structure_op__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CommunityUpdateStructureReplyOpt {
                    err_code: err_code__,
                    structure_op: structure_op__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CommunityUpdateStructureReplyOpt", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CompensationData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.overflow_energy.is_some() {
            len += 1;
        }
        if self.finish_times.is_some() {
            len += 1;
        }
        if self.climb_up_layer_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CompensationData", len)?;
        if let Some(v) = self.overflow_energy.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("OverflowEnergy", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.finish_times.as_ref() {
            struct_ser.serialize_field("FinishTimes", v)?;
        }
        if let Some(v) = self.climb_up_layer_id.as_ref() {
            struct_ser.serialize_field("ClimbUpLayerId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CompensationData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OverflowEnergy",
            "FinishTimes",
            "ClimbUpLayerId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OverflowEnergy,
            FinishTimes,
            ClimbUpLayerId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "OverflowEnergy" => Ok(GeneratedField::OverflowEnergy),
                            "FinishTimes" => Ok(GeneratedField::FinishTimes),
                            "ClimbUpLayerId" => Ok(GeneratedField::ClimbUpLayerId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CompensationData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CompensationData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CompensationData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut overflow_energy__ = None;
                let mut finish_times__ = None;
                let mut climb_up_layer_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OverflowEnergy => {
                            if overflow_energy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OverflowEnergy"));
                            }
                            overflow_energy__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FinishTimes => {
                            if finish_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FinishTimes"));
                            }
                            finish_times__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ClimbUpLayerId => {
                            if climb_up_layer_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ClimbUpLayerId"));
                            }
                            climb_up_layer_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CompensationData {
                    overflow_energy: overflow_energy__,
                    finish_times: finish_times__,
                    climb_up_layer_id: climb_up_layer_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CompensationData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CompensationRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.compensation_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CompensationRecord", len)?;
        if !self.compensation_data.is_empty() {
            struct_ser.serialize_field("CompensationData", &self.compensation_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CompensationRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CompensationData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CompensationData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CompensationData" => Ok(GeneratedField::CompensationData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CompensationRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CompensationRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CompensationRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut compensation_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CompensationData => {
                            if compensation_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CompensationData"));
                            }
                            compensation_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(CompensationRecord {
                    compensation_data: compensation_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CompensationRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CompensationSeasonStatistics {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.week_data.is_empty() {
            len += 1;
        }
        if !self.compensation.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CompensationSeasonStatistics", len)?;
        if !self.week_data.is_empty() {
            struct_ser.serialize_field("WeekData", &self.week_data)?;
        }
        if !self.compensation.is_empty() {
            struct_ser.serialize_field("Compensation", &self.compensation)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CompensationSeasonStatistics {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "WeekData",
            "Compensation",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            WeekData,
            Compensation,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "WeekData" => Ok(GeneratedField::WeekData),
                            "Compensation" => Ok(GeneratedField::Compensation),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CompensationSeasonStatistics;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CompensationSeasonStatistics")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CompensationSeasonStatistics, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut week_data__ = None;
                let mut compensation__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::WeekData => {
                            if week_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WeekData"));
                            }
                            week_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::Compensation => {
                            if compensation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Compensation"));
                            }
                            compensation__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(CompensationSeasonStatistics {
                    week_data: week_data__.unwrap_or_default(),
                    compensation: compensation__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CompensationSeasonStatistics", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CompensationStatistics {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.season_data.is_empty() {
            len += 1;
        }
        if self.last_season_id.is_some() {
            len += 1;
        }
        if self.cur_point.is_some() {
            len += 1;
        }
        if self.max_point.is_some() {
            len += 1;
        }
        if !self.last_week.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CompensationStatistics", len)?;
        if !self.season_data.is_empty() {
            struct_ser.serialize_field("SeasonData", &self.season_data)?;
        }
        if let Some(v) = self.last_season_id.as_ref() {
            struct_ser.serialize_field("LastSeasonId", v)?;
        }
        if let Some(v) = self.cur_point.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CurPoint", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.max_point.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("MaxPoint", ToString::to_string(&v).as_str())?;
        }
        if !self.last_week.is_empty() {
            struct_ser.serialize_field("LastWeek", &self.last_week)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CompensationStatistics {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SeasonData",
            "LastSeasonId",
            "CurPoint",
            "MaxPoint",
            "LastWeek",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SeasonData,
            LastSeasonId,
            CurPoint,
            MaxPoint,
            LastWeek,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SeasonData" => Ok(GeneratedField::SeasonData),
                            "LastSeasonId" => Ok(GeneratedField::LastSeasonId),
                            "CurPoint" => Ok(GeneratedField::CurPoint),
                            "MaxPoint" => Ok(GeneratedField::MaxPoint),
                            "LastWeek" => Ok(GeneratedField::LastWeek),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CompensationStatistics;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CompensationStatistics")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CompensationStatistics, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut season_data__ = None;
                let mut last_season_id__ = None;
                let mut cur_point__ = None;
                let mut max_point__ = None;
                let mut last_week__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SeasonData => {
                            if season_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonData"));
                            }
                            season_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::LastSeasonId => {
                            if last_season_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastSeasonId"));
                            }
                            last_season_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurPoint => {
                            if cur_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurPoint"));
                            }
                            cur_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxPoint => {
                            if max_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaxPoint"));
                            }
                            max_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastWeek => {
                            if last_week__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastWeek"));
                            }
                            last_week__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(CompensationStatistics {
                    season_data: season_data__.unwrap_or_default(),
                    last_season_id: last_season_id__,
                    cur_point: cur_point__,
                    max_point: max_point__,
                    last_week: last_week__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CompensationStatistics", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CompletedTargetInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.completed_target_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CompletedTargetInfo", len)?;
        if !self.completed_target_list.is_empty() {
            struct_ser.serialize_field("CompletedTargetList", &self.completed_target_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CompletedTargetInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CompletedTargetList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CompletedTargetList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CompletedTargetList" => Ok(GeneratedField::CompletedTargetList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CompletedTargetInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CompletedTargetInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CompletedTargetInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut completed_target_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CompletedTargetList => {
                            if completed_target_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CompletedTargetList"));
                            }
                            completed_target_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(CompletedTargetInfo {
                    completed_target_list: completed_target_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CompletedTargetInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConnectWorld {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ConnectWorld", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConnectWorld {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConnectWorld;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ConnectWorld")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ConnectWorld, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ConnectWorld {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ConnectWorld", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConnectWorldResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.result.is_some() {
            len += 1;
        }
        if self.err_code.is_some() {
            len += 1;
        }
        if self.ack_client_sequence.is_some() {
            len += 1;
        }
        if self.session_token.is_some() {
            len += 1;
        }
        if self.connect_guid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ConnectWorldResult", len)?;
        if let Some(v) = self.result.as_ref() {
            let v = WorldReconnectStatus::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Result", &v)?;
        }
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        if let Some(v) = self.ack_client_sequence.as_ref() {
            struct_ser.serialize_field("AckClientSequence", v)?;
        }
        if let Some(v) = self.session_token.as_ref() {
            struct_ser.serialize_field("SessionToken", v)?;
        }
        if let Some(v) = self.connect_guid.as_ref() {
            struct_ser.serialize_field("ConnectGuid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConnectWorldResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Result",
            "ErrCode",
            "AckClientSequence",
            "SessionToken",
            "ConnectGuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Result,
            ErrCode,
            AckClientSequence,
            SessionToken,
            ConnectGuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Result" => Ok(GeneratedField::Result),
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            "AckClientSequence" => Ok(GeneratedField::AckClientSequence),
                            "SessionToken" => Ok(GeneratedField::SessionToken),
                            "ConnectGuid" => Ok(GeneratedField::ConnectGuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConnectWorldResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ConnectWorldResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ConnectWorldResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut result__ = None;
                let mut err_code__ = None;
                let mut ack_client_sequence__ = None;
                let mut session_token__ = None;
                let mut connect_guid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Result => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Result"));
                            }
                            result__ = map_.next_value::<::std::option::Option<WorldReconnectStatus>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                        GeneratedField::AckClientSequence => {
                            if ack_client_sequence__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AckClientSequence"));
                            }
                            ack_client_sequence__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SessionToken => {
                            if session_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SessionToken"));
                            }
                            session_token__ = map_.next_value()?;
                        }
                        GeneratedField::ConnectGuid => {
                            if connect_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConnectGuid"));
                            }
                            connect_guid__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ConnectWorldResult {
                    result: result__,
                    err_code: err_code__,
                    ack_client_sequence: ack_client_sequence__,
                    session_token: session_token__,
                    connect_guid: connect_guid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ConnectWorldResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CookBook {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.create_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CookBook", len)?;
        if let Some(v) = self.create_time.as_ref() {
            struct_ser.serialize_field("CreateTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CookBook {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CreateTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CreateTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CreateTime" => Ok(GeneratedField::CreateTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CookBook;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CookBook")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CookBook, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut create_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CreateTime => {
                            if create_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateTime"));
                            }
                            create_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CookBook {
                    create_time: create_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CookBook", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CookList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.book_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CookList", len)?;
        if !self.book_data.is_empty() {
            struct_ser.serialize_field("BookData", &self.book_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CookList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BookData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BookData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BookData" => Ok(GeneratedField::BookData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CookList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CookList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CookList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut book_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BookData => {
                            if book_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BookData"));
                            }
                            book_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(CookList {
                    book_data: book_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CookList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CounterInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.counter.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CounterInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.counter.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Counter", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CounterInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Counter",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Counter,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Counter" => Ok(GeneratedField::Counter),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CounterInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CounterInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CounterInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut counter__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Counter => {
                            if counter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Counter"));
                            }
                            counter__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CounterInfo {
                    id: id__,
                    counter: counter__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CounterInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CounterList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.counter_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CounterList", len)?;
        if !self.counter_map.is_empty() {
            struct_ser.serialize_field("CounterMap", &self.counter_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CounterList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CounterMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CounterMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CounterMap" => Ok(GeneratedField::CounterMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CounterList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CounterList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CounterList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut counter_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CounterMap => {
                            if counter_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CounterMap"));
                            }
                            counter_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(CounterList {
                    counter_map: counter_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CounterList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CraftEnergyRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.records.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CraftEnergyRecord", len)?;
        if !self.records.is_empty() {
            struct_ser.serialize_field("Records", &self.records)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CraftEnergyRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Records",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Records,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Records" => Ok(GeneratedField::Records),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CraftEnergyRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CraftEnergyRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CraftEnergyRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut records__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Records => {
                            if records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Records"));
                            }
                            records__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(CraftEnergyRecord {
                    records: records__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CraftEnergyRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CurrencyData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.config_id.is_some() {
            len += 1;
        }
        if self.count.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CurrencyData", len)?;
        if let Some(v) = self.config_id.as_ref() {
            struct_ser.serialize_field("ConfigId", v)?;
        }
        if let Some(v) = self.count.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Count", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CurrencyData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ConfigId",
            "Count",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ConfigId,
            Count,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ConfigId" => Ok(GeneratedField::ConfigId),
                            "Count" => Ok(GeneratedField::Count),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CurrencyData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CurrencyData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CurrencyData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut config_id__ = None;
                let mut count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ConfigId => {
                            if config_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConfigId"));
                            }
                            config_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Count"));
                            }
                            count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CurrencyData {
                    config_id: config_id__,
                    count: count__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CurrencyData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CutSceneInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cut_scene_id.is_some() {
            len += 1;
        }
        if self.flag.is_some() {
            len += 1;
        }
        if self.scene_id.is_some() {
            len += 1;
        }
        if self.event_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CutSceneInfo", len)?;
        if let Some(v) = self.cut_scene_id.as_ref() {
            struct_ser.serialize_field("CutSceneId", v)?;
        }
        if let Some(v) = self.flag.as_ref() {
            struct_ser.serialize_field("Flag", v)?;
        }
        if let Some(v) = self.scene_id.as_ref() {
            struct_ser.serialize_field("SceneId", v)?;
        }
        if let Some(v) = self.event_data.as_ref() {
            struct_ser.serialize_field("EventData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CutSceneInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CutSceneId",
            "Flag",
            "SceneId",
            "EventData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CutSceneId,
            Flag,
            SceneId,
            EventData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CutSceneId" => Ok(GeneratedField::CutSceneId),
                            "Flag" => Ok(GeneratedField::Flag),
                            "SceneId" => Ok(GeneratedField::SceneId),
                            "EventData" => Ok(GeneratedField::EventData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CutSceneInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CutSceneInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CutSceneInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cut_scene_id__ = None;
                let mut flag__ = None;
                let mut scene_id__ = None;
                let mut event_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CutSceneId => {
                            if cut_scene_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CutSceneId"));
                            }
                            cut_scene_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Flag => {
                            if flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Flag"));
                            }
                            flag__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SceneId => {
                            if scene_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneId"));
                            }
                            scene_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EventData => {
                            if event_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EventData"));
                            }
                            event_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CutSceneInfo {
                    cut_scene_id: cut_scene_id__,
                    flag: flag__,
                    scene_id: scene_id__,
                    event_data: event_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CutSceneInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CutSceneInfos {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.cut_scene_infos.is_empty() {
            len += 1;
        }
        if !self.finished_cut_scenes.is_empty() {
            len += 1;
        }
        if !self.finished_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CutSceneInfos", len)?;
        if !self.cut_scene_infos.is_empty() {
            struct_ser.serialize_field("CutSceneInfos", &self.cut_scene_infos)?;
        }
        if !self.finished_cut_scenes.is_empty() {
            struct_ser.serialize_field("FinishedCutScenes", &self.finished_cut_scenes)?;
        }
        if !self.finished_infos.is_empty() {
            struct_ser.serialize_field("FinishedInfos", &self.finished_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CutSceneInfos {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CutSceneInfos_",
            "CutSceneInfos",
            "FinishedCutScenes",
            "FinishedInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CutSceneInfos,
            FinishedCutScenes,
            FinishedInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CutSceneInfos" | "CutSceneInfos_" => Ok(GeneratedField::CutSceneInfos),
                            "FinishedCutScenes" => Ok(GeneratedField::FinishedCutScenes),
                            "FinishedInfos" => Ok(GeneratedField::FinishedInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CutSceneInfos;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CutSceneInfos")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CutSceneInfos, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cut_scene_infos__ = None;
                let mut finished_cut_scenes__ = None;
                let mut finished_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CutSceneInfos => {
                            if cut_scene_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CutSceneInfos"));
                            }
                            cut_scene_infos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::FinishedCutScenes => {
                            if finished_cut_scenes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FinishedCutScenes"));
                            }
                            finished_cut_scenes__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::FinishedInfos => {
                            if finished_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FinishedInfos"));
                            }
                            finished_infos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(CutSceneInfos {
                    cut_scene_infos: cut_scene_infos__.unwrap_or_default(),
                    finished_cut_scenes: finished_cut_scenes__.unwrap_or_default(),
                    finished_infos: finished_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CutSceneInfos", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CutScenePlayEnd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_cut_scene_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CutScenePlayEnd", len)?;
        if let Some(v) = self.v_cut_scene_id.as_ref() {
            struct_ser.serialize_field("VCutSceneId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CutScenePlayEnd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VCutSceneId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VCutSceneId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VCutSceneId" => Ok(GeneratedField::VCutSceneId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CutScenePlayEnd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CutScenePlayEnd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CutScenePlayEnd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_cut_scene_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VCutSceneId => {
                            if v_cut_scene_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VCutSceneId"));
                            }
                            v_cut_scene_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CutScenePlayEnd {
                    v_cut_scene_id: v_cut_scene_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CutScenePlayEnd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CutScenePointInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cut_scene_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CutScenePointInfo", len)?;
        if let Some(v) = self.cut_scene_id.as_ref() {
            struct_ser.serialize_field("CutSceneId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CutScenePointInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CutSceneId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CutSceneId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CutSceneId" => Ok(GeneratedField::CutSceneId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CutScenePointInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CutScenePointInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CutScenePointInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cut_scene_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CutSceneId => {
                            if cut_scene_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CutSceneId"));
                            }
                            cut_scene_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CutScenePointInfo {
                    cut_scene_id: cut_scene_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CutScenePointInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CutsState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.state_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.CutsState", len)?;
        if !self.state_info.is_empty() {
            struct_ser.serialize_field("StateInfo", &self.state_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CutsState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "StateInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StateInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "StateInfo" => Ok(GeneratedField::StateInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CutsState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.CutsState")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CutsState, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut state_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StateInfo => {
                            if state_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StateInfo"));
                            }
                            state_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(CutsState {
                    state_info: state_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.CutsState", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DanceBall {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.dance_id.is_some() {
            len += 1;
        }
        if self.begin_time.is_some() {
            len += 1;
        }
        if self.end_time.is_some() {
            len += 1;
        }
        if self.rand_index.is_some() {
            len += 1;
        }
        if !self.dancers.is_empty() {
            len += 1;
        }
        if self.buff_id.is_some() {
            len += 1;
        }
        if self.npc_id.is_some() {
            len += 1;
        }
        if self.npc_pos_index.is_some() {
            len += 1;
        }
        if self.sum_dance_score.is_some() {
            len += 1;
        }
        if self.has_notify_npc.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DanceBall", len)?;
        if let Some(v) = self.dance_id.as_ref() {
            struct_ser.serialize_field("DanceId", v)?;
        }
        if let Some(v) = self.begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.end_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("EndTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.rand_index.as_ref() {
            struct_ser.serialize_field("RandIndex", v)?;
        }
        if !self.dancers.is_empty() {
            struct_ser.serialize_field("Dancers", &self.dancers)?;
        }
        if let Some(v) = self.buff_id.as_ref() {
            struct_ser.serialize_field("BuffId", v)?;
        }
        if let Some(v) = self.npc_id.as_ref() {
            struct_ser.serialize_field("NpcId", v)?;
        }
        if let Some(v) = self.npc_pos_index.as_ref() {
            struct_ser.serialize_field("NpcPosIndex", v)?;
        }
        if let Some(v) = self.sum_dance_score.as_ref() {
            struct_ser.serialize_field("SumDanceScore", v)?;
        }
        if let Some(v) = self.has_notify_npc.as_ref() {
            struct_ser.serialize_field("HasNotifyNpc", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DanceBall {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DanceId",
            "BeginTime",
            "EndTime",
            "RandIndex",
            "Dancers",
            "BuffId",
            "NpcId",
            "NpcPosIndex",
            "SumDanceScore",
            "HasNotifyNpc",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DanceId,
            BeginTime,
            EndTime,
            RandIndex,
            Dancers,
            BuffId,
            NpcId,
            NpcPosIndex,
            SumDanceScore,
            HasNotifyNpc,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DanceId" => Ok(GeneratedField::DanceId),
                            "BeginTime" => Ok(GeneratedField::BeginTime),
                            "EndTime" => Ok(GeneratedField::EndTime),
                            "RandIndex" => Ok(GeneratedField::RandIndex),
                            "Dancers" => Ok(GeneratedField::Dancers),
                            "BuffId" => Ok(GeneratedField::BuffId),
                            "NpcId" => Ok(GeneratedField::NpcId),
                            "NpcPosIndex" => Ok(GeneratedField::NpcPosIndex),
                            "SumDanceScore" => Ok(GeneratedField::SumDanceScore),
                            "HasNotifyNpc" => Ok(GeneratedField::HasNotifyNpc),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DanceBall;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DanceBall")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DanceBall, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dance_id__ = None;
                let mut begin_time__ = None;
                let mut end_time__ = None;
                let mut rand_index__ = None;
                let mut dancers__ = None;
                let mut buff_id__ = None;
                let mut npc_id__ = None;
                let mut npc_pos_index__ = None;
                let mut sum_dance_score__ = None;
                let mut has_notify_npc__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DanceId => {
                            if dance_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DanceId"));
                            }
                            dance_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BeginTime => {
                            if begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeginTime"));
                            }
                            begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EndTime"));
                            }
                            end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RandIndex => {
                            if rand_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RandIndex"));
                            }
                            rand_index__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Dancers => {
                            if dancers__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Dancers"));
                            }
                            dancers__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::BuffId => {
                            if buff_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffId"));
                            }
                            buff_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NpcId => {
                            if npc_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NpcId"));
                            }
                            npc_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NpcPosIndex => {
                            if npc_pos_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NpcPosIndex"));
                            }
                            npc_pos_index__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SumDanceScore => {
                            if sum_dance_score__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SumDanceScore"));
                            }
                            sum_dance_score__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HasNotifyNpc => {
                            if has_notify_npc__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HasNotifyNpc"));
                            }
                            has_notify_npc__ = map_.next_value()?;
                        }
                    }
                }
                Ok(DanceBall {
                    dance_id: dance_id__,
                    begin_time: begin_time__,
                    end_time: end_time__,
                    rand_index: rand_index__,
                    dancers: dancers__.unwrap_or_default(),
                    buff_id: buff_id__,
                    npc_id: npc_id__,
                    npc_pos_index: npc_pos_index__,
                    sum_dance_score: sum_dance_score__,
                    has_notify_npc: has_notify_npc__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DanceBall", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DancerInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.char_id.is_some() {
            len += 1;
        }
        if self.dance_secs.is_some() {
            len += 1;
        }
        if self.is_dancing.is_some() {
            len += 1;
        }
        if self.has_drawn.is_some() {
            len += 1;
        }
        if self.has_send.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DancerInfo", len)?;
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.dance_secs.as_ref() {
            struct_ser.serialize_field("DanceSecs", v)?;
        }
        if let Some(v) = self.is_dancing.as_ref() {
            struct_ser.serialize_field("IsDancing", v)?;
        }
        if let Some(v) = self.has_drawn.as_ref() {
            struct_ser.serialize_field("HasDrawn", v)?;
        }
        if let Some(v) = self.has_send.as_ref() {
            struct_ser.serialize_field("HasSend", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DancerInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CharId",
            "DanceSecs",
            "IsDancing",
            "HasDrawn",
            "HasSend",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CharId,
            DanceSecs,
            IsDancing,
            HasDrawn,
            HasSend,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CharId" => Ok(GeneratedField::CharId),
                            "DanceSecs" => Ok(GeneratedField::DanceSecs),
                            "IsDancing" => Ok(GeneratedField::IsDancing),
                            "HasDrawn" => Ok(GeneratedField::HasDrawn),
                            "HasSend" => Ok(GeneratedField::HasSend),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DancerInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DancerInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DancerInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut char_id__ = None;
                let mut dance_secs__ = None;
                let mut is_dancing__ = None;
                let mut has_drawn__ = None;
                let mut has_send__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DanceSecs => {
                            if dance_secs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DanceSecs"));
                            }
                            dance_secs__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsDancing => {
                            if is_dancing__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsDancing"));
                            }
                            is_dancing__ = map_.next_value()?;
                        }
                        GeneratedField::HasDrawn => {
                            if has_drawn__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HasDrawn"));
                            }
                            has_drawn__ = map_.next_value()?;
                        }
                        GeneratedField::HasSend => {
                            if has_send__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HasSend"));
                            }
                            has_send__ = map_.next_value()?;
                        }
                    }
                }
                Ok(DancerInfo {
                    char_id: char_id__,
                    dance_secs: dance_secs__,
                    is_dancing: is_dancing__,
                    has_drawn: has_drawn__,
                    has_send: has_send__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DancerInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DelayHitInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.effect_id.is_some() {
            len += 1;
        }
        if self.buff_uuid.is_some() {
            len += 1;
        }
        if self.event_id.is_some() {
            len += 1;
        }
        if self.play_time.is_some() {
            len += 1;
        }
        if !self.target_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DelayHitInfo", len)?;
        if let Some(v) = self.effect_id.as_ref() {
            struct_ser.serialize_field("EffectId", v)?;
        }
        if let Some(v) = self.buff_uuid.as_ref() {
            struct_ser.serialize_field("BuffUuid", v)?;
        }
        if let Some(v) = self.event_id.as_ref() {
            struct_ser.serialize_field("EventId", v)?;
        }
        if let Some(v) = self.play_time.as_ref() {
            struct_ser.serialize_field("PlayTime", v)?;
        }
        if !self.target_infos.is_empty() {
            struct_ser.serialize_field("TargetInfos", &self.target_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DelayHitInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EffectId",
            "BuffUuid",
            "EventId",
            "PlayTime",
            "TargetInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EffectId,
            BuffUuid,
            EventId,
            PlayTime,
            TargetInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EffectId" => Ok(GeneratedField::EffectId),
                            "BuffUuid" => Ok(GeneratedField::BuffUuid),
                            "EventId" => Ok(GeneratedField::EventId),
                            "PlayTime" => Ok(GeneratedField::PlayTime),
                            "TargetInfos" => Ok(GeneratedField::TargetInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DelayHitInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DelayHitInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DelayHitInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut effect_id__ = None;
                let mut buff_uuid__ = None;
                let mut event_id__ = None;
                let mut play_time__ = None;
                let mut target_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EffectId => {
                            if effect_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EffectId"));
                            }
                            effect_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BuffUuid => {
                            if buff_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffUuid"));
                            }
                            buff_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EventId => {
                            if event_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EventId"));
                            }
                            event_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PlayTime => {
                            if play_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayTime"));
                            }
                            play_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetInfos => {
                            if target_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetInfos"));
                            }
                            target_infos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DelayHitInfo {
                    effect_id: effect_id__,
                    buff_uuid: buff_uuid__,
                    event_id: event_id__,
                    play_time: play_time__,
                    target_infos: target_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DelayHitInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DelayHitTargetInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target_uuid.is_some() {
            len += 1;
        }
        if self.hit_pos.is_some() {
            len += 1;
        }
        if self.delay_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DelayHitTargetInfo", len)?;
        if let Some(v) = self.target_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.hit_pos.as_ref() {
            struct_ser.serialize_field("HitPos", v)?;
        }
        if let Some(v) = self.delay_time.as_ref() {
            struct_ser.serialize_field("DelayTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DelayHitTargetInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetUuid",
            "HitPos",
            "DelayTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetUuid,
            HitPos,
            DelayTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            "HitPos" => Ok(GeneratedField::HitPos),
                            "DelayTime" => Ok(GeneratedField::DelayTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DelayHitTargetInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DelayHitTargetInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DelayHitTargetInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_uuid__ = None;
                let mut hit_pos__ = None;
                let mut delay_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HitPos => {
                            if hit_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HitPos"));
                            }
                            hit_pos__ = map_.next_value()?;
                        }
                        GeneratedField::DelayTime => {
                            if delay_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DelayTime"));
                            }
                            delay_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DelayHitTargetInfo {
                    target_uuid: target_uuid__,
                    hit_pos: hit_pos__,
                    delay_time: delay_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DelayHitTargetInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DetachRideMagnetic {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.detach_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DetachRideMagnetic", len)?;
        if let Some(v) = self.detach_type.as_ref() {
            let v = EDetachMagneticType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("DetachType", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DetachRideMagnetic {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DetachType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DetachType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DetachType" => Ok(GeneratedField::DetachType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DetachRideMagnetic;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DetachRideMagnetic")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DetachRideMagnetic, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut detach_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DetachType => {
                            if detach_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DetachType"));
                            }
                            detach_type__ = map_.next_value::<::std::option::Option<EDetachMagneticType>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(DetachRideMagnetic {
                    detach_type: detach_type__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DetachRideMagnetic", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DirtyMask {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dirty_key.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DirtyMask", len)?;
        if !self.dirty_key.is_empty() {
            struct_ser.serialize_field("DirtyKey", &self.dirty_key.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DirtyMask {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DirtyKey",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DirtyKey,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DirtyKey" => Ok(GeneratedField::DirtyKey),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DirtyMask;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DirtyMask")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DirtyMask, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dirty_key__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DirtyKey => {
                            if dirty_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DirtyKey"));
                            }
                            dirty_key__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(DirtyMask {
                    dirty_key: dirty_key__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DirtyMask", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DisappearEntity {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DisappearEntity", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.r#type.as_ref() {
            let v = EDisappearType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Type", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DisappearEntity {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "Type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            Type,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "Type" => Ok(GeneratedField::Type),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DisappearEntity;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DisappearEntity")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DisappearEntity, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<EDisappearType>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(DisappearEntity {
                    uuid: uuid__,
                    r#type: r#type__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DisappearEntity", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DrawingLines {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.color.is_some() {
            len += 1;
        }
        if self.width.is_some() {
            len += 1;
        }
        if self.delete_time.is_some() {
            len += 1;
        }
        if !self.points.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DrawingLines", len)?;
        if let Some(v) = self.color.as_ref() {
            struct_ser.serialize_field("Color", v)?;
        }
        if let Some(v) = self.width.as_ref() {
            struct_ser.serialize_field("Width", v)?;
        }
        if let Some(v) = self.delete_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("DeleteTime", ToString::to_string(&v).as_str())?;
        }
        if !self.points.is_empty() {
            struct_ser.serialize_field("Points", &self.points)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DrawingLines {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Color",
            "Width",
            "DeleteTime",
            "Points",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Color,
            Width,
            DeleteTime,
            Points,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Color" => Ok(GeneratedField::Color),
                            "Width" => Ok(GeneratedField::Width),
                            "DeleteTime" => Ok(GeneratedField::DeleteTime),
                            "Points" => Ok(GeneratedField::Points),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DrawingLines;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DrawingLines")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DrawingLines, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut color__ = None;
                let mut width__ = None;
                let mut delete_time__ = None;
                let mut points__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Color => {
                            if color__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Color"));
                            }
                            color__ = map_.next_value()?;
                        }
                        GeneratedField::Width => {
                            if width__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Width"));
                            }
                            width__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DeleteTime => {
                            if delete_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DeleteTime"));
                            }
                            delete_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Points => {
                            if points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Points"));
                            }
                            points__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DrawingLines {
                    color: color__,
                    width: width__,
                    delete_time: delete_time__,
                    points: points__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DrawingLines", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DropAwardHistory {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.count.is_some() {
            len += 1;
        }
        if self.cycle_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DropAwardHistory", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.count.as_ref() {
            struct_ser.serialize_field("Count", v)?;
        }
        if let Some(v) = self.cycle_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CycleTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DropAwardHistory {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Count",
            "CycleTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Count,
            CycleTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Count" => Ok(GeneratedField::Count),
                            "CycleTime" => Ok(GeneratedField::CycleTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DropAwardHistory;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DropAwardHistory")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DropAwardHistory, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut count__ = None;
                let mut cycle_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Count"));
                            }
                            count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CycleTime => {
                            if cycle_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CycleTime"));
                            }
                            cycle_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DropAwardHistory {
                    id: id__,
                    count: count__,
                    cycle_time: cycle_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DropAwardHistory", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DropContainerInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.drop_containers.is_empty() {
            len += 1;
        }
        if !self.drop_award_histories.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DropContainerInfo", len)?;
        if !self.drop_containers.is_empty() {
            struct_ser.serialize_field("DropContainers", &self.drop_containers)?;
        }
        if !self.drop_award_histories.is_empty() {
            struct_ser.serialize_field("DropAwardHistories", &self.drop_award_histories)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DropContainerInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DropContainers",
            "DropAwardHistories",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DropContainers,
            DropAwardHistories,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DropContainers" => Ok(GeneratedField::DropContainers),
                            "DropAwardHistories" => Ok(GeneratedField::DropAwardHistories),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DropContainerInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DropContainerInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DropContainerInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut drop_containers__ = None;
                let mut drop_award_histories__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DropContainers => {
                            if drop_containers__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DropContainers"));
                            }
                            drop_containers__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::DropAwardHistories => {
                            if drop_award_histories__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DropAwardHistories"));
                            }
                            drop_award_histories__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DropContainerInfo {
                    drop_containers: drop_containers__.unwrap_or_default(),
                    drop_award_histories: drop_award_histories__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DropContainerInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DropContainerSingle {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.count.is_some() {
            len += 1;
        }
        if self.cycle_time.is_some() {
            len += 1;
        }
        if self.history_count.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DropContainerSingle", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.count.as_ref() {
            struct_ser.serialize_field("Count", v)?;
        }
        if let Some(v) = self.cycle_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CycleTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.history_count.as_ref() {
            struct_ser.serialize_field("HistoryCount", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DropContainerSingle {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Count",
            "CycleTime",
            "HistoryCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Count,
            CycleTime,
            HistoryCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Count" => Ok(GeneratedField::Count),
                            "CycleTime" => Ok(GeneratedField::CycleTime),
                            "HistoryCount" => Ok(GeneratedField::HistoryCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DropContainerSingle;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DropContainerSingle")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DropContainerSingle, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut count__ = None;
                let mut cycle_time__ = None;
                let mut history_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Count"));
                            }
                            count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CycleTime => {
                            if cycle_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CycleTime"));
                            }
                            cycle_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HistoryCount => {
                            if history_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HistoryCount"));
                            }
                            history_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DropContainerSingle {
                    id: id__,
                    count: count__,
                    cycle_time: cycle_time__,
                    history_count: history_count__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DropContainerSingle", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DroughtRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.trigger_time.is_some() {
            len += 1;
        }
        if self.segment_id.is_some() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        if self.actual_end_time.is_some() {
            len += 1;
        }
        if self.is_watered.is_some() {
            len += 1;
        }
        if self.is_expired.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DroughtRecord", len)?;
        if let Some(v) = self.trigger_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TriggerTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.segment_id.as_ref() {
            struct_ser.serialize_field("SegmentId", v)?;
        }
        if let Some(v) = self.duration.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Duration", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.actual_end_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ActualEndTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.is_watered.as_ref() {
            struct_ser.serialize_field("IsWatered", v)?;
        }
        if let Some(v) = self.is_expired.as_ref() {
            struct_ser.serialize_field("IsExpired", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DroughtRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TriggerTime",
            "SegmentId",
            "Duration",
            "ActualEndTime",
            "IsWatered",
            "IsExpired",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TriggerTime,
            SegmentId,
            Duration,
            ActualEndTime,
            IsWatered,
            IsExpired,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TriggerTime" => Ok(GeneratedField::TriggerTime),
                            "SegmentId" => Ok(GeneratedField::SegmentId),
                            "Duration" => Ok(GeneratedField::Duration),
                            "ActualEndTime" => Ok(GeneratedField::ActualEndTime),
                            "IsWatered" => Ok(GeneratedField::IsWatered),
                            "IsExpired" => Ok(GeneratedField::IsExpired),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DroughtRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DroughtRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DroughtRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut trigger_time__ = None;
                let mut segment_id__ = None;
                let mut duration__ = None;
                let mut actual_end_time__ = None;
                let mut is_watered__ = None;
                let mut is_expired__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TriggerTime => {
                            if trigger_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TriggerTime"));
                            }
                            trigger_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SegmentId => {
                            if segment_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SegmentId"));
                            }
                            segment_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ActualEndTime => {
                            if actual_end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActualEndTime"));
                            }
                            actual_end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsWatered => {
                            if is_watered__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsWatered"));
                            }
                            is_watered__ = map_.next_value()?;
                        }
                        GeneratedField::IsExpired => {
                            if is_expired__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsExpired"));
                            }
                            is_expired__ = map_.next_value()?;
                        }
                    }
                }
                Ok(DroughtRecord {
                    trigger_time: trigger_time__,
                    segment_id: segment_id__,
                    duration: duration__,
                    actual_end_time: actual_end_time__,
                    is_watered: is_watered__,
                    is_expired: is_expired__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DroughtRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonAffixData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.affix_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonAffixData", len)?;
        if !self.affix_data.is_empty() {
            struct_ser.serialize_field("AffixData", &self.affix_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonAffixData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AffixData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AffixData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AffixData" => Ok(GeneratedField::AffixData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonAffixData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonAffixData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonAffixData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut affix_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AffixData => {
                            if affix_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AffixData"));
                            }
                            affix_data__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(DungeonAffixData {
                    affix_data: affix_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonAffixData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonAward {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.items.is_empty() {
            len += 1;
        }
        if self.flag_assist.is_some() {
            len += 1;
        }
        if self.award_count.is_some() {
            len += 1;
        }
        if !self.first_items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonAward", len)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("Items", &self.items)?;
        }
        if let Some(v) = self.flag_assist.as_ref() {
            struct_ser.serialize_field("FlagAssist", v)?;
        }
        if let Some(v) = self.award_count.as_ref() {
            struct_ser.serialize_field("AwardCount", v)?;
        }
        if !self.first_items.is_empty() {
            struct_ser.serialize_field("FirstItems", &self.first_items.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonAward {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Items",
            "FlagAssist",
            "AwardCount",
            "FirstItems",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
            FlagAssist,
            AwardCount,
            FirstItems,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Items" => Ok(GeneratedField::Items),
                            "FlagAssist" => Ok(GeneratedField::FlagAssist),
                            "AwardCount" => Ok(GeneratedField::AwardCount),
                            "FirstItems" => Ok(GeneratedField::FirstItems),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonAward;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonAward")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonAward, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                let mut flag_assist__ = None;
                let mut award_count__ = None;
                let mut first_items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Items"));
                            }
                            items__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::FlagAssist => {
                            if flag_assist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FlagAssist"));
                            }
                            flag_assist__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AwardCount => {
                            if award_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardCount"));
                            }
                            award_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FirstItems => {
                            if first_items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FirstItems"));
                            }
                            first_items__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(DungeonAward {
                    items: items__.unwrap_or_default(),
                    flag_assist: flag_assist__,
                    award_count: award_count__,
                    first_items: first_items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonAward", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonBossRank {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.boss_rank.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonBossRank", len)?;
        if !self.boss_rank.is_empty() {
            struct_ser.serialize_field("BossRank", &self.boss_rank)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonBossRank {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BossRank",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BossRank,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BossRank" => Ok(GeneratedField::BossRank),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonBossRank;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonBossRank")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonBossRank, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut boss_rank__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BossRank => {
                            if boss_rank__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BossRank"));
                            }
                            boss_rank__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonBossRank {
                    boss_rank: boss_rank__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonBossRank", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonDamage {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.damages.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonDamage", len)?;
        if !self.damages.is_empty() {
            let v: std::collections::HashMap<_, _> = self.damages.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("Damages", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonDamage {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Damages",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Damages,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Damages" => Ok(GeneratedField::Damages),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonDamage;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonDamage")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonDamage, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut damages__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Damages => {
                            if damages__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Damages"));
                            }
                            damages__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonDamage {
                    damages: damages__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonDamage", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonEnterCount {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.enter_time.is_some() {
            len += 1;
        }
        if self.enter_count.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonEnterCount", len)?;
        if let Some(v) = self.enter_time.as_ref() {
            struct_ser.serialize_field("EnterTime", v)?;
        }
        if let Some(v) = self.enter_count.as_ref() {
            struct_ser.serialize_field("EnterCount", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonEnterCount {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EnterTime",
            "EnterCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EnterTime,
            EnterCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EnterTime" => Ok(GeneratedField::EnterTime),
                            "EnterCount" => Ok(GeneratedField::EnterCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonEnterCount;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonEnterCount")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonEnterCount, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut enter_time__ = None;
                let mut enter_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EnterTime => {
                            if enter_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnterTime"));
                            }
                            enter_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EnterCount => {
                            if enter_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnterCount"));
                            }
                            enter_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonEnterCount {
                    enter_time: enter_time__,
                    enter_count: enter_count__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonEnterCount", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonEnterLimit {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.enter_count.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonEnterLimit", len)?;
        if !self.enter_count.is_empty() {
            struct_ser.serialize_field("EnterCount", &self.enter_count)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonEnterLimit {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EnterCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EnterCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EnterCount" => Ok(GeneratedField::EnterCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonEnterLimit;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonEnterLimit")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonEnterLimit, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut enter_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EnterCount => {
                            if enter_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnterCount"));
                            }
                            enter_count__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonEnterLimit {
                    enter_count: enter_count__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonEnterLimit", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonEvent {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dungeon_event_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonEvent", len)?;
        if !self.dungeon_event_data.is_empty() {
            struct_ser.serialize_field("DungeonEventData", &self.dungeon_event_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonEvent {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonEventData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DungeonEventData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DungeonEventData" => Ok(GeneratedField::DungeonEventData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonEvent;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonEvent")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonEvent, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dungeon_event_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DungeonEventData => {
                            if dungeon_event_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonEventData"));
                            }
                            dungeon_event_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonEvent {
                    dungeon_event_data: dungeon_event_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonEvent", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonEventData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.event_id.is_some() {
            len += 1;
        }
        if self.start_time.is_some() {
            len += 1;
        }
        if self.state.is_some() {
            len += 1;
        }
        if self.result.is_some() {
            len += 1;
        }
        if !self.dungeon_target.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonEventData", len)?;
        if let Some(v) = self.event_id.as_ref() {
            struct_ser.serialize_field("EventId", v)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            struct_ser.serialize_field("StartTime", v)?;
        }
        if let Some(v) = self.state.as_ref() {
            let v = DungeonEventState::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("State", &v)?;
        }
        if let Some(v) = self.result.as_ref() {
            let v = DungeonEventResult::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Result", &v)?;
        }
        if !self.dungeon_target.is_empty() {
            struct_ser.serialize_field("DungeonTarget", &self.dungeon_target)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonEventData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EventId",
            "StartTime",
            "State",
            "Result",
            "DungeonTarget",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EventId,
            StartTime,
            State,
            Result,
            DungeonTarget,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EventId" => Ok(GeneratedField::EventId),
                            "StartTime" => Ok(GeneratedField::StartTime),
                            "State" => Ok(GeneratedField::State),
                            "Result" => Ok(GeneratedField::Result),
                            "DungeonTarget" => Ok(GeneratedField::DungeonTarget),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonEventData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonEventData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonEventData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut event_id__ = None;
                let mut start_time__ = None;
                let mut state__ = None;
                let mut result__ = None;
                let mut dungeon_target__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EventId => {
                            if event_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EventId"));
                            }
                            event_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StartTime => {
                            if start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StartTime"));
                            }
                            start_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("State"));
                            }
                            state__ = map_.next_value::<::std::option::Option<DungeonEventState>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Result => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Result"));
                            }
                            result__ = map_.next_value::<::std::option::Option<DungeonEventResult>>()?.map(|x| x as i32);
                        }
                        GeneratedField::DungeonTarget => {
                            if dungeon_target__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonTarget"));
                            }
                            dungeon_target__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonEventData {
                    event_id: event_id__,
                    start_time: start_time__,
                    state: state__,
                    result: result__,
                    dungeon_target: dungeon_target__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonEventData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonEventResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Null => "DungeonEventResultNull",
            Self::Success => "DungeonEventResultSuccess",
            Self::TimeOut => "DungeonEventResultTimeOut",
            Self::Failed => "DungeonEventResultFailed",
            Self::End => "DungeonEventResultEnd",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for DungeonEventResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonEventResultNull",
            "DungeonEventResultSuccess",
            "DungeonEventResultTimeOut",
            "DungeonEventResultFailed",
            "DungeonEventResultEnd",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonEventResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DungeonEventResultNull" => Ok(DungeonEventResult::Null),
                    "DungeonEventResultSuccess" => Ok(DungeonEventResult::Success),
                    "DungeonEventResultTimeOut" => Ok(DungeonEventResult::TimeOut),
                    "DungeonEventResultFailed" => Ok(DungeonEventResult::Failed),
                    "DungeonEventResultEnd" => Ok(DungeonEventResult::End),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonEventState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Null => "DungeonEventStateNull",
            Self::Running => "DungeonEventStateRunning",
            Self::End => "DungeonEventStateEnd",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for DungeonEventState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonEventStateNull",
            "DungeonEventStateRunning",
            "DungeonEventStateEnd",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonEventState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DungeonEventStateNull" => Ok(DungeonEventState::Null),
                    "DungeonEventStateRunning" => Ok(DungeonEventState::Running),
                    "DungeonEventStateEnd" => Ok(DungeonEventState::End),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonFlowInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.state.is_some() {
            len += 1;
        }
        if self.active_time.is_some() {
            len += 1;
        }
        if self.ready_time.is_some() {
            len += 1;
        }
        if self.play_time.is_some() {
            len += 1;
        }
        if self.end_time.is_some() {
            len += 1;
        }
        if self.settlement_time.is_some() {
            len += 1;
        }
        if self.dungeon_times.is_some() {
            len += 1;
        }
        if self.result.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonFlowInfo", len)?;
        if let Some(v) = self.state.as_ref() {
            let v = EDungeonState::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("State", &v)?;
        }
        if let Some(v) = self.active_time.as_ref() {
            struct_ser.serialize_field("ActiveTime", v)?;
        }
        if let Some(v) = self.ready_time.as_ref() {
            struct_ser.serialize_field("ReadyTime", v)?;
        }
        if let Some(v) = self.play_time.as_ref() {
            struct_ser.serialize_field("PlayTime", v)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            struct_ser.serialize_field("EndTime", v)?;
        }
        if let Some(v) = self.settlement_time.as_ref() {
            struct_ser.serialize_field("SettlementTime", v)?;
        }
        if let Some(v) = self.dungeon_times.as_ref() {
            struct_ser.serialize_field("DungeonTimes", v)?;
        }
        if let Some(v) = self.result.as_ref() {
            struct_ser.serialize_field("Result", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonFlowInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "State",
            "ActiveTime",
            "ReadyTime",
            "PlayTime",
            "EndTime",
            "SettlementTime",
            "DungeonTimes",
            "Result",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
            ActiveTime,
            ReadyTime,
            PlayTime,
            EndTime,
            SettlementTime,
            DungeonTimes,
            Result,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "State" => Ok(GeneratedField::State),
                            "ActiveTime" => Ok(GeneratedField::ActiveTime),
                            "ReadyTime" => Ok(GeneratedField::ReadyTime),
                            "PlayTime" => Ok(GeneratedField::PlayTime),
                            "EndTime" => Ok(GeneratedField::EndTime),
                            "SettlementTime" => Ok(GeneratedField::SettlementTime),
                            "DungeonTimes" => Ok(GeneratedField::DungeonTimes),
                            "Result" => Ok(GeneratedField::Result),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonFlowInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonFlowInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonFlowInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                let mut active_time__ = None;
                let mut ready_time__ = None;
                let mut play_time__ = None;
                let mut end_time__ = None;
                let mut settlement_time__ = None;
                let mut dungeon_times__ = None;
                let mut result__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("State"));
                            }
                            state__ = map_.next_value::<::std::option::Option<EDungeonState>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ActiveTime => {
                            if active_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActiveTime"));
                            }
                            active_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReadyTime => {
                            if ready_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReadyTime"));
                            }
                            ready_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PlayTime => {
                            if play_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayTime"));
                            }
                            play_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EndTime"));
                            }
                            end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SettlementTime => {
                            if settlement_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SettlementTime"));
                            }
                            settlement_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DungeonTimes => {
                            if dungeon_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonTimes"));
                            }
                            dungeon_times__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Result => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Result"));
                            }
                            result__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonFlowInfo {
                    state: state__,
                    active_time: active_time__,
                    ready_time: ready_time__,
                    play_time: play_time__,
                    end_time: end_time__,
                    settlement_time: settlement_time__,
                    dungeon_times: dungeon_times__,
                    result: result__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonFlowInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonHeroKeyInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.char_id.is_some() {
            len += 1;
        }
        if !self.hero_key_item.is_empty() {
            len += 1;
        }
        if !self.key_info.is_empty() {
            len += 1;
        }
        if self.use_item.is_some() {
            len += 1;
        }
        if !self.hero_key_award_item.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonHeroKeyInfo", len)?;
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if !self.hero_key_item.is_empty() {
            struct_ser.serialize_field("HeroKeyItem", &self.hero_key_item)?;
        }
        if !self.key_info.is_empty() {
            struct_ser.serialize_field("KeyInfo", &self.key_info)?;
        }
        if let Some(v) = self.use_item.as_ref() {
            struct_ser.serialize_field("UseItem", v)?;
        }
        if !self.hero_key_award_item.is_empty() {
            struct_ser.serialize_field("HeroKeyAwardItem", &self.hero_key_award_item)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonHeroKeyInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CharId",
            "HeroKeyItem",
            "KeyInfo",
            "UseItem",
            "HeroKeyAwardItem",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CharId,
            HeroKeyItem,
            KeyInfo,
            UseItem,
            HeroKeyAwardItem,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CharId" => Ok(GeneratedField::CharId),
                            "HeroKeyItem" => Ok(GeneratedField::HeroKeyItem),
                            "KeyInfo" => Ok(GeneratedField::KeyInfo),
                            "UseItem" => Ok(GeneratedField::UseItem),
                            "HeroKeyAwardItem" => Ok(GeneratedField::HeroKeyAwardItem),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonHeroKeyInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonHeroKeyInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonHeroKeyInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut char_id__ = None;
                let mut hero_key_item__ = None;
                let mut key_info__ = None;
                let mut use_item__ = None;
                let mut hero_key_award_item__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HeroKeyItem => {
                            if hero_key_item__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HeroKeyItem"));
                            }
                            hero_key_item__ = Some(map_.next_value()?);
                        }
                        GeneratedField::KeyInfo => {
                            if key_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("KeyInfo"));
                            }
                            key_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::UseItem => {
                            if use_item__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UseItem"));
                            }
                            use_item__ = map_.next_value()?;
                        }
                        GeneratedField::HeroKeyAwardItem => {
                            if hero_key_award_item__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HeroKeyAwardItem"));
                            }
                            hero_key_award_item__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DungeonHeroKeyInfo {
                    char_id: char_id__,
                    hero_key_item: hero_key_item__.unwrap_or_default(),
                    key_info: key_info__.unwrap_or_default(),
                    use_item: use_item__,
                    hero_key_award_item: hero_key_award_item__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonHeroKeyInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.dungeon_id.is_some() {
            len += 1;
        }
        if self.complete_count.is_some() {
            len += 1;
        }
        if self.award_flg.is_some() {
            len += 1;
        }
        if self.score.is_some() {
            len += 1;
        }
        if self.pass_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonInfo", len)?;
        if let Some(v) = self.dungeon_id.as_ref() {
            struct_ser.serialize_field("DungeonID", v)?;
        }
        if let Some(v) = self.complete_count.as_ref() {
            struct_ser.serialize_field("CompleteCount", v)?;
        }
        if let Some(v) = self.award_flg.as_ref() {
            struct_ser.serialize_field("AwardFlg", v)?;
        }
        if let Some(v) = self.score.as_ref() {
            struct_ser.serialize_field("Score", v)?;
        }
        if let Some(v) = self.pass_time.as_ref() {
            struct_ser.serialize_field("PassTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonID",
            "CompleteCount",
            "AwardFlg",
            "Score",
            "PassTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DungeonId,
            CompleteCount,
            AwardFlg,
            Score,
            PassTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DungeonID" => Ok(GeneratedField::DungeonId),
                            "CompleteCount" => Ok(GeneratedField::CompleteCount),
                            "AwardFlg" => Ok(GeneratedField::AwardFlg),
                            "Score" => Ok(GeneratedField::Score),
                            "PassTime" => Ok(GeneratedField::PassTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dungeon_id__ = None;
                let mut complete_count__ = None;
                let mut award_flg__ = None;
                let mut score__ = None;
                let mut pass_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DungeonId => {
                            if dungeon_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonID"));
                            }
                            dungeon_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CompleteCount => {
                            if complete_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CompleteCount"));
                            }
                            complete_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AwardFlg => {
                            if award_flg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardFlg"));
                            }
                            award_flg__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Score => {
                            if score__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Score"));
                            }
                            score__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PassTime => {
                            if pass_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PassTime"));
                            }
                            pass_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonInfo {
                    dungeon_id: dungeon_id__,
                    complete_count: complete_count__,
                    award_flg: award_flg__,
                    score: score__,
                    pass_time: pass_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.complete_dungeon.is_empty() {
            len += 1;
        }
        if self.reset_time.is_some() {
            len += 1;
        }
        if self.normal_dungeon_pass_count.is_some() {
            len += 1;
        }
        if self.dungeon_enter_limit.is_some() {
            len += 1;
        }
        if self.week_target.is_some() {
            len += 1;
        }
        if self.is_assist.is_some() {
            len += 1;
        }
        if !self.raid_record_table.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonList", len)?;
        if !self.complete_dungeon.is_empty() {
            struct_ser.serialize_field("CompleteDungeon", &self.complete_dungeon)?;
        }
        if let Some(v) = self.reset_time.as_ref() {
            struct_ser.serialize_field("ResetTime", v)?;
        }
        if let Some(v) = self.normal_dungeon_pass_count.as_ref() {
            struct_ser.serialize_field("NormalDungeonPassCount", v)?;
        }
        if let Some(v) = self.dungeon_enter_limit.as_ref() {
            struct_ser.serialize_field("DungeonEnterLimit", v)?;
        }
        if let Some(v) = self.week_target.as_ref() {
            struct_ser.serialize_field("WeekTarget", v)?;
        }
        if let Some(v) = self.is_assist.as_ref() {
            struct_ser.serialize_field("IsAssist", v)?;
        }
        if !self.raid_record_table.is_empty() {
            struct_ser.serialize_field("RaidRecordTable", &self.raid_record_table)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CompleteDungeon",
            "ResetTime",
            "NormalDungeonPassCount",
            "DungeonEnterLimit",
            "WeekTarget",
            "IsAssist",
            "RaidRecordTable",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CompleteDungeon,
            ResetTime,
            NormalDungeonPassCount,
            DungeonEnterLimit,
            WeekTarget,
            IsAssist,
            RaidRecordTable,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CompleteDungeon" => Ok(GeneratedField::CompleteDungeon),
                            "ResetTime" => Ok(GeneratedField::ResetTime),
                            "NormalDungeonPassCount" => Ok(GeneratedField::NormalDungeonPassCount),
                            "DungeonEnterLimit" => Ok(GeneratedField::DungeonEnterLimit),
                            "WeekTarget" => Ok(GeneratedField::WeekTarget),
                            "IsAssist" => Ok(GeneratedField::IsAssist),
                            "RaidRecordTable" => Ok(GeneratedField::RaidRecordTable),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut complete_dungeon__ = None;
                let mut reset_time__ = None;
                let mut normal_dungeon_pass_count__ = None;
                let mut dungeon_enter_limit__ = None;
                let mut week_target__ = None;
                let mut is_assist__ = None;
                let mut raid_record_table__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CompleteDungeon => {
                            if complete_dungeon__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CompleteDungeon"));
                            }
                            complete_dungeon__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::ResetTime => {
                            if reset_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ResetTime"));
                            }
                            reset_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NormalDungeonPassCount => {
                            if normal_dungeon_pass_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NormalDungeonPassCount"));
                            }
                            normal_dungeon_pass_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DungeonEnterLimit => {
                            if dungeon_enter_limit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonEnterLimit"));
                            }
                            dungeon_enter_limit__ = map_.next_value()?;
                        }
                        GeneratedField::WeekTarget => {
                            if week_target__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WeekTarget"));
                            }
                            week_target__ = map_.next_value()?;
                        }
                        GeneratedField::IsAssist => {
                            if is_assist__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsAssist"));
                            }
                            is_assist__ = map_.next_value()?;
                        }
                        GeneratedField::RaidRecordTable => {
                            if raid_record_table__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RaidRecordTable"));
                            }
                            raid_record_table__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonList {
                    complete_dungeon: complete_dungeon__.unwrap_or_default(),
                    reset_time: reset_time__,
                    normal_dungeon_pass_count: normal_dungeon_pass_count__,
                    dungeon_enter_limit: dungeon_enter_limit__,
                    week_target: week_target__,
                    is_assist: is_assist__,
                    raid_record_table: raid_record_table__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonPioneer {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.completed_target_this_time.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonPioneer", len)?;
        if !self.completed_target_this_time.is_empty() {
            struct_ser.serialize_field("CompletedTargetThisTime", &self.completed_target_this_time)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonPioneer {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CompletedTargetThisTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CompletedTargetThisTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CompletedTargetThisTime" => Ok(GeneratedField::CompletedTargetThisTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonPioneer;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonPioneer")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonPioneer, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut completed_target_this_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CompletedTargetThisTime => {
                            if completed_target_this_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CompletedTargetThisTime"));
                            }
                            completed_target_this_time__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonPioneer {
                    completed_target_this_time: completed_target_this_time__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonPioneer", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonPlanetMemoryRoom {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.room_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonPlanetMemoryRoom", len)?;
        if let Some(v) = self.room_id.as_ref() {
            struct_ser.serialize_field("RoomId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonPlanetMemoryRoom {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RoomId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RoomId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RoomId" => Ok(GeneratedField::RoomId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonPlanetMemoryRoom;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonPlanetMemoryRoom")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonPlanetMemoryRoom, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut room_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RoomId => {
                            if room_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RoomId"));
                            }
                            room_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonPlanetMemoryRoom {
                    room_id: room_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonPlanetMemoryRoom", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonPlayerInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.char_id.is_some() {
            len += 1;
        }
        if self.social_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonPlayerInfo", len)?;
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.social_data.as_ref() {
            struct_ser.serialize_field("SocialData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonPlayerInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CharId",
            "SocialData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CharId,
            SocialData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CharId" => Ok(GeneratedField::CharId),
                            "SocialData" => Ok(GeneratedField::SocialData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonPlayerInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonPlayerInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonPlayerInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut char_id__ = None;
                let mut social_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SocialData => {
                            if social_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SocialData"));
                            }
                            social_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(DungeonPlayerInfo {
                    char_id: char_id__,
                    social_data: social_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonPlayerInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonPlayerList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.player_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonPlayerList", len)?;
        if !self.player_infos.is_empty() {
            struct_ser.serialize_field("PlayerInfos", &self.player_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonPlayerList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PlayerInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PlayerInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PlayerInfos" => Ok(GeneratedField::PlayerInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonPlayerList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonPlayerList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonPlayerList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut player_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PlayerInfos => {
                            if player_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayerInfos"));
                            }
                            player_infos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonPlayerList {
                    player_infos: player_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonPlayerList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonRaidInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonRaidInfo", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonRaidInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonRaidInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonRaidInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonRaidInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(DungeonRaidInfo {
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonRaidInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonRandomEntityConfigIdInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.random_entity_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonRandomEntityConfigIdInfo", len)?;
        if !self.random_entity_map.is_empty() {
            struct_ser.serialize_field("RandomEntityMap", &self.random_entity_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonRandomEntityConfigIdInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RandomEntityMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RandomEntityMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RandomEntityMap" => Ok(GeneratedField::RandomEntityMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonRandomEntityConfigIdInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonRandomEntityConfigIdInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonRandomEntityConfigIdInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut random_entity_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RandomEntityMap => {
                            if random_entity_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RandomEntityMap"));
                            }
                            random_entity_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonRandomEntityConfigIdInfo {
                    random_entity_map: random_entity_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonRandomEntityConfigIdInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonRankInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.num.is_some() {
            len += 1;
        }
        if self.rank.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonRankInfo", len)?;
        if let Some(v) = self.num.as_ref() {
            struct_ser.serialize_field("Num", v)?;
        }
        if let Some(v) = self.rank.as_ref() {
            struct_ser.serialize_field("Rank", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonRankInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Num",
            "Rank",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Num,
            Rank,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Num" => Ok(GeneratedField::Num),
                            "Rank" => Ok(GeneratedField::Rank),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonRankInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonRankInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonRankInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut num__ = None;
                let mut rank__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Num => {
                            if num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Num"));
                            }
                            num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Rank => {
                            if rank__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Rank"));
                            }
                            rank__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonRankInfo {
                    num: num__,
                    rank: rank__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonRankInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonRankList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dungeon_rank_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonRankList", len)?;
        if !self.dungeon_rank_map.is_empty() {
            struct_ser.serialize_field("DungeonRankMap", &self.dungeon_rank_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonRankList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonRankMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DungeonRankMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DungeonRankMap" => Ok(GeneratedField::DungeonRankMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonRankList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonRankList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonRankList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dungeon_rank_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DungeonRankMap => {
                            if dungeon_rank_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonRankMap"));
                            }
                            dungeon_rank_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonRankList {
                    dungeon_rank_map: dungeon_rank_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonRankList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonReviveInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.revive_ids.is_empty() {
            len += 1;
        }
        if !self.revive_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonReviveInfo", len)?;
        if !self.revive_ids.is_empty() {
            struct_ser.serialize_field("ReviveIds", &self.revive_ids)?;
        }
        if !self.revive_map.is_empty() {
            struct_ser.serialize_field("ReviveMap", &self.revive_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonReviveInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ReviveIds",
            "ReviveMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ReviveIds,
            ReviveMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ReviveIds" => Ok(GeneratedField::ReviveIds),
                            "ReviveMap" => Ok(GeneratedField::ReviveMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonReviveInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonReviveInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonReviveInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut revive_ids__ = None;
                let mut revive_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ReviveIds => {
                            if revive_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReviveIds"));
                            }
                            revive_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::ReviveMap => {
                            if revive_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReviveMap"));
                            }
                            revive_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonReviveInfo {
                    revive_ids: revive_ids__.unwrap_or_default(),
                    revive_map: revive_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonReviveInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonSceneInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.difficulty.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonSceneInfo", len)?;
        if let Some(v) = self.difficulty.as_ref() {
            struct_ser.serialize_field("Difficulty", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonSceneInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Difficulty",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Difficulty,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Difficulty" => Ok(GeneratedField::Difficulty),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonSceneInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonSceneInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonSceneInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut difficulty__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Difficulty => {
                            if difficulty__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Difficulty"));
                            }
                            difficulty__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonSceneInfo {
                    difficulty: difficulty__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonSceneInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonScore {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.total_score.is_some() {
            len += 1;
        }
        if self.cur_ratio.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonScore", len)?;
        if let Some(v) = self.total_score.as_ref() {
            struct_ser.serialize_field("TotalScore", v)?;
        }
        if let Some(v) = self.cur_ratio.as_ref() {
            struct_ser.serialize_field("CurRatio", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonScore {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TotalScore",
            "CurRatio",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TotalScore,
            CurRatio,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TotalScore" => Ok(GeneratedField::TotalScore),
                            "CurRatio" => Ok(GeneratedField::CurRatio),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonScore;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonScore")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonScore, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut total_score__ = None;
                let mut cur_ratio__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TotalScore => {
                            if total_score__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TotalScore"));
                            }
                            total_score__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurRatio => {
                            if cur_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurRatio"));
                            }
                            cur_ratio__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonScore {
                    total_score: total_score__,
                    cur_ratio: cur_ratio__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonScore", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonSettlement {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.pass_time.is_some() {
            len += 1;
        }
        if !self.award.is_empty() {
            len += 1;
        }
        if !self.settlement_pos.is_empty() {
            len += 1;
        }
        if self.world_boss_settlement.is_some() {
            len += 1;
        }
        if self.master_mode_score.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonSettlement", len)?;
        if let Some(v) = self.pass_time.as_ref() {
            struct_ser.serialize_field("PassTime", v)?;
        }
        if !self.award.is_empty() {
            struct_ser.serialize_field("Award", &self.award)?;
        }
        if !self.settlement_pos.is_empty() {
            struct_ser.serialize_field("SettlementPos", &self.settlement_pos)?;
        }
        if let Some(v) = self.world_boss_settlement.as_ref() {
            struct_ser.serialize_field("WorldBossSettlement", v)?;
        }
        if let Some(v) = self.master_mode_score.as_ref() {
            struct_ser.serialize_field("MasterModeScore", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonSettlement {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PassTime",
            "Award",
            "SettlementPos",
            "WorldBossSettlement",
            "MasterModeScore",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PassTime,
            Award,
            SettlementPos,
            WorldBossSettlement,
            MasterModeScore,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PassTime" => Ok(GeneratedField::PassTime),
                            "Award" => Ok(GeneratedField::Award),
                            "SettlementPos" => Ok(GeneratedField::SettlementPos),
                            "WorldBossSettlement" => Ok(GeneratedField::WorldBossSettlement),
                            "MasterModeScore" => Ok(GeneratedField::MasterModeScore),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonSettlement;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonSettlement")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonSettlement, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pass_time__ = None;
                let mut award__ = None;
                let mut settlement_pos__ = None;
                let mut world_boss_settlement__ = None;
                let mut master_mode_score__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PassTime => {
                            if pass_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PassTime"));
                            }
                            pass_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Award => {
                            if award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Award"));
                            }
                            award__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::SettlementPos => {
                            if settlement_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SettlementPos"));
                            }
                            settlement_pos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::WorldBossSettlement => {
                            if world_boss_settlement__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WorldBossSettlement"));
                            }
                            world_boss_settlement__ = map_.next_value()?;
                        }
                        GeneratedField::MasterModeScore => {
                            if master_mode_score__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MasterModeScore"));
                            }
                            master_mode_score__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonSettlement {
                    pass_time: pass_time__,
                    award: award__.unwrap_or_default(),
                    settlement_pos: settlement_pos__.unwrap_or_default(),
                    world_boss_settlement: world_boss_settlement__,
                    master_mode_score: master_mode_score__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonSettlement", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonSyncData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scene_uuid.is_some() {
            len += 1;
        }
        if self.flow_info.is_some() {
            len += 1;
        }
        if self.title.is_some() {
            len += 1;
        }
        if self.target.is_some() {
            len += 1;
        }
        if self.damage.is_some() {
            len += 1;
        }
        if self.vote.is_some() {
            len += 1;
        }
        if self.settlement.is_some() {
            len += 1;
        }
        if self.dungeon_pioneer.is_some() {
            len += 1;
        }
        if self.planet_room_info.is_some() {
            len += 1;
        }
        if self.dungeon_var.is_some() {
            len += 1;
        }
        if self.dungeon_rank.is_some() {
            len += 1;
        }
        if self.dungeon_affix_data.is_some() {
            len += 1;
        }
        if self.dungeon_event.is_some() {
            len += 1;
        }
        if self.dungeon_score.is_some() {
            len += 1;
        }
        if self.timer_info.is_some() {
            len += 1;
        }
        if self.hero_key.is_some() {
            len += 1;
        }
        if self.dungeon_union_info.is_some() {
            len += 1;
        }
        if self.dungeon_player_list.is_some() {
            len += 1;
        }
        if self.revive_info.is_some() {
            len += 1;
        }
        if self.random_entity_config_id_info.is_some() {
            len += 1;
        }
        if self.dungeon_scene_info.is_some() {
            len += 1;
        }
        if self.dungeon_var_all.is_some() {
            len += 1;
        }
        if self.dungeon_raid_info.is_some() {
            len += 1;
        }
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonSyncData", len)?;
        if let Some(v) = self.scene_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SceneUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.flow_info.as_ref() {
            struct_ser.serialize_field("FlowInfo", v)?;
        }
        if let Some(v) = self.title.as_ref() {
            struct_ser.serialize_field("Title", v)?;
        }
        if let Some(v) = self.target.as_ref() {
            struct_ser.serialize_field("Target", v)?;
        }
        if let Some(v) = self.damage.as_ref() {
            struct_ser.serialize_field("Damage", v)?;
        }
        if let Some(v) = self.vote.as_ref() {
            struct_ser.serialize_field("Vote", v)?;
        }
        if let Some(v) = self.settlement.as_ref() {
            struct_ser.serialize_field("Settlement", v)?;
        }
        if let Some(v) = self.dungeon_pioneer.as_ref() {
            struct_ser.serialize_field("DungeonPioneer", v)?;
        }
        if let Some(v) = self.planet_room_info.as_ref() {
            struct_ser.serialize_field("PlanetRoomInfo", v)?;
        }
        if let Some(v) = self.dungeon_var.as_ref() {
            struct_ser.serialize_field("DungeonVar", v)?;
        }
        if let Some(v) = self.dungeon_rank.as_ref() {
            struct_ser.serialize_field("DungeonRank", v)?;
        }
        if let Some(v) = self.dungeon_affix_data.as_ref() {
            struct_ser.serialize_field("DungeonAffixData", v)?;
        }
        if let Some(v) = self.dungeon_event.as_ref() {
            struct_ser.serialize_field("DungeonEvent", v)?;
        }
        if let Some(v) = self.dungeon_score.as_ref() {
            struct_ser.serialize_field("DungeonScore", v)?;
        }
        if let Some(v) = self.timer_info.as_ref() {
            struct_ser.serialize_field("TimerInfo", v)?;
        }
        if let Some(v) = self.hero_key.as_ref() {
            struct_ser.serialize_field("HeroKey", v)?;
        }
        if let Some(v) = self.dungeon_union_info.as_ref() {
            struct_ser.serialize_field("DungeonUnionInfo", v)?;
        }
        if let Some(v) = self.dungeon_player_list.as_ref() {
            struct_ser.serialize_field("DungeonPlayerList", v)?;
        }
        if let Some(v) = self.revive_info.as_ref() {
            struct_ser.serialize_field("ReviveInfo", v)?;
        }
        if let Some(v) = self.random_entity_config_id_info.as_ref() {
            struct_ser.serialize_field("RandomEntityConfigIdInfo", v)?;
        }
        if let Some(v) = self.dungeon_scene_info.as_ref() {
            struct_ser.serialize_field("DungeonSceneInfo", v)?;
        }
        if let Some(v) = self.dungeon_var_all.as_ref() {
            struct_ser.serialize_field("DungeonVarAll", v)?;
        }
        if let Some(v) = self.dungeon_raid_info.as_ref() {
            struct_ser.serialize_field("DungeonRaidInfo", v)?;
        }
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonSyncData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SceneUuid",
            "FlowInfo",
            "Title",
            "Target",
            "Damage",
            "Vote",
            "Settlement",
            "DungeonPioneer",
            "PlanetRoomInfo",
            "DungeonVar",
            "DungeonRank",
            "DungeonAffixData",
            "DungeonEvent",
            "DungeonScore",
            "TimerInfo",
            "HeroKey",
            "DungeonUnionInfo",
            "DungeonPlayerList",
            "ReviveInfo",
            "RandomEntityConfigIdInfo",
            "DungeonSceneInfo",
            "DungeonVarAll",
            "DungeonRaidInfo",
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SceneUuid,
            FlowInfo,
            Title,
            Target,
            Damage,
            Vote,
            Settlement,
            DungeonPioneer,
            PlanetRoomInfo,
            DungeonVar,
            DungeonRank,
            DungeonAffixData,
            DungeonEvent,
            DungeonScore,
            TimerInfo,
            HeroKey,
            DungeonUnionInfo,
            DungeonPlayerList,
            ReviveInfo,
            RandomEntityConfigIdInfo,
            DungeonSceneInfo,
            DungeonVarAll,
            DungeonRaidInfo,
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SceneUuid" => Ok(GeneratedField::SceneUuid),
                            "FlowInfo" => Ok(GeneratedField::FlowInfo),
                            "Title" => Ok(GeneratedField::Title),
                            "Target" => Ok(GeneratedField::Target),
                            "Damage" => Ok(GeneratedField::Damage),
                            "Vote" => Ok(GeneratedField::Vote),
                            "Settlement" => Ok(GeneratedField::Settlement),
                            "DungeonPioneer" => Ok(GeneratedField::DungeonPioneer),
                            "PlanetRoomInfo" => Ok(GeneratedField::PlanetRoomInfo),
                            "DungeonVar" => Ok(GeneratedField::DungeonVar),
                            "DungeonRank" => Ok(GeneratedField::DungeonRank),
                            "DungeonAffixData" => Ok(GeneratedField::DungeonAffixData),
                            "DungeonEvent" => Ok(GeneratedField::DungeonEvent),
                            "DungeonScore" => Ok(GeneratedField::DungeonScore),
                            "TimerInfo" => Ok(GeneratedField::TimerInfo),
                            "HeroKey" => Ok(GeneratedField::HeroKey),
                            "DungeonUnionInfo" => Ok(GeneratedField::DungeonUnionInfo),
                            "DungeonPlayerList" => Ok(GeneratedField::DungeonPlayerList),
                            "ReviveInfo" => Ok(GeneratedField::ReviveInfo),
                            "RandomEntityConfigIdInfo" => Ok(GeneratedField::RandomEntityConfigIdInfo),
                            "DungeonSceneInfo" => Ok(GeneratedField::DungeonSceneInfo),
                            "DungeonVarAll" => Ok(GeneratedField::DungeonVarAll),
                            "DungeonRaidInfo" => Ok(GeneratedField::DungeonRaidInfo),
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonSyncData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonSyncData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonSyncData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_uuid__ = None;
                let mut flow_info__ = None;
                let mut title__ = None;
                let mut target__ = None;
                let mut damage__ = None;
                let mut vote__ = None;
                let mut settlement__ = None;
                let mut dungeon_pioneer__ = None;
                let mut planet_room_info__ = None;
                let mut dungeon_var__ = None;
                let mut dungeon_rank__ = None;
                let mut dungeon_affix_data__ = None;
                let mut dungeon_event__ = None;
                let mut dungeon_score__ = None;
                let mut timer_info__ = None;
                let mut hero_key__ = None;
                let mut dungeon_union_info__ = None;
                let mut dungeon_player_list__ = None;
                let mut revive_info__ = None;
                let mut random_entity_config_id_info__ = None;
                let mut dungeon_scene_info__ = None;
                let mut dungeon_var_all__ = None;
                let mut dungeon_raid_info__ = None;
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SceneUuid => {
                            if scene_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneUuid"));
                            }
                            scene_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FlowInfo => {
                            if flow_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FlowInfo"));
                            }
                            flow_info__ = map_.next_value()?;
                        }
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Title"));
                            }
                            title__ = map_.next_value()?;
                        }
                        GeneratedField::Target => {
                            if target__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Target"));
                            }
                            target__ = map_.next_value()?;
                        }
                        GeneratedField::Damage => {
                            if damage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Damage"));
                            }
                            damage__ = map_.next_value()?;
                        }
                        GeneratedField::Vote => {
                            if vote__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Vote"));
                            }
                            vote__ = map_.next_value()?;
                        }
                        GeneratedField::Settlement => {
                            if settlement__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Settlement"));
                            }
                            settlement__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonPioneer => {
                            if dungeon_pioneer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonPioneer"));
                            }
                            dungeon_pioneer__ = map_.next_value()?;
                        }
                        GeneratedField::PlanetRoomInfo => {
                            if planet_room_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlanetRoomInfo"));
                            }
                            planet_room_info__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonVar => {
                            if dungeon_var__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonVar"));
                            }
                            dungeon_var__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonRank => {
                            if dungeon_rank__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonRank"));
                            }
                            dungeon_rank__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonAffixData => {
                            if dungeon_affix_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonAffixData"));
                            }
                            dungeon_affix_data__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonEvent => {
                            if dungeon_event__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonEvent"));
                            }
                            dungeon_event__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonScore => {
                            if dungeon_score__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonScore"));
                            }
                            dungeon_score__ = map_.next_value()?;
                        }
                        GeneratedField::TimerInfo => {
                            if timer_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TimerInfo"));
                            }
                            timer_info__ = map_.next_value()?;
                        }
                        GeneratedField::HeroKey => {
                            if hero_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HeroKey"));
                            }
                            hero_key__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonUnionInfo => {
                            if dungeon_union_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonUnionInfo"));
                            }
                            dungeon_union_info__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonPlayerList => {
                            if dungeon_player_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonPlayerList"));
                            }
                            dungeon_player_list__ = map_.next_value()?;
                        }
                        GeneratedField::ReviveInfo => {
                            if revive_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReviveInfo"));
                            }
                            revive_info__ = map_.next_value()?;
                        }
                        GeneratedField::RandomEntityConfigIdInfo => {
                            if random_entity_config_id_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RandomEntityConfigIdInfo"));
                            }
                            random_entity_config_id_info__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonSceneInfo => {
                            if dungeon_scene_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonSceneInfo"));
                            }
                            dungeon_scene_info__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonVarAll => {
                            if dungeon_var_all__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonVarAll"));
                            }
                            dungeon_var_all__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonRaidInfo => {
                            if dungeon_raid_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonRaidInfo"));
                            }
                            dungeon_raid_info__ = map_.next_value()?;
                        }
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(DungeonSyncData {
                    scene_uuid: scene_uuid__,
                    flow_info: flow_info__,
                    title: title__,
                    target: target__,
                    damage: damage__,
                    vote: vote__,
                    settlement: settlement__,
                    dungeon_pioneer: dungeon_pioneer__,
                    planet_room_info: planet_room_info__,
                    dungeon_var: dungeon_var__,
                    dungeon_rank: dungeon_rank__,
                    dungeon_affix_data: dungeon_affix_data__,
                    dungeon_event: dungeon_event__,
                    dungeon_score: dungeon_score__,
                    timer_info: timer_info__,
                    hero_key: hero_key__,
                    dungeon_union_info: dungeon_union_info__,
                    dungeon_player_list: dungeon_player_list__,
                    revive_info: revive_info__,
                    random_entity_config_id_info: random_entity_config_id_info__,
                    dungeon_scene_info: dungeon_scene_info__,
                    dungeon_var_all: dungeon_var_all__,
                    dungeon_raid_info: dungeon_raid_info__,
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonSyncData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonTarget {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.target_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonTarget", len)?;
        if !self.target_data.is_empty() {
            struct_ser.serialize_field("TargetData", &self.target_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonTarget {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetData" => Ok(GeneratedField::TargetData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonTarget;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonTarget")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonTarget, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetData => {
                            if target_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetData"));
                            }
                            target_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonTarget {
                    target_data: target_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonTarget", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonTargetAward {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dungeon_target_progress.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonTargetAward", len)?;
        if !self.dungeon_target_progress.is_empty() {
            struct_ser.serialize_field("DungeonTargetProgress", &self.dungeon_target_progress)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonTargetAward {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonTargetProgress",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DungeonTargetProgress,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DungeonTargetProgress" => Ok(GeneratedField::DungeonTargetProgress),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonTargetAward;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonTargetAward")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonTargetAward, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dungeon_target_progress__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DungeonTargetProgress => {
                            if dungeon_target_progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonTargetProgress"));
                            }
                            dungeon_target_progress__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonTargetAward {
                    dungeon_target_progress: dungeon_target_progress__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonTargetAward", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonTargetData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target_id.is_some() {
            len += 1;
        }
        if self.nums.is_some() {
            len += 1;
        }
        if self.complete.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonTargetData", len)?;
        if let Some(v) = self.target_id.as_ref() {
            struct_ser.serialize_field("TargetId", v)?;
        }
        if let Some(v) = self.nums.as_ref() {
            struct_ser.serialize_field("Nums", v)?;
        }
        if let Some(v) = self.complete.as_ref() {
            struct_ser.serialize_field("Complete", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonTargetData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetId",
            "Nums",
            "Complete",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetId,
            Nums,
            Complete,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetId" => Ok(GeneratedField::TargetId),
                            "Nums" => Ok(GeneratedField::Nums),
                            "Complete" => Ok(GeneratedField::Complete),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonTargetData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonTargetData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonTargetData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_id__ = None;
                let mut nums__ = None;
                let mut complete__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetId => {
                            if target_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetId"));
                            }
                            target_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Nums => {
                            if nums__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Nums"));
                            }
                            nums__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Complete => {
                            if complete__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Complete"));
                            }
                            complete__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonTargetData {
                    target_id: target_id__,
                    nums: nums__,
                    complete: complete__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonTargetData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonTargetProgress {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target_id.is_some() {
            len += 1;
        }
        if self.target_progress.is_some() {
            len += 1;
        }
        if self.award_state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonTargetProgress", len)?;
        if let Some(v) = self.target_id.as_ref() {
            struct_ser.serialize_field("TargetId", v)?;
        }
        if let Some(v) = self.target_progress.as_ref() {
            struct_ser.serialize_field("TargetProgress", v)?;
        }
        if let Some(v) = self.award_state.as_ref() {
            struct_ser.serialize_field("AwardState", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonTargetProgress {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetId",
            "TargetProgress",
            "AwardState",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetId,
            TargetProgress,
            AwardState,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetId" => Ok(GeneratedField::TargetId),
                            "TargetProgress" => Ok(GeneratedField::TargetProgress),
                            "AwardState" => Ok(GeneratedField::AwardState),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonTargetProgress;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonTargetProgress")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonTargetProgress, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_id__ = None;
                let mut target_progress__ = None;
                let mut award_state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetId => {
                            if target_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetId"));
                            }
                            target_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetProgress => {
                            if target_progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetProgress"));
                            }
                            target_progress__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AwardState => {
                            if award_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardState"));
                            }
                            award_state__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonTargetProgress {
                    target_id: target_id__,
                    target_progress: target_progress__,
                    award_state: award_state__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonTargetProgress", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonTimerInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.start_time.is_some() {
            len += 1;
        }
        if self.dungeon_times.is_some() {
            len += 1;
        }
        if self.direction.is_some() {
            len += 1;
        }
        if self.index.is_some() {
            len += 1;
        }
        if self.change_time.is_some() {
            len += 1;
        }
        if self.effect_type.is_some() {
            len += 1;
        }
        if self.pause_time.is_some() {
            len += 1;
        }
        if self.pause_total_time.is_some() {
            len += 1;
        }
        if self.out_look_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonTimerInfo", len)?;
        if let Some(v) = self.r#type.as_ref() {
            let v = EDungeonTimerType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Type", &v)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            struct_ser.serialize_field("StartTime", v)?;
        }
        if let Some(v) = self.dungeon_times.as_ref() {
            struct_ser.serialize_field("DungeonTimes", v)?;
        }
        if let Some(v) = self.direction.as_ref() {
            let v = EDungeonTimerDirection::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Direction", &v)?;
        }
        if let Some(v) = self.index.as_ref() {
            struct_ser.serialize_field("Index", v)?;
        }
        if let Some(v) = self.change_time.as_ref() {
            struct_ser.serialize_field("ChangeTime", v)?;
        }
        if let Some(v) = self.effect_type.as_ref() {
            let v = EDungeonTimerEffectType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("EffectType", &v)?;
        }
        if let Some(v) = self.pause_time.as_ref() {
            struct_ser.serialize_field("PauseTime", v)?;
        }
        if let Some(v) = self.pause_total_time.as_ref() {
            struct_ser.serialize_field("PauseTotalTime", v)?;
        }
        if let Some(v) = self.out_look_type.as_ref() {
            let v = EDungeonTimerTimerLookType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("OutLookType", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonTimerInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Type",
            "StartTime",
            "DungeonTimes",
            "Direction",
            "Index",
            "ChangeTime",
            "EffectType",
            "PauseTime",
            "PauseTotalTime",
            "OutLookType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            StartTime,
            DungeonTimes,
            Direction,
            Index,
            ChangeTime,
            EffectType,
            PauseTime,
            PauseTotalTime,
            OutLookType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Type" => Ok(GeneratedField::Type),
                            "StartTime" => Ok(GeneratedField::StartTime),
                            "DungeonTimes" => Ok(GeneratedField::DungeonTimes),
                            "Direction" => Ok(GeneratedField::Direction),
                            "Index" => Ok(GeneratedField::Index),
                            "ChangeTime" => Ok(GeneratedField::ChangeTime),
                            "EffectType" => Ok(GeneratedField::EffectType),
                            "PauseTime" => Ok(GeneratedField::PauseTime),
                            "PauseTotalTime" => Ok(GeneratedField::PauseTotalTime),
                            "OutLookType" => Ok(GeneratedField::OutLookType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonTimerInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonTimerInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonTimerInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut start_time__ = None;
                let mut dungeon_times__ = None;
                let mut direction__ = None;
                let mut index__ = None;
                let mut change_time__ = None;
                let mut effect_type__ = None;
                let mut pause_time__ = None;
                let mut pause_total_time__ = None;
                let mut out_look_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<EDungeonTimerType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::StartTime => {
                            if start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StartTime"));
                            }
                            start_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DungeonTimes => {
                            if dungeon_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonTimes"));
                            }
                            dungeon_times__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Direction => {
                            if direction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Direction"));
                            }
                            direction__ = map_.next_value::<::std::option::Option<EDungeonTimerDirection>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Index => {
                            if index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Index"));
                            }
                            index__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ChangeTime => {
                            if change_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ChangeTime"));
                            }
                            change_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EffectType => {
                            if effect_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EffectType"));
                            }
                            effect_type__ = map_.next_value::<::std::option::Option<EDungeonTimerEffectType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::PauseTime => {
                            if pause_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PauseTime"));
                            }
                            pause_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PauseTotalTime => {
                            if pause_total_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PauseTotalTime"));
                            }
                            pause_total_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OutLookType => {
                            if out_look_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OutLookType"));
                            }
                            out_look_type__ = map_.next_value::<::std::option::Option<EDungeonTimerTimerLookType>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(DungeonTimerInfo {
                    r#type: r#type__,
                    start_time: start_time__,
                    dungeon_times: dungeon_times__,
                    direction: direction__,
                    index: index__,
                    change_time: change_time__,
                    effect_type: effect_type__,
                    pause_time: pause_time__,
                    pause_total_time: pause_total_time__,
                    out_look_type: out_look_type__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonTimerInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonTitle {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonTitle", len)?;
        if !self.title_list.is_empty() {
            struct_ser.serialize_field("TitleList", &self.title_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonTitle {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TitleList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TitleList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TitleList" => Ok(GeneratedField::TitleList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonTitle;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonTitle")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonTitle, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TitleList => {
                            if title_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TitleList"));
                            }
                            title_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonTitle {
                    title_list: title_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonTitle", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonTitleInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if self.title_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonTitleInfo", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.title_id.as_ref() {
            struct_ser.serialize_field("TitleId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonTitleInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "TitleId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            TitleId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "TitleId" => Ok(GeneratedField::TitleId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonTitleInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonTitleInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonTitleInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut title_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TitleId => {
                            if title_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TitleId"));
                            }
                            title_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonTitleInfo {
                    uuid: uuid__,
                    title_id: title_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonTitleInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonTitleList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.title_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonTitleList", len)?;
        if !self.title_info.is_empty() {
            struct_ser.serialize_field("TitleInfo", &self.title_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonTitleList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TitleInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TitleInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TitleInfo" => Ok(GeneratedField::TitleInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonTitleList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonTitleList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonTitleList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut title_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TitleInfo => {
                            if title_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TitleInfo"));
                            }
                            title_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonTitleList {
                    title_info: title_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonTitleList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonUnionInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.union_id.is_some() {
            len += 1;
        }
        if !self.union_buildings.is_empty() {
            len += 1;
        }
        if !self.e_screen_infos.is_empty() {
            len += 1;
        }
        if self.dance_ball.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonUnionInfo", len)?;
        if let Some(v) = self.union_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("UnionId", ToString::to_string(&v).as_str())?;
        }
        if !self.union_buildings.is_empty() {
            struct_ser.serialize_field("UnionBuildings", &self.union_buildings)?;
        }
        if !self.e_screen_infos.is_empty() {
            struct_ser.serialize_field("EScreenInfos", &self.e_screen_infos)?;
        }
        if let Some(v) = self.dance_ball.as_ref() {
            struct_ser.serialize_field("DanceBall", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonUnionInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UnionId",
            "UnionBuildings",
            "EScreenInfos",
            "DanceBall",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UnionId,
            UnionBuildings,
            EScreenInfos,
            DanceBall,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UnionId" => Ok(GeneratedField::UnionId),
                            "UnionBuildings" => Ok(GeneratedField::UnionBuildings),
                            "EScreenInfos" => Ok(GeneratedField::EScreenInfos),
                            "DanceBall" => Ok(GeneratedField::DanceBall),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonUnionInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonUnionInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonUnionInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut union_id__ = None;
                let mut union_buildings__ = None;
                let mut e_screen_infos__ = None;
                let mut dance_ball__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UnionId => {
                            if union_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnionId"));
                            }
                            union_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::UnionBuildings => {
                            if union_buildings__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnionBuildings"));
                            }
                            union_buildings__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::EScreenInfos => {
                            if e_screen_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EScreenInfos"));
                            }
                            e_screen_infos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::DanceBall => {
                            if dance_ball__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DanceBall"));
                            }
                            dance_ball__ = map_.next_value()?;
                        }
                    }
                }
                Ok(DungeonUnionInfo {
                    union_id: union_id__,
                    union_buildings: union_buildings__.unwrap_or_default(),
                    e_screen_infos: e_screen_infos__.unwrap_or_default(),
                    dance_ball: dance_ball__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonUnionInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonVar {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dungeon_var_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonVar", len)?;
        if !self.dungeon_var_data.is_empty() {
            struct_ser.serialize_field("DungeonVarData", &self.dungeon_var_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonVar {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonVarData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DungeonVarData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DungeonVarData" => Ok(GeneratedField::DungeonVarData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonVar;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonVar")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonVar, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dungeon_var_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DungeonVarData => {
                            if dungeon_var_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonVarData"));
                            }
                            dungeon_var_data__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(DungeonVar {
                    dungeon_var_data: dungeon_var_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonVar", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonVarAll {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dungeon_var_all_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonVarAll", len)?;
        if !self.dungeon_var_all_map.is_empty() {
            struct_ser.serialize_field("DungeonVarAllMap", &self.dungeon_var_all_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonVarAll {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonVarAllMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DungeonVarAllMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DungeonVarAllMap" => Ok(GeneratedField::DungeonVarAllMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonVarAll;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonVarAll")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonVarAll, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dungeon_var_all_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DungeonVarAllMap => {
                            if dungeon_var_all_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonVarAllMap"));
                            }
                            dungeon_var_all_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonVarAll {
                    dungeon_var_all_map: dungeon_var_all_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonVarAll", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonVarData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonVarData", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("Name", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("Value", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonVarData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Name",
            "Value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Name" => Ok(GeneratedField::Name),
                            "Value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonVarData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonVarData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonVarData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Value"));
                            }
                            value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonVarData {
                    name: name__,
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonVarData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonVote {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.vote.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonVote", len)?;
        if !self.vote.is_empty() {
            struct_ser.serialize_field("Vote", &self.vote)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonVote {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Vote",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Vote,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Vote" => Ok(GeneratedField::Vote),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonVote;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonVote")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonVote, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut vote__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Vote => {
                            if vote__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Vote"));
                            }
                            vote__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonVote {
                    vote: vote__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonVote", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonWeekTargetList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.week_target.is_empty() {
            len += 1;
        }
        if self.refresh_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonWeekTargetList", len)?;
        if !self.week_target.is_empty() {
            struct_ser.serialize_field("WeekTarget", &self.week_target)?;
        }
        if let Some(v) = self.refresh_time.as_ref() {
            struct_ser.serialize_field("RefreshTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonWeekTargetList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "WeekTarget",
            "RefreshTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            WeekTarget,
            RefreshTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "WeekTarget" => Ok(GeneratedField::WeekTarget),
                            "RefreshTime" => Ok(GeneratedField::RefreshTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonWeekTargetList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonWeekTargetList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonWeekTargetList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut week_target__ = None;
                let mut refresh_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::WeekTarget => {
                            if week_target__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WeekTarget"));
                            }
                            week_target__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::RefreshTime => {
                            if refresh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshTime"));
                            }
                            refresh_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(DungeonWeekTargetList {
                    week_target: week_target__.unwrap_or_default(),
                    refresh_time: refresh_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonWeekTargetList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DungeonWorldBossSettlement {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.boss_hp_percent.is_some() {
            len += 1;
        }
        if self.dungeon_boss_rank.is_some() {
            len += 1;
        }
        if !self.award.is_empty() {
            len += 1;
        }
        if !self.boss_rank_award.is_empty() {
            len += 1;
        }
        if !self.last_hit_award.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.DungeonWorldBossSettlement", len)?;
        if let Some(v) = self.boss_hp_percent.as_ref() {
            struct_ser.serialize_field("BossHpPercent", v)?;
        }
        if let Some(v) = self.dungeon_boss_rank.as_ref() {
            struct_ser.serialize_field("DungeonBossRank", v)?;
        }
        if !self.award.is_empty() {
            struct_ser.serialize_field("Award", &self.award)?;
        }
        if !self.boss_rank_award.is_empty() {
            struct_ser.serialize_field("BossRankAward", &self.boss_rank_award)?;
        }
        if !self.last_hit_award.is_empty() {
            struct_ser.serialize_field("LastHitAward", &self.last_hit_award)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DungeonWorldBossSettlement {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BossHpPercent",
            "DungeonBossRank",
            "Award",
            "BossRankAward",
            "LastHitAward",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BossHpPercent,
            DungeonBossRank,
            Award,
            BossRankAward,
            LastHitAward,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BossHpPercent" => Ok(GeneratedField::BossHpPercent),
                            "DungeonBossRank" => Ok(GeneratedField::DungeonBossRank),
                            "Award" => Ok(GeneratedField::Award),
                            "BossRankAward" => Ok(GeneratedField::BossRankAward),
                            "LastHitAward" => Ok(GeneratedField::LastHitAward),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DungeonWorldBossSettlement;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.DungeonWorldBossSettlement")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DungeonWorldBossSettlement, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut boss_hp_percent__ = None;
                let mut dungeon_boss_rank__ = None;
                let mut award__ = None;
                let mut boss_rank_award__ = None;
                let mut last_hit_award__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BossHpPercent => {
                            if boss_hp_percent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BossHpPercent"));
                            }
                            boss_hp_percent__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DungeonBossRank => {
                            if dungeon_boss_rank__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonBossRank"));
                            }
                            dungeon_boss_rank__ = map_.next_value()?;
                        }
                        GeneratedField::Award => {
                            if award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Award"));
                            }
                            award__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::BossRankAward => {
                            if boss_rank_award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BossRankAward"));
                            }
                            boss_rank_award__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::LastHitAward => {
                            if last_hit_award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastHitAward"));
                            }
                            last_hit_award__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(DungeonWorldBossSettlement {
                    boss_hp_percent: boss_hp_percent__,
                    dungeon_boss_rank: dungeon_boss_rank__,
                    award: award__.unwrap_or_default(),
                    boss_rank_award: boss_rank_award__.unwrap_or_default(),
                    last_hit_award: last_hit_award__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.DungeonWorldBossSettlement", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EActorState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ActorStateDefault => "ActorStateDefault",
            Self::ActorStateSinging => "ActorStateSinging",
            Self::ActorStateSkill => "ActorStateSkill",
            Self::ActorStateJump => "ActorStateJump",
            Self::ActorStateRush => "ActorStateRush",
            Self::ActorStateClimb => "ActorStateClimb",
            Self::ActorStateSwim => "ActorStateSwim",
            Self::ActorStateFishing => "ActorStateFishing",
            Self::ActorStateAction => "ActorStateAction",
            Self::ActorStateDead => "ActorStateDead",
            Self::ActorStateStiff => "ActorStateStiff",
            Self::ActorStateSwimStiff => "ActorStateSwimStiff",
            Self::ActorStateBorn => "ActorStateBorn",
            Self::ActorStateTelePort => "ActorStateTelePort",
            Self::ActorStateFall => "ActorStateFall",
            Self::ActorStateFlow => "ActorStateFlow",
            Self::ActorStateGlide => "ActorStateGlide",
            Self::ActorStatePedalWall => "ActorStatePedalWall",
            Self::ActorStateFallTelePort => "ActorStateFallTelePort",
            Self::ActorStateSelfPhoto => "ActorStateSelfPhoto",
            Self::ActorStateCollection => "ActorStateCollection",
            Self::ActorStateReset => "ActorStateReset",
            Self::ActorStateBreaking => "ActorStateBreaking",
            Self::ActorStateWeakness => "ActorStateWeakness",
            Self::ActorStateFracture => "ActorStateFracture",
            Self::ActorStateAbnormal => "ActorStateAbnormal",
            Self::ActorStateResurrection => "ActorStateResurrection",
            Self::ActorStateInteraction => "ActorStateInteraction",
            Self::ActorStateSceneInteraction => "ActorStateSceneInteraction",
            Self::ActorStateTunnelFly => "ActorStateTunnelFly",
            Self::ActorStateLevitation => "ActorStateLevitation",
            Self::ActorStateHomelandEdit => "ActorStateHomelandEdit",
            Self::ActorStateRide => "ActorStateRide",
            Self::ActorStateRideControl => "ActorStateRideControl",
            Self::ActorStateAll => "ActorStateAll",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EActorState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ActorStateDefault",
            "ActorStateSinging",
            "ActorStateSkill",
            "ActorStateJump",
            "ActorStateRush",
            "ActorStateClimb",
            "ActorStateSwim",
            "ActorStateFishing",
            "ActorStateAction",
            "ActorStateDead",
            "ActorStateStiff",
            "ActorStateSwimStiff",
            "ActorStateBorn",
            "ActorStateTelePort",
            "ActorStateFall",
            "ActorStateFlow",
            "ActorStateGlide",
            "ActorStatePedalWall",
            "ActorStateFallTelePort",
            "ActorStateSelfPhoto",
            "ActorStateCollection",
            "ActorStateReset",
            "ActorStateBreaking",
            "ActorStateWeakness",
            "ActorStateFracture",
            "ActorStateAbnormal",
            "ActorStateResurrection",
            "ActorStateInteraction",
            "ActorStateSceneInteraction",
            "ActorStateTunnelFly",
            "ActorStateLevitation",
            "ActorStateHomelandEdit",
            "ActorStateRide",
            "ActorStateRideControl",
            "ActorStateAll",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EActorState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ActorStateDefault" => Ok(EActorState::ActorStateDefault),
                    "ActorStateSinging" => Ok(EActorState::ActorStateSinging),
                    "ActorStateSkill" => Ok(EActorState::ActorStateSkill),
                    "ActorStateJump" => Ok(EActorState::ActorStateJump),
                    "ActorStateRush" => Ok(EActorState::ActorStateRush),
                    "ActorStateClimb" => Ok(EActorState::ActorStateClimb),
                    "ActorStateSwim" => Ok(EActorState::ActorStateSwim),
                    "ActorStateFishing" => Ok(EActorState::ActorStateFishing),
                    "ActorStateAction" => Ok(EActorState::ActorStateAction),
                    "ActorStateDead" => Ok(EActorState::ActorStateDead),
                    "ActorStateStiff" => Ok(EActorState::ActorStateStiff),
                    "ActorStateSwimStiff" => Ok(EActorState::ActorStateSwimStiff),
                    "ActorStateBorn" => Ok(EActorState::ActorStateBorn),
                    "ActorStateTelePort" => Ok(EActorState::ActorStateTelePort),
                    "ActorStateFall" => Ok(EActorState::ActorStateFall),
                    "ActorStateFlow" => Ok(EActorState::ActorStateFlow),
                    "ActorStateGlide" => Ok(EActorState::ActorStateGlide),
                    "ActorStatePedalWall" => Ok(EActorState::ActorStatePedalWall),
                    "ActorStateFallTelePort" => Ok(EActorState::ActorStateFallTelePort),
                    "ActorStateSelfPhoto" => Ok(EActorState::ActorStateSelfPhoto),
                    "ActorStateCollection" => Ok(EActorState::ActorStateCollection),
                    "ActorStateReset" => Ok(EActorState::ActorStateReset),
                    "ActorStateBreaking" => Ok(EActorState::ActorStateBreaking),
                    "ActorStateWeakness" => Ok(EActorState::ActorStateWeakness),
                    "ActorStateFracture" => Ok(EActorState::ActorStateFracture),
                    "ActorStateAbnormal" => Ok(EActorState::ActorStateAbnormal),
                    "ActorStateResurrection" => Ok(EActorState::ActorStateResurrection),
                    "ActorStateInteraction" => Ok(EActorState::ActorStateInteraction),
                    "ActorStateSceneInteraction" => Ok(EActorState::ActorStateSceneInteraction),
                    "ActorStateTunnelFly" => Ok(EActorState::ActorStateTunnelFly),
                    "ActorStateLevitation" => Ok(EActorState::ActorStateLevitation),
                    "ActorStateHomelandEdit" => Ok(EActorState::ActorStateHomelandEdit),
                    "ActorStateRide" => Ok(EActorState::ActorStateRide),
                    "ActorStateRideControl" => Ok(EActorState::ActorStateRideControl),
                    "ActorStateAll" => Ok(EActorState::ActorStateAll),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EAppearType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::EAppearNull => "EAppearNull",
            Self::EAppearTransferIn => "EAppearTransferIn",
            Self::EAppearTransferPassLineIn => "EAppearTransferPassLineIn",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EAppearType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EAppearNull",
            "EAppearTransferIn",
            "EAppearTransferPassLineIn",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EAppearType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EAppearNull" => Ok(EAppearType::EAppearNull),
                    "EAppearTransferIn" => Ok(EAppearType::EAppearTransferIn),
                    "EAppearTransferPassLineIn" => Ok(EAppearType::EAppearTransferPassLineIn),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EBodySize {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::BodySizeNull => "BodySizeNull",
            Self::BodySizeS => "BodySizeS",
            Self::BodySizeM => "BodySizeM",
            Self::BodySizeL => "BodySizeL",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EBodySize {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BodySizeNull",
            "BodySizeS",
            "BodySizeM",
            "BodySizeL",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EBodySize;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "BodySizeNull" => Ok(EBodySize::BodySizeNull),
                    "BodySizeS" => Ok(EBodySize::BodySizeS),
                    "BodySizeM" => Ok(EBodySize::BodySizeM),
                    "BodySizeL" => Ok(EBodySize::BodySizeL),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EBuffEffectLogicPbType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::PlayEffect => "PlayEffect",
            Self::Gravity => "Gravity",
            Self::ParabolaEffect => "ParabolaEffect",
            Self::Linking => "Linking",
            Self::ConfusionEffect => "ConfusionEffect",
            Self::ZoomScale => "ZoomScale",
            Self::BuffProfessionEffect => "BuffProfessionEffect",
            Self::TeleportBelt => "TeleportBelt",
            Self::BuffEffectRainbow => "BuffEffectRainbow",
            Self::BuffEffectAttrHud => "BuffEffectAttrHUD",
            Self::BuffEffectStop => "BuffEffectStop",
            Self::BuffEffectProgress => "BuffEffectProgress",
            Self::BuffEffectEnergyDisplay => "BuffEffectEnergyDisplay",
            Self::BuffEffectStopAll => "BuffEffectStopAll",
            Self::BuffEffectLayerChange => "BuffEffectLayerChange",
            Self::Tension => "Tension",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EBuffEffectLogicPbType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PlayEffect",
            "Gravity",
            "ParabolaEffect",
            "Linking",
            "ConfusionEffect",
            "ZoomScale",
            "BuffProfessionEffect",
            "TeleportBelt",
            "BuffEffectRainbow",
            "BuffEffectAttrHUD",
            "BuffEffectStop",
            "BuffEffectProgress",
            "BuffEffectEnergyDisplay",
            "BuffEffectStopAll",
            "BuffEffectLayerChange",
            "Tension",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EBuffEffectLogicPbType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PlayEffect" => Ok(EBuffEffectLogicPbType::PlayEffect),
                    "Gravity" => Ok(EBuffEffectLogicPbType::Gravity),
                    "ParabolaEffect" => Ok(EBuffEffectLogicPbType::ParabolaEffect),
                    "Linking" => Ok(EBuffEffectLogicPbType::Linking),
                    "ConfusionEffect" => Ok(EBuffEffectLogicPbType::ConfusionEffect),
                    "ZoomScale" => Ok(EBuffEffectLogicPbType::ZoomScale),
                    "BuffProfessionEffect" => Ok(EBuffEffectLogicPbType::BuffProfessionEffect),
                    "TeleportBelt" => Ok(EBuffEffectLogicPbType::TeleportBelt),
                    "BuffEffectRainbow" => Ok(EBuffEffectLogicPbType::BuffEffectRainbow),
                    "BuffEffectAttrHUD" => Ok(EBuffEffectLogicPbType::BuffEffectAttrHud),
                    "BuffEffectStop" => Ok(EBuffEffectLogicPbType::BuffEffectStop),
                    "BuffEffectProgress" => Ok(EBuffEffectLogicPbType::BuffEffectProgress),
                    "BuffEffectEnergyDisplay" => Ok(EBuffEffectLogicPbType::BuffEffectEnergyDisplay),
                    "BuffEffectStopAll" => Ok(EBuffEffectLogicPbType::BuffEffectStopAll),
                    "BuffEffectLayerChange" => Ok(EBuffEffectLogicPbType::BuffEffectLayerChange),
                    "Tension" => Ok(EBuffEffectLogicPbType::Tension),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EBuffEventType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::BuffEventUnknown => "BuffEventUnknown",
            Self::BuffEventAddTo => "BuffEventAddTo",
            Self::BuffEventRemove => "BuffEventRemove",
            Self::BuffEventReplace => "BuffEventReplace",
            Self::BuffEventTimer => "BuffEventTimer",
            Self::BuffEventStackLayer => "BuffEventStackLayer",
            Self::BuffEventRemoveLayer => "BuffEventRemoveLayer",
            Self::BuffEventOnHitTargetBefore => "BuffEventOnHitTargetBefore",
            Self::BuffEventOnHitTargetAfter => "BuffEventOnHitTargetAfter",
            Self::BuffEventOnHittedBefore => "BuffEventOnHittedBefore",
            Self::BuffEventOnHittedAfter => "BuffEventOnHittedAfter",
            Self::BuffEventOnReachMaxLayer => "BuffEventOnReachMaxLayer",
            Self::BuffEventHostDeath => "BuffEventHostDeath",
            Self::BuffEventOnSkillHitAfter => "BuffEventOnSkillHitAfter",
            Self::BuffEventTrigTimingAura => "BuffEventTrigTimingAura",
            Self::BuffEventBodyPartDead => "BuffEventBodyPartDead",
            Self::BuffEventBodyPartHit => "BuffEventBodyPartHit",
            Self::BuffEventBodyPartStateChange => "BuffEventBodyPartStateChange",
            Self::BuffEventOnPartHittedBefore => "BuffEventOnPartHittedBefore",
            Self::BuffEventOnPartHittedAfter => "BuffEventOnPartHittedAfter",
            Self::BuffEventGravitational => "BuffEventGravitational",
            Self::BuffEventFightResChange => "BuffEventFightResChange",
            Self::BuffEventOnKillActor => "BuffEventOnKillActor",
            Self::BuffEventAttrWatcher => "BuffEventAttrWatcher",
            Self::BuffEventOnHittedLhBefore => "BuffEventOnHittedLHBefore",
            Self::BuffEventOnBeHittedLhBefore => "BuffEventOnBeHittedLHBefore",
            Self::BuffEventAddByTarget => "BuffEventAddByTarget",
            Self::BuffEventRemoveByTarget => "BuffEventRemoveByTarget",
            Self::BuffEventInCombatState => "BuffEventInCombatState",
            Self::BuffEventOutCombatState => "BuffEventOutCombatState",
            Self::BuffEventSkillBegin => "BuffEventSkillBegin",
            Self::BuffEventSkillEnd => "BuffEventSkillEnd",
            Self::BuffEventSingingEnd => "BuffEventSingingEnd",
            Self::BuffEventSummonBuffAdd => "BuffEventSummonBuffAdd",
            Self::BuffEventSummonEntity => "BuffEventSummonEntity",
            Self::BuffEventGuideEnd => "BuffEventGuideEnd",
            Self::BuffEventOnDelayHit => "BuffEventOnDelayHit",
            Self::BuffEventTeamBuffAdd => "BuffEventTeamBuffAdd",
            Self::BuffEventChangeProfession => "BuffEventChangeProfession",
            Self::BuffEventDodgeSuccess => "BuffEventDodgeSuccess",
            Self::BuffEventHealBefore => "BuffEventHealBefore",
            Self::BuffEventHealAfter => "BuffEventHealAfter",
            Self::BuffEventProduceHealBefore => "BuffEventProduceHealBefore",
            Self::BuffEventProduceHealAfter => "BuffEventProduceHealAfter",
            Self::BuffEventShieldBroken => "BuffEventShieldBroken",
            Self::BuffEventLinkingStart => "BuffEventLinkingStart",
            Self::BuffEventLinkingEnd => "BuffEventLinkingEnd",
            Self::BuffEventLinkingWatcher => "BuffEventLinkingWatcher",
            Self::BuffEventSuperArmorBroken => "BuffEventSuperArmorBroken",
            Self::BuffEventAddedByTargetTag => "BuffEventAddedByTargetTag",
            Self::BuffEventAddToTargetTag => "BuffEventAddToTargetTag",
            Self::BuffEventOnBeHitLessenHp => "BuffEventOnBeHitLessenHp",
            Self::BuffEventEnterBreaking => "BuffEventEnterBreaking",
            Self::BuffEventTeleportBelt => "BuffEventTeleportBelt",
            Self::BuffEventOnBeHitAfterOnly => "BuffEventOnBeHitAfterOnly",
            Self::BuffEventOnHitAfterOnly => "BuffEventOnHitAfterOnly",
            Self::BuffEventOnBeHealAfterOnly => "BuffEventOnBeHealAfterOnly",
            Self::BuffEventOnHealAfterOnly => "BuffEventOnHealAfterOnly",
            Self::BuffEventHealCalcAttrBefore => "BuffEventHealCalcAttrBefore",
            Self::BuffEventProduceHealCalcAttrBefore => "BuffEventProduceHealCalcAttrBefore",
            Self::BuffEventReviveSuccessEnd => "BuffEventReviveSuccessEnd",
            Self::BuffEventAfterReviveFirstMove => "BuffEventAfterReviveFirstMove",
            Self::BuffEventMonsterIntoAlert => "BuffEventMonsterIntoAlert",
            Self::BuffEventMonsterOutAlert => "BuffEventMonsterOutAlert",
            Self::BuffEventOnAddShieldCalcBefore => "BuffEventOnAddShieldCalcBefore",
            Self::BuffEventOnAddShieldBefore => "BuffEventOnAddShieldBefore",
            Self::BuffEventOnAddShieldAfter => "BuffEventOnAddShieldAfter",
            Self::BuffEventOnBeAddedShieldCalcBefore => "BuffEventOnBeAddedShieldCalcBefore",
            Self::BuffEventOnBeAddedShieldBefore => "BuffEventOnBeAddedShieldBefore",
            Self::BuffEventOnBeAddedShieldAfter => "BuffEventOnBeAddedShieldAfter",
            Self::BuffEventProgressWatcher => "BuffEventProgressWatcher",
            Self::BuffEventOnLuckyDamage => "BuffEventOnLuckyDamage",
            Self::BuffEventSkillCdEnd => "BuffEventSkillCDEnd",
            Self::BuffEventMotionless => "BuffEventMotionless",
            Self::BuffEventParticipateKill => "BuffEventParticipateKill",
            Self::BuffEventProfessionBdTypeChange => "BuffEventProfessionBDTypeChange",
            Self::BuffEventSingingBegin => "BuffEventSingingBegin",
            Self::BuffEventGuideBegin => "BuffEventGuideBegin",
            Self::BuffEventRandTimer => "BuffEventRandTimer",
            Self::BuffEventIntoFractureState => "BuffEventIntoFractureState",
            Self::BuffEventTakeOnRide => "BuffEventTakeOnRide",
            Self::BuffEventTakeOffRide => "BuffEventTakeOffRide",
            Self::BuffEventStartJump => "BuffEventStartJump",
            Self::BuffEventPlayAction => "BuffEventPlayAction",
            Self::BuffEventPlayEmote => "BuffEventPlayEmote",
            Self::BuffEventCheck => "BuffEventCheck",
            Self::BuffEventCustomize => "BuffEventCustomize",
            Self::BuffEventShapeshiftEndEvent => "BuffEventShapeshiftEndEvent",
            Self::BuffEventAttrRefresh => "BuffEventAttrRefresh",
            Self::BuffEventMonitorTeamKillActor => "BuffEventMonitorTeamKillActor",
            Self::BuffEventSpecialEffects => "BuffEventSpecialEffects",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EBuffEventType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BuffEventUnknown",
            "BuffEventAddTo",
            "BuffEventRemove",
            "BuffEventReplace",
            "BuffEventTimer",
            "BuffEventStackLayer",
            "BuffEventRemoveLayer",
            "BuffEventOnHitTargetBefore",
            "BuffEventOnHitTargetAfter",
            "BuffEventOnHittedBefore",
            "BuffEventOnHittedAfter",
            "BuffEventOnReachMaxLayer",
            "BuffEventHostDeath",
            "BuffEventOnSkillHitAfter",
            "BuffEventTrigTimingAura",
            "BuffEventBodyPartDead",
            "BuffEventBodyPartHit",
            "BuffEventBodyPartStateChange",
            "BuffEventOnPartHittedBefore",
            "BuffEventOnPartHittedAfter",
            "BuffEventGravitational",
            "BuffEventFightResChange",
            "BuffEventOnKillActor",
            "BuffEventAttrWatcher",
            "BuffEventOnHittedLHBefore",
            "BuffEventOnBeHittedLHBefore",
            "BuffEventAddByTarget",
            "BuffEventRemoveByTarget",
            "BuffEventInCombatState",
            "BuffEventOutCombatState",
            "BuffEventSkillBegin",
            "BuffEventSkillEnd",
            "BuffEventSingingEnd",
            "BuffEventSummonBuffAdd",
            "BuffEventSummonEntity",
            "BuffEventGuideEnd",
            "BuffEventOnDelayHit",
            "BuffEventTeamBuffAdd",
            "BuffEventChangeProfession",
            "BuffEventDodgeSuccess",
            "BuffEventHealBefore",
            "BuffEventHealAfter",
            "BuffEventProduceHealBefore",
            "BuffEventProduceHealAfter",
            "BuffEventShieldBroken",
            "BuffEventLinkingStart",
            "BuffEventLinkingEnd",
            "BuffEventLinkingWatcher",
            "BuffEventSuperArmorBroken",
            "BuffEventAddedByTargetTag",
            "BuffEventAddToTargetTag",
            "BuffEventOnBeHitLessenHp",
            "BuffEventEnterBreaking",
            "BuffEventTeleportBelt",
            "BuffEventOnBeHitAfterOnly",
            "BuffEventOnHitAfterOnly",
            "BuffEventOnBeHealAfterOnly",
            "BuffEventOnHealAfterOnly",
            "BuffEventHealCalcAttrBefore",
            "BuffEventProduceHealCalcAttrBefore",
            "BuffEventReviveSuccessEnd",
            "BuffEventAfterReviveFirstMove",
            "BuffEventMonsterIntoAlert",
            "BuffEventMonsterOutAlert",
            "BuffEventOnAddShieldCalcBefore",
            "BuffEventOnAddShieldBefore",
            "BuffEventOnAddShieldAfter",
            "BuffEventOnBeAddedShieldCalcBefore",
            "BuffEventOnBeAddedShieldBefore",
            "BuffEventOnBeAddedShieldAfter",
            "BuffEventProgressWatcher",
            "BuffEventOnLuckyDamage",
            "BuffEventSkillCDEnd",
            "BuffEventMotionless",
            "BuffEventParticipateKill",
            "BuffEventProfessionBDTypeChange",
            "BuffEventSingingBegin",
            "BuffEventGuideBegin",
            "BuffEventRandTimer",
            "BuffEventIntoFractureState",
            "BuffEventTakeOnRide",
            "BuffEventTakeOffRide",
            "BuffEventStartJump",
            "BuffEventPlayAction",
            "BuffEventPlayEmote",
            "BuffEventCheck",
            "BuffEventCustomize",
            "BuffEventShapeshiftEndEvent",
            "BuffEventAttrRefresh",
            "BuffEventMonitorTeamKillActor",
            "BuffEventSpecialEffects",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EBuffEventType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "BuffEventUnknown" => Ok(EBuffEventType::BuffEventUnknown),
                    "BuffEventAddTo" => Ok(EBuffEventType::BuffEventAddTo),
                    "BuffEventRemove" => Ok(EBuffEventType::BuffEventRemove),
                    "BuffEventReplace" => Ok(EBuffEventType::BuffEventReplace),
                    "BuffEventTimer" => Ok(EBuffEventType::BuffEventTimer),
                    "BuffEventStackLayer" => Ok(EBuffEventType::BuffEventStackLayer),
                    "BuffEventRemoveLayer" => Ok(EBuffEventType::BuffEventRemoveLayer),
                    "BuffEventOnHitTargetBefore" => Ok(EBuffEventType::BuffEventOnHitTargetBefore),
                    "BuffEventOnHitTargetAfter" => Ok(EBuffEventType::BuffEventOnHitTargetAfter),
                    "BuffEventOnHittedBefore" => Ok(EBuffEventType::BuffEventOnHittedBefore),
                    "BuffEventOnHittedAfter" => Ok(EBuffEventType::BuffEventOnHittedAfter),
                    "BuffEventOnReachMaxLayer" => Ok(EBuffEventType::BuffEventOnReachMaxLayer),
                    "BuffEventHostDeath" => Ok(EBuffEventType::BuffEventHostDeath),
                    "BuffEventOnSkillHitAfter" => Ok(EBuffEventType::BuffEventOnSkillHitAfter),
                    "BuffEventTrigTimingAura" => Ok(EBuffEventType::BuffEventTrigTimingAura),
                    "BuffEventBodyPartDead" => Ok(EBuffEventType::BuffEventBodyPartDead),
                    "BuffEventBodyPartHit" => Ok(EBuffEventType::BuffEventBodyPartHit),
                    "BuffEventBodyPartStateChange" => Ok(EBuffEventType::BuffEventBodyPartStateChange),
                    "BuffEventOnPartHittedBefore" => Ok(EBuffEventType::BuffEventOnPartHittedBefore),
                    "BuffEventOnPartHittedAfter" => Ok(EBuffEventType::BuffEventOnPartHittedAfter),
                    "BuffEventGravitational" => Ok(EBuffEventType::BuffEventGravitational),
                    "BuffEventFightResChange" => Ok(EBuffEventType::BuffEventFightResChange),
                    "BuffEventOnKillActor" => Ok(EBuffEventType::BuffEventOnKillActor),
                    "BuffEventAttrWatcher" => Ok(EBuffEventType::BuffEventAttrWatcher),
                    "BuffEventOnHittedLHBefore" => Ok(EBuffEventType::BuffEventOnHittedLhBefore),
                    "BuffEventOnBeHittedLHBefore" => Ok(EBuffEventType::BuffEventOnBeHittedLhBefore),
                    "BuffEventAddByTarget" => Ok(EBuffEventType::BuffEventAddByTarget),
                    "BuffEventRemoveByTarget" => Ok(EBuffEventType::BuffEventRemoveByTarget),
                    "BuffEventInCombatState" => Ok(EBuffEventType::BuffEventInCombatState),
                    "BuffEventOutCombatState" => Ok(EBuffEventType::BuffEventOutCombatState),
                    "BuffEventSkillBegin" => Ok(EBuffEventType::BuffEventSkillBegin),
                    "BuffEventSkillEnd" => Ok(EBuffEventType::BuffEventSkillEnd),
                    "BuffEventSingingEnd" => Ok(EBuffEventType::BuffEventSingingEnd),
                    "BuffEventSummonBuffAdd" => Ok(EBuffEventType::BuffEventSummonBuffAdd),
                    "BuffEventSummonEntity" => Ok(EBuffEventType::BuffEventSummonEntity),
                    "BuffEventGuideEnd" => Ok(EBuffEventType::BuffEventGuideEnd),
                    "BuffEventOnDelayHit" => Ok(EBuffEventType::BuffEventOnDelayHit),
                    "BuffEventTeamBuffAdd" => Ok(EBuffEventType::BuffEventTeamBuffAdd),
                    "BuffEventChangeProfession" => Ok(EBuffEventType::BuffEventChangeProfession),
                    "BuffEventDodgeSuccess" => Ok(EBuffEventType::BuffEventDodgeSuccess),
                    "BuffEventHealBefore" => Ok(EBuffEventType::BuffEventHealBefore),
                    "BuffEventHealAfter" => Ok(EBuffEventType::BuffEventHealAfter),
                    "BuffEventProduceHealBefore" => Ok(EBuffEventType::BuffEventProduceHealBefore),
                    "BuffEventProduceHealAfter" => Ok(EBuffEventType::BuffEventProduceHealAfter),
                    "BuffEventShieldBroken" => Ok(EBuffEventType::BuffEventShieldBroken),
                    "BuffEventLinkingStart" => Ok(EBuffEventType::BuffEventLinkingStart),
                    "BuffEventLinkingEnd" => Ok(EBuffEventType::BuffEventLinkingEnd),
                    "BuffEventLinkingWatcher" => Ok(EBuffEventType::BuffEventLinkingWatcher),
                    "BuffEventSuperArmorBroken" => Ok(EBuffEventType::BuffEventSuperArmorBroken),
                    "BuffEventAddedByTargetTag" => Ok(EBuffEventType::BuffEventAddedByTargetTag),
                    "BuffEventAddToTargetTag" => Ok(EBuffEventType::BuffEventAddToTargetTag),
                    "BuffEventOnBeHitLessenHp" => Ok(EBuffEventType::BuffEventOnBeHitLessenHp),
                    "BuffEventEnterBreaking" => Ok(EBuffEventType::BuffEventEnterBreaking),
                    "BuffEventTeleportBelt" => Ok(EBuffEventType::BuffEventTeleportBelt),
                    "BuffEventOnBeHitAfterOnly" => Ok(EBuffEventType::BuffEventOnBeHitAfterOnly),
                    "BuffEventOnHitAfterOnly" => Ok(EBuffEventType::BuffEventOnHitAfterOnly),
                    "BuffEventOnBeHealAfterOnly" => Ok(EBuffEventType::BuffEventOnBeHealAfterOnly),
                    "BuffEventOnHealAfterOnly" => Ok(EBuffEventType::BuffEventOnHealAfterOnly),
                    "BuffEventHealCalcAttrBefore" => Ok(EBuffEventType::BuffEventHealCalcAttrBefore),
                    "BuffEventProduceHealCalcAttrBefore" => Ok(EBuffEventType::BuffEventProduceHealCalcAttrBefore),
                    "BuffEventReviveSuccessEnd" => Ok(EBuffEventType::BuffEventReviveSuccessEnd),
                    "BuffEventAfterReviveFirstMove" => Ok(EBuffEventType::BuffEventAfterReviveFirstMove),
                    "BuffEventMonsterIntoAlert" => Ok(EBuffEventType::BuffEventMonsterIntoAlert),
                    "BuffEventMonsterOutAlert" => Ok(EBuffEventType::BuffEventMonsterOutAlert),
                    "BuffEventOnAddShieldCalcBefore" => Ok(EBuffEventType::BuffEventOnAddShieldCalcBefore),
                    "BuffEventOnAddShieldBefore" => Ok(EBuffEventType::BuffEventOnAddShieldBefore),
                    "BuffEventOnAddShieldAfter" => Ok(EBuffEventType::BuffEventOnAddShieldAfter),
                    "BuffEventOnBeAddedShieldCalcBefore" => Ok(EBuffEventType::BuffEventOnBeAddedShieldCalcBefore),
                    "BuffEventOnBeAddedShieldBefore" => Ok(EBuffEventType::BuffEventOnBeAddedShieldBefore),
                    "BuffEventOnBeAddedShieldAfter" => Ok(EBuffEventType::BuffEventOnBeAddedShieldAfter),
                    "BuffEventProgressWatcher" => Ok(EBuffEventType::BuffEventProgressWatcher),
                    "BuffEventOnLuckyDamage" => Ok(EBuffEventType::BuffEventOnLuckyDamage),
                    "BuffEventSkillCDEnd" => Ok(EBuffEventType::BuffEventSkillCdEnd),
                    "BuffEventMotionless" => Ok(EBuffEventType::BuffEventMotionless),
                    "BuffEventParticipateKill" => Ok(EBuffEventType::BuffEventParticipateKill),
                    "BuffEventProfessionBDTypeChange" => Ok(EBuffEventType::BuffEventProfessionBdTypeChange),
                    "BuffEventSingingBegin" => Ok(EBuffEventType::BuffEventSingingBegin),
                    "BuffEventGuideBegin" => Ok(EBuffEventType::BuffEventGuideBegin),
                    "BuffEventRandTimer" => Ok(EBuffEventType::BuffEventRandTimer),
                    "BuffEventIntoFractureState" => Ok(EBuffEventType::BuffEventIntoFractureState),
                    "BuffEventTakeOnRide" => Ok(EBuffEventType::BuffEventTakeOnRide),
                    "BuffEventTakeOffRide" => Ok(EBuffEventType::BuffEventTakeOffRide),
                    "BuffEventStartJump" => Ok(EBuffEventType::BuffEventStartJump),
                    "BuffEventPlayAction" => Ok(EBuffEventType::BuffEventPlayAction),
                    "BuffEventPlayEmote" => Ok(EBuffEventType::BuffEventPlayEmote),
                    "BuffEventCheck" => Ok(EBuffEventType::BuffEventCheck),
                    "BuffEventCustomize" => Ok(EBuffEventType::BuffEventCustomize),
                    "BuffEventShapeshiftEndEvent" => Ok(EBuffEventType::BuffEventShapeshiftEndEvent),
                    "BuffEventAttrRefresh" => Ok(EBuffEventType::BuffEventAttrRefresh),
                    "BuffEventMonitorTeamKillActor" => Ok(EBuffEventType::BuffEventMonitorTeamKillActor),
                    "BuffEventSpecialEffects" => Ok(EBuffEventType::BuffEventSpecialEffects),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EDamageMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::DamageNormal => "DamageNormal",
            Self::DamagePhysical => "DamagePhysical",
            Self::DamageMagical => "DamageMagical",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EDamageMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DamageNormal",
            "DamagePhysical",
            "DamageMagical",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EDamageMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DamageNormal" => Ok(EDamageMode::DamageNormal),
                    "DamagePhysical" => Ok(EDamageMode::DamagePhysical),
                    "DamageMagical" => Ok(EDamageMode::DamageMagical),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EDamageProperty {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::General => "General",
            Self::Fire => "Fire",
            Self::Water => "Water",
            Self::Electricity => "Electricity",
            Self::Wood => "Wood",
            Self::Wind => "Wind",
            Self::Rock => "Rock",
            Self::Light => "Light",
            Self::Dark => "Dark",
            Self::Count => "Count",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EDamageProperty {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "General",
            "Fire",
            "Water",
            "Electricity",
            "Wood",
            "Wind",
            "Rock",
            "Light",
            "Dark",
            "Count",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EDamageProperty;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "General" => Ok(EDamageProperty::General),
                    "Fire" => Ok(EDamageProperty::Fire),
                    "Water" => Ok(EDamageProperty::Water),
                    "Electricity" => Ok(EDamageProperty::Electricity),
                    "Wood" => Ok(EDamageProperty::Wood),
                    "Wind" => Ok(EDamageProperty::Wind),
                    "Rock" => Ok(EDamageProperty::Rock),
                    "Light" => Ok(EDamageProperty::Light),
                    "Dark" => Ok(EDamageProperty::Dark),
                    "Count" => Ok(EDamageProperty::Count),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EDamageSource {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Skill => "EDamageSourceSkill",
            Self::Bullet => "EDamageSourceBullet",
            Self::Buff => "EDamageSourceBuff",
            Self::Fall => "EDamageSourceFall",
            Self::FakeBullet => "EDamageSourceFakeBullet",
            Self::Other => "EDamageSourceOther",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EDamageSource {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EDamageSourceSkill",
            "EDamageSourceBullet",
            "EDamageSourceBuff",
            "EDamageSourceFall",
            "EDamageSourceFakeBullet",
            "EDamageSourceOther",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EDamageSource;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EDamageSourceSkill" => Ok(EDamageSource::Skill),
                    "EDamageSourceBullet" => Ok(EDamageSource::Bullet),
                    "EDamageSourceBuff" => Ok(EDamageSource::Buff),
                    "EDamageSourceFall" => Ok(EDamageSource::Fall),
                    "EDamageSourceFakeBullet" => Ok(EDamageSource::FakeBullet),
                    "EDamageSourceOther" => Ok(EDamageSource::Other),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EDamageType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Normal => "Normal",
            Self::Miss => "Miss",
            Self::Heal => "Heal",
            Self::Immune => "Immune",
            Self::Fall => "Fall",
            Self::Absorbed => "Absorbed",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EDamageType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Normal",
            "Miss",
            "Heal",
            "Immune",
            "Fall",
            "Absorbed",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EDamageType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "Normal" => Ok(EDamageType::Normal),
                    "Miss" => Ok(EDamageType::Miss),
                    "Heal" => Ok(EDamageType::Heal),
                    "Immune" => Ok(EDamageType::Immune),
                    "Fall" => Ok(EDamageType::Fall),
                    "Absorbed" => Ok(EDamageType::Absorbed),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EDetachMagneticType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::EOperate => "EOperate",
            Self::EFall => "EFall",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EDetachMagneticType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EOperate",
            "EFall",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EDetachMagneticType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EOperate" => Ok(EDetachMagneticType::EOperate),
                    "EFall" => Ok(EDetachMagneticType::EFall),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EDisappearType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::EDisappearNormal => "EDisappearNormal",
            Self::EDisappearDead => "EDisappearDead",
            Self::EDisappearDestroy => "EDisappearDestroy",
            Self::EDisappearTransferLeave => "EDisappearTransferLeave",
            Self::EDisappearTransferPassLineLeave => "EDisappearTransferPassLineLeave",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EDisappearType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EDisappearNormal",
            "EDisappearDead",
            "EDisappearDestroy",
            "EDisappearTransferLeave",
            "EDisappearTransferPassLineLeave",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EDisappearType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EDisappearNormal" => Ok(EDisappearType::EDisappearNormal),
                    "EDisappearDead" => Ok(EDisappearType::EDisappearDead),
                    "EDisappearDestroy" => Ok(EDisappearType::EDisappearDestroy),
                    "EDisappearTransferLeave" => Ok(EDisappearType::EDisappearTransferLeave),
                    "EDisappearTransferPassLineLeave" => Ok(EDisappearType::EDisappearTransferPassLineLeave),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EDungeonState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::DungeonStateNull => "DungeonStateNull",
            Self::DungeonStateActive => "DungeonStateActive",
            Self::DungeonStateReady => "DungeonStateReady",
            Self::DungeonStatePlaying => "DungeonStatePlaying",
            Self::DungeonStateEnd => "DungeonStateEnd",
            Self::DungeonStateSettlement => "DungeonStateSettlement",
            Self::DungeonStateVote => "DungeonStateVote",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EDungeonState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonStateNull",
            "DungeonStateActive",
            "DungeonStateReady",
            "DungeonStatePlaying",
            "DungeonStateEnd",
            "DungeonStateSettlement",
            "DungeonStateVote",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EDungeonState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DungeonStateNull" => Ok(EDungeonState::DungeonStateNull),
                    "DungeonStateActive" => Ok(EDungeonState::DungeonStateActive),
                    "DungeonStateReady" => Ok(EDungeonState::DungeonStateReady),
                    "DungeonStatePlaying" => Ok(EDungeonState::DungeonStatePlaying),
                    "DungeonStateEnd" => Ok(EDungeonState::DungeonStateEnd),
                    "DungeonStateSettlement" => Ok(EDungeonState::DungeonStateSettlement),
                    "DungeonStateVote" => Ok(EDungeonState::DungeonStateVote),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EDungeonTimerDirection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::DungeonTimerDirectionDown => "DungeonTimerDirectionDown",
            Self::DungeonTimerDirectionUp => "DungeonTimerDirectionUp",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EDungeonTimerDirection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonTimerDirectionDown",
            "DungeonTimerDirectionUp",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EDungeonTimerDirection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DungeonTimerDirectionDown" => Ok(EDungeonTimerDirection::DungeonTimerDirectionDown),
                    "DungeonTimerDirectionUp" => Ok(EDungeonTimerDirection::DungeonTimerDirectionUp),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EDungeonTimerEffectType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Null => "EDungeonTimerEffectTypeNull",
            Self::Add => "EDungeonTimerEffectTypeAdd",
            Self::Sub => "EDungeonTimerEffectTypeSub",
            Self::Change => "EDungeonTimerEffectTypeChange",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EDungeonTimerEffectType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EDungeonTimerEffectTypeNull",
            "EDungeonTimerEffectTypeAdd",
            "EDungeonTimerEffectTypeSub",
            "EDungeonTimerEffectTypeChange",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EDungeonTimerEffectType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EDungeonTimerEffectTypeNull" => Ok(EDungeonTimerEffectType::Null),
                    "EDungeonTimerEffectTypeAdd" => Ok(EDungeonTimerEffectType::Add),
                    "EDungeonTimerEffectTypeSub" => Ok(EDungeonTimerEffectType::Sub),
                    "EDungeonTimerEffectTypeChange" => Ok(EDungeonTimerEffectType::Change),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EDungeonTimerTimerLookType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Default => "EDungeonTimerTimerLookTypeDefault",
            Self::Red => "EDungeonTimerTimerLookTypeRed",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EDungeonTimerTimerLookType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EDungeonTimerTimerLookTypeDefault",
            "EDungeonTimerTimerLookTypeRed",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EDungeonTimerTimerLookType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EDungeonTimerTimerLookTypeDefault" => Ok(EDungeonTimerTimerLookType::Default),
                    "EDungeonTimerTimerLookTypeRed" => Ok(EDungeonTimerTimerLookType::Red),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EDungeonTimerType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::DungeonTimerTypeNull => "DungeonTimerTypeNull",
            Self::DungeonTimerTypeRightCommon => "DungeonTimerTypeRightCommon",
            Self::DungeonTimerTypeMiddlerCommon => "DungeonTimerTypeMiddlerCommon",
            Self::DungeonTimerTypeHero => "DungeonTimerTypeHero",
            Self::DungeonTimerTypeWait => "DungeonTimerTypeWait",
            Self::DungeonTimerTypePrepare => "DungeonTimerTypePrepare",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EDungeonTimerType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonTimerTypeNull",
            "DungeonTimerTypeRightCommon",
            "DungeonTimerTypeMiddlerCommon",
            "DungeonTimerTypeHero",
            "DungeonTimerTypeWait",
            "DungeonTimerTypePrepare",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EDungeonTimerType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DungeonTimerTypeNull" => Ok(EDungeonTimerType::DungeonTimerTypeNull),
                    "DungeonTimerTypeRightCommon" => Ok(EDungeonTimerType::DungeonTimerTypeRightCommon),
                    "DungeonTimerTypeMiddlerCommon" => Ok(EDungeonTimerType::DungeonTimerTypeMiddlerCommon),
                    "DungeonTimerTypeHero" => Ok(EDungeonTimerType::DungeonTimerTypeHero),
                    "DungeonTimerTypeWait" => Ok(EDungeonTimerType::DungeonTimerTypeWait),
                    "DungeonTimerTypePrepare" => Ok(EDungeonTimerType::DungeonTimerTypePrepare),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EEntityType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::EntErrType => "EntErrType",
            Self::EntMonster => "EntMonster",
            Self::EntNpc => "EntNpc",
            Self::EntSceneObject => "EntSceneObject",
            Self::EntZone => "EntZone",
            Self::EntBullet => "EntBullet",
            Self::EntClientBullet => "EntClientBullet",
            Self::EntPet => "EntPet",
            Self::EntChar => "EntChar",
            Self::EntDummy => "EntDummy",
            Self::EntDrop => "EntDrop",
            Self::EntField => "EntField",
            Self::EntTrap => "EntTrap",
            Self::EntCollection => "EntCollection",
            Self::EntStaticObject => "EntStaticObject",
            Self::EntVehicle => "EntVehicle",
            Self::EntToy => "EntToy",
            Self::EntCommunityHouse => "EntCommunityHouse",
            Self::EntHouseItem => "EntHouseItem",
            Self::EntCount => "EntCount",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EEntityType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EntErrType",
            "EntMonster",
            "EntNpc",
            "EntSceneObject",
            "EntZone",
            "EntBullet",
            "EntClientBullet",
            "EntPet",
            "EntChar",
            "EntDummy",
            "EntDrop",
            "EntField",
            "EntTrap",
            "EntCollection",
            "EntStaticObject",
            "EntVehicle",
            "EntToy",
            "EntCommunityHouse",
            "EntHouseItem",
            "EntCount",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EEntityType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EntErrType" => Ok(EEntityType::EntErrType),
                    "EntMonster" => Ok(EEntityType::EntMonster),
                    "EntNpc" => Ok(EEntityType::EntNpc),
                    "EntSceneObject" => Ok(EEntityType::EntSceneObject),
                    "EntZone" => Ok(EEntityType::EntZone),
                    "EntBullet" => Ok(EEntityType::EntBullet),
                    "EntClientBullet" => Ok(EEntityType::EntClientBullet),
                    "EntPet" => Ok(EEntityType::EntPet),
                    "EntChar" => Ok(EEntityType::EntChar),
                    "EntDummy" => Ok(EEntityType::EntDummy),
                    "EntDrop" => Ok(EEntityType::EntDrop),
                    "EntField" => Ok(EEntityType::EntField),
                    "EntTrap" => Ok(EEntityType::EntTrap),
                    "EntCollection" => Ok(EEntityType::EntCollection),
                    "EntStaticObject" => Ok(EEntityType::EntStaticObject),
                    "EntVehicle" => Ok(EEntityType::EntVehicle),
                    "EntToy" => Ok(EEntityType::EntToy),
                    "EntCommunityHouse" => Ok(EEntityType::EntCommunityHouse),
                    "EntHouseItem" => Ok(EEntityType::EntHouseItem),
                    "EntCount" => Ok(EEntityType::EntCount),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EEquipEnchantType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::EEquipEnchantNone => "EEquipEnchantNone",
            Self::EEquipEnchantOrdinary => "EEquipEnchantOrdinary",
            Self::EEquipEnchantIntermediate => "EEquipEnchantIntermediate",
            Self::EEquipEnchantAdvanced => "EEquipEnchantAdvanced",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EEquipEnchantType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EEquipEnchantNone",
            "EEquipEnchantOrdinary",
            "EEquipEnchantIntermediate",
            "EEquipEnchantAdvanced",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EEquipEnchantType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EEquipEnchantNone" => Ok(EEquipEnchantType::EEquipEnchantNone),
                    "EEquipEnchantOrdinary" => Ok(EEquipEnchantType::EEquipEnchantOrdinary),
                    "EEquipEnchantIntermediate" => Ok(EEquipEnchantType::EEquipEnchantIntermediate),
                    "EEquipEnchantAdvanced" => Ok(EEquipEnchantType::EEquipEnchantAdvanced),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EErrorCode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ErrSuccess => "ErrSuccess",
            Self::ErrNoRecord => "ErrNoRecord",
            Self::ErrExceptionCancel => "ErrExceptionCancel",
            Self::ErrDbException => "ErrDBException",
            Self::ErrDbSeqException => "ErrDBSeqException",
            Self::ErrDbSceneException => "ErrDBSceneException",
            Self::ErrDbTokenException => "ErrDBTokenException",
            Self::ErrCancelled => "ErrCancelled",
            Self::ErrUnknownRpc => "ErrUnknownRpc",
            Self::ErrInvalidArgument => "ErrInvalidArgument",
            Self::ErrDeadlineExceeded => "ErrDeadlineExceeded",
            Self::ErrNotFound => "ErrNotFound",
            Self::ErrAlreadyExists => "ErrAlreadyExists",
            Self::ErrPermissionDenied => "ErrPermissionDenied",
            Self::ErrResourceExhausted => "ErrResourceExhausted",
            Self::ErrFailedPrecondition => "ErrFailedPrecondition",
            Self::ErrAborted => "ErrAborted",
            Self::ErrOutOfRange => "ErrOutOfRange",
            Self::ErrUnimplemented => "ErrUnimplemented",
            Self::ErrInternal => "ErrInternal",
            Self::ErrUnavailable => "ErrUnavailable",
            Self::ErrDataLoss => "ErrDataLoss",
            Self::ErrUnauthenticated => "ErrUnauthenticated",
            Self::ErrSystemMax => "ErrSystemMax",
            Self::ErrDbError => "ErrDBError",
            Self::ErrCreateOpenInfo => "ErrCreateOpenInfo",
            Self::ErrCreateAccountInfo => "ErrCreateAccountInfo",
            Self::ErrCreateCharInfo => "ErrCreateCharInfo",
            Self::ErrCreateAccountToken => "ErrCreateAccountToken",
            Self::ErrGetOpenInfo => "ErrGetOpenInfo",
            Self::ErrGetAccountInfo => "ErrGetAccountInfo",
            Self::ErrGetCharInfo => "ErrGetCharInfo",
            Self::ErrGetAccountToken => "ErrGetAccountToken",
            Self::ErrLoginInQueue => "ErrLoginInQueue",
            Self::ErrOtherLogin => "ErrOtherLogin",
            Self::ErrServerError => "ErrServerError",
            Self::ErrNoAccountInfo => "ErrNoAccountInfo",
            Self::ErrNoCharInfo => "ErrNoCharInfo",
            Self::ErrTokenExpired => "ErrTokenExpired",
            Self::ErrUpdateTokenFail => "ErrUpdateTokenFail",
            Self::ErrRegIntoSceneError => "ErrRegIntoSceneError",
            Self::ErrLoginTypeErr => "ErrLoginTypeErr",
            Self::ErrChangeMapErr => "ErrChangeMapErr",
            Self::ErrLoginPlatformErr => "ErrLoginPlatformErr",
            Self::ErrVersionErr => "ErrVersionErr",
            Self::ErrDelayOffLineKickOff => "ErrDelayOffLineKickOff",
            Self::ErrServiceLanguageError => "ErrServiceLanguageError",
            Self::NoEnterScene => "NoEnterScene",
            Self::ModIdNotOpen => "ModIDNotOpen",
            Self::ErrFaceData => "ErrFaceData",
            Self::ErrInitProfession => "ErrInitProfession",
            Self::ErrSceneCloseKickoff => "ErrSceneCloseKickoff",
            Self::ErrLoginReconnectKick => "ErrLoginReconnectKick",
            Self::ErrLoginErrorResume => "ErrLoginErrorResume",
            Self::ErrRepeatedLogin => "ErrRepeatedLogin",
            Self::ErrRestrictLogin => "ErrRestrictLogin",
            Self::ErrRestrictBlack => "ErrRestrictBlack",
            Self::ErrSdkVerifyFail => "ErrSdkVerifyFail",
            Self::ErrSdkTokenExpired => "ErrSdkTokenExpired",
            Self::ErrServerNotOpen => "ErrServerNotOpen",
            Self::ErrServerEndOpen => "ErrServerEndOpen",
            Self::ErrNormalKick => "ErrNormalKick",
            Self::ErrServerBusy => "ErrServerBusy",
            Self::ErrServerClose => "ErrServerClose",
            Self::ErrExitGame => "ErrExitGame",
            Self::ErrHopeKick => "ErrHopeKick",
            Self::ErrClientVersionError => "ErrClientVersionError",
            Self::ErrInvalidDeviceId => "ErrInvalidDeviceId",
            Self::ErrInvalidSystemType => "ErrInvalidSystemType",
            Self::ErrDeleteChar => "ErrDeleteChar",
            Self::ErrCancelDeleteChar => "ErrCancelDeleteChar",
            Self::ErrCancelDeleteCharIsDelete => "ErrCancelDeleteCharIsDelete",
            Self::ErrIntoSceneOwnerFail => "ErrIntoSceneOwnerFail",
            Self::ErrSceneQueueUp => "ErrSceneQueueUp",
            Self::ErrProtocolVersionErr => "ErrProtocolVersionErr",
            Self::ErrConfigVersionErr => "ErrConfigVersionErr",
            Self::ErrStateEventFailed => "ErrStateEventFailed",
            Self::ErrSelectCharDoing => "ErrSelectCharDoing",
            Self::ErrSelectCharDeleted => "ErrSelectCharDeleted",
            Self::ErrLoginChannelMax => "ErrLoginChannelMax",
            Self::ErrDeleteAccountKick => "ErrDeleteAccountKick",
            Self::ErrIsDeleteAccount => "ErrIsDeleteAccount",
            Self::ErrIsVersionKick => "ErrIsVersionKick",
            Self::ErrNotQqChnnel => "ErrNotQQChnnel",
            Self::ErrIncorrectLaunchPlatform => "ErrIncorrectLaunchPlatform",
            Self::ErrConditionWrong => "ErrConditionWrong",
            Self::ErrNotSupportLoginType => "ErrNotSupportLoginType",
            Self::ErrSceneNotExist => "ErrSceneNotExist",
            Self::ErrUserNotExist => "ErrUserNotExist",
            Self::ErrComponentNotExist => "ErrComponentNotExist",
            Self::ErrSceneConfigNotExist => "ErrSceneConfigNotExist",
            Self::ErrServiceNotExist => "ErrServiceNotExist",
            Self::ErrDataContainerNotExist => "ErrDataContainerNotExist",
            Self::ErrAsynchronousReturn => "ErrAsynchronousReturn",
            Self::ErrConfigNotExist => "ErrConfigNotExist",
            Self::ErrNotUser => "ErrNotUser",
            Self::ErrConfigError => "ErrConfigError",
            Self::ErrActorNotExist => "ErrActorNotExist",
            Self::ErrCutSceneAlreadyPlayed => "ErrCutSceneAlreadyPlayed",
            Self::ErrFunctionUnlock => "ErrFunctionUnlock",
            Self::ErrFunctionClosed => "ErrFunctionClosed",
            Self::ErrUserPlayerNotFurniturePackage => "ErrUserPlayerNotFurniturePackage",
            Self::ErrSysInnerError => "ErrSysInnerError",
            Self::ErrSysWebClientNull => "ErrSysWebClientNull",
            Self::ErrSysWebRequestTimeOut => "ErrSysWebRequestTimeOut",
            Self::ErrSysWebReturnError => "ErrSysWebReturnError",
            Self::ErrRequestTooFrequently => "ErrRequestTooFrequently",
            Self::ErrArgStringTooLong => "ErrArgStringTooLong",
            Self::ErrArgStringEmpty => "ErrArgStringEmpty",
            Self::ErrArgArrayTooBig => "ErrArgArrayTooBig",
            Self::ErrArgArrayEmpty => "ErrArgArrayEmpty",
            Self::ErrArgMapTooBig => "ErrArgMapTooBig",
            Self::ErrArgMapEmpty => "ErrArgMapEmpty",
            Self::ErrItemNotExist => "ErrItemNotExist",
            Self::ErrPackageNotExist => "ErrPackageNotExist",
            Self::ErrPackageFull => "ErrPackageFull",
            Self::ErrItemExpireTime => "ErrItemExpireTime",
            Self::ErrItemPackageGridNotEnough => "ErrItemPackageGridNotEnough",
            Self::ErrItemUuidError => "ErrItemUUIDError",
            Self::ErrItemNotEnough => "ErrItemNotEnough",
            Self::ErrOptTypeError => "ErrOptTypeError",
            Self::ErrItemInCoolDown => "ErrItemInCoolDown",
            Self::ErrItemNotUse => "ErrItemNotUse",
            Self::ErrItemEffectTypeError => "ErrItemEffectTypeError",
            Self::ErrItemParamError => "ErrItemParamError",
            Self::ErrItemAddBuffError => "ErrItemAddBuffError",
            Self::ErrItemAdd => "ErrItemAdd",
            Self::ErrUseItemState => "ErrUseItemState",
            Self::ErrBatchUse => "ErrBatchUse",
            Self::ErrFullSendMail => "ErrFullSendMail",
            Self::ErrItemNumZero => "ErrItemNumZero",
            Self::ErrItemSelectAwardIllegalNum => "ErrItemSelectAwardIllegalNum",
            Self::ErrItemSelectAwardIllegalPos => "ErrItemSelectAwardIllegalPos",
            Self::ErrItemSelectLimit => "ErrItemSelectLimit",
            Self::ErrItemPeriodGainExceeded => "ErrItemPeriodGainExceeded",
            Self::ErrItemNoRecycle => "ErrItemNoRecycle",
            Self::ErrItemRecycleBeyondMaxGrid => "ErrItemRecycleBeyondMaxGrid",
            Self::ErrItemRecycleBeyondMaxNum => "ErrItemRecycleBeyondMaxNum",
            Self::ErrItemRecycleIdNoMatchItemId => "ErrItemRecycleIdNoMatchItemId",
            Self::ErrItemRecycleIllegalId => "ErrItemRecycleIllegalId",
            Self::ErrItemLimitCount => "ErrItemLimitCount",
            Self::ErrItemFriendPontExceeded => "ErrItemFriendPontExceeded",
            Self::ErrItemToySingleEntUseExceeded => "ErrItemToySingleEntUseExceeded",
            Self::ErrItemToySceneUseExceeded => "ErrItemToySceneUseExceeded",
            Self::ErrItemToyUseInDisableArea => "ErrItemToyUseInDisableArea",
            Self::ErrItemToySingleCellUseExceeded => "ErrItemToySingleCellUseExceeded",
            Self::ErrMonthlyCardNotExists => "ErrMonthlyCardNotExists",
            Self::ErrMonthlyCardDataError => "ErrMonthlyCardDataError",
            Self::ErrMonthlyCardDayAwardReceived => "ErrMonthlyCardDayAwardReceived",
            Self::ErrMonthlyCardLimitCount => "ErrMonthlyCardLimitCount",
            Self::ErrCommunityNoHome => "ErrCommunityNoHome",
            Self::ErrNotHouseOwner => "ErrNotHouseOwner",
            Self::ErrHomeLandExisted => "ErrHomeLandExisted",
            Self::ErrHomeLandContentWrongful => "ErrHomeLandContentWrongful",
            Self::ErrHouseLivetogetherCd => "ErrHouseLivetogetherCD",
            Self::ErrHomeLandNotExisted => "ErrHomeLandNotExisted",
            Self::ErrHomeLandNotInScene => "ErrHomeLandNotInScene",
            Self::ErrHomeLandIsInvitation => "ErrHomeLandIsInvitation",
            Self::ErrHomeLandInsufficientAuthority => "ErrHomeLandInsufficientAuthority",
            Self::ErrHomeLandTransferRequestPending => "ErrHomeLandTransferRequestPending",
            Self::ErrHomeLandTransferRequestTimeout => "ErrHomeLandTransferRequestTimeout",
            Self::ErrHomeLandTransferCd => "ErrHomeLandTransferCD",
            Self::ErrHomelandTargetIsHasHome => "ErrHomelandTargetIsHasHome",
            Self::ErrHomelandTargetIsOwner => "ErrHomelandTargetIsOwner",
            Self::ErrHomelandNotOwnerCannotOperate => "ErrHomelandNotOwnerCannotOperate",
            Self::ErrHomeLandHasHouse => "ErrHomeLandHasHouse",
            Self::ErrHomeLandContentTooLong => "ErrHomeLandContentTooLong",
            Self::ErrHomeLandClutterNotExist => "ErrHomeLandClutterNotExist",
            Self::ErrHouseNameOrStatementCd => "ErrHouseNameOrStatementCD",
            Self::ErrHouseIntroductionStatementCd => "ErrHouseIntroductionStatementCD",
            Self::ErrCommunityBuildInvalidRecipeId => "ErrCommunityBuildInvalidRecipeId",
            Self::ErrCommunityBuildRecipeIsUnlock => "ErrCommunityBuildRecipeIsUnlock",
            Self::ErrCommunityBuildMax => "ErrCommunityBuildMax",
            Self::ErrCommunityBuildNoAuthority => "ErrCommunityBuildNoAuthority",
            Self::ErrCommunityNotBuildCannotCancel => "ErrCommunityNotBuildCannotCancel",
            Self::ErrCommunityBuildNotSelfCannotCancel => "ErrCommunityBuildNotSelfCannotCancel",
            Self::ErrCommunityNotBuildCannotAccelerate => "ErrCommunityNotBuildCannotAccelerate",
            Self::ErrCommunityBuildNotSelfCannotAccelerate => "ErrCommunityBuildNotSelfCannotAccelerate",
            Self::ErrCommunityBuildCannotAccelerate => "ErrCommunityBuildCannotAccelerate",
            Self::ErrCommunityBuildAlreadyAccelerate => "ErrCommunityBuildAlreadyAccelerate",
            Self::ErrCommunityBuildInDungeon => "ErrCommunityBuildInDungeon",
            Self::ErrCommunityBuildRecipeIsLock => "ErrCommunityBuildRecipeIsLock",
            Self::ErrCommunityBuildRecipeNotItemUnlock => "ErrCommunityBuildRecipeNotItemUnlock",
            Self::ErrCommunityBuildInvalidCount => "ErrCommunityBuildInvalidCount",
            Self::ErrCommunityNotBuildCannotReceive => "ErrCommunityNotBuildCannotReceive",
            Self::ErrCommunityCanNotBuild => "ErrCommunityCanNotBuild",
            Self::ErrHomeLandCohabitantLimit => "ErrHomeLandCohabitantLimit",
            Self::ErrHomeLandRootNotQuitCohabitant => "ErrHomeLandRootNotQuitCohabitant",
            Self::ErrHomeLandNotOwnerCannotQuitCohabitant => "ErrHomeLandNotOwnerCannotQuitCohabitant",
            Self::ErrHomeLandCohabitantIsExiting => "ErrHomeLandCohabitantIsExiting",
            Self::ErrHomeLandCohabitantNotExists => "ErrHomeLandCohabitantNotExists",
            Self::ErrHomeLandCohabitantExitRequestExists => "ErrHomeLandCohabitantExitRequestExists",
            Self::ErrHomeLandCohabitantDismiss => "ErrHomeLandCohabitantDismiss",
            Self::ErrHomeLandNotInvitation => "ErrHomeLandNotInvitation",
            Self::ErrHomeLandCohabitantInvitationTimeout => "ErrHomeLandCohabitantInvitationTimeout",
            Self::ErrHomeLandCohabitantNotFriend => "ErrHomeLandCohabitantNotFriend",
            Self::ErrHomeLandCohabitantFriendLevel => "ErrHomeLandCohabitantFriendLevel",
            Self::ErrHomeLandCohabitantLevel => "ErrHomeLandCohabitantLevel",
            Self::ErrHomeLandInviteCohabitantNotOwner => "ErrHomeLandInviteCohabitantNotOwner",
            Self::ErrCommunityWarehouseGridFull => "ErrCommunityWarehouseGridFull",
            Self::ErrCommunityWarehouseNoAuthority => "ErrCommunityWarehouseNoAuthority",
            Self::ErrCommunityWarehouseGridPosItemNoEnough => "ErrCommunityWarehouseGridPosItemNoEnough",
            Self::ErrHomeLandInsufficientFurniture => "ErrHomeLandInsufficientFurniture",
            Self::ErrCommunityWarehouseTakeOutCountLimit => "ErrCommunityWarehouseTakeOutCountLimit",
            Self::ErrHomeLandTaskNotExist => "ErrHomeLandTaskNotExist",
            Self::ErrHomeLandTaskTimeNotEnough => "ErrHomeLandTaskTimeNotEnough",
            Self::ErrHomeLandTaskAlreadyFinished => "ErrHomeLandTaskAlreadyFinished",
            Self::ErrHomeLandTaskItemNotEnough => "ErrHomeLandTaskItemNotEnough",
            Self::ErrHomeLandCurLevelError => "ErrHomeLandCurLevelError",
            Self::ErrHomeLandExpNotEnough => "ErrHomeLandExpNotEnough",
            Self::ErrHomeLandAlreadyMaxLevel => "ErrHomeLandAlreadyMaxLevel",
            Self::ErrHomeLandLevelLocked => "ErrHomeLandLevelLocked",
            Self::ErrHomeLandLevelConfigError => "ErrHomeLandLevelConfigError",
            Self::ErrCommunityEditorNotEditable => "ErrCommunityEditorNotEditable",
            Self::ErrCommunityEditorNotFurniture => "ErrCommunityEditorNotFurniture",
            Self::ErrCommunityEditorNotOutdoor => "ErrCommunityEditorNotOutdoor",
            Self::ErrCommunityEditorNotIndoor => "ErrCommunityEditorNotIndoor",
            Self::ErrCommunityEditorOverMax => "ErrCommunityEditorOverMax",
            Self::ErrCommunityEditorOverTypeMax => "ErrCommunityEditorOverTypeMax",
            Self::ErrCommunityEditorFurnitureNotEnough => "ErrCommunityEditorFurnitureNotEnough",
            Self::ErrCommunityEditorFurnitureNotExist => "ErrCommunityEditorFurnitureNotExist",
            Self::ErrCommunityEditorOverMaxGroup => "ErrCommunityEditorOverMaxGroup",
            Self::ErrCommunityEditorNoStructure => "ErrCommunityEditorNoStructure",
            Self::ErrCommunityEditorGroupMaxStructure => "ErrCommunityEditorGroupMaxStructure",
            Self::ErrCommunityEditorStructureInGroup => "ErrCommunityEditorStructureInGroup",
            Self::ErrCommunityEditorGroupNotExist => "ErrCommunityEditorGroupNotExist",
            Self::ErrCommunityEditorAlreadyExist => "ErrCommunityEditorAlreadyExist",
            Self::ErrHomeLandSellItemNotExist => "ErrHomeLandSellItemNotExist",
            Self::ErrHomeLandLeftNumNotEnough => "ErrHomeLandLeftNumNotEnough",
            Self::ErrHomeLandSellShopLocked => "ErrHomeLandSellShopLocked",
            Self::ErrHomeLandSeedExist => "ErrHomeLandSeedExist",
            Self::ErrHomeLandItemNotOwner => "ErrHomeLandItemNotOwner",
            Self::ErrHomeLandSeedStateError => "ErrHomeLandSeedStateError",
            Self::ErrHomeLandNoSeed => "ErrHomeLandNoSeed",
            Self::ErrHomeLandNoWater => "ErrHomeLandNoWater",
            Self::ErrHomeLandFertilizerMaxNumLimit => "ErrHomeLandFertilizerMaxNumLimit",
            Self::ErrHomeLandNotFertilize => "ErrHomeLandNotFertilize",
            Self::ErrHomeLandNotPollen => "ErrHomeLandNotPollen",
            Self::ErrHomeLandAlreadyPollen => "ErrHomeLandAlreadyPollen",
            Self::ErrHomeLandNotHarvest => "ErrHomeLandNotHarvest",
            Self::ErrHomeLandPickUpSinglePlayerLimit => "ErrHomeLandPickUpSinglePlayerLimit",
            Self::ErrHomeLandPickUpTotalLimit => "ErrHomeLandPickUpTotalLimit",
            Self::ErrHomeLandPickUpFlowerNotFinished => "ErrHomeLandPickUpFlowerNotFinished",
            Self::ErrHomeLandPickUpOwner => "ErrHomeLandPickUpOwner",
            Self::ErrHomeLandGainNotOwner => "ErrHomeLandGainNotOwner",
            Self::ErrHomeLandItemFullGrid => "ErrHomeLandItemFullGrid",
            Self::ErrHomeLandFurnitureFull => "ErrHomeLandFurnitureFull",
            Self::ErrComposeItemNotEnough => "ErrComposeItemNotEnough",
            Self::ErrComposeFailed => "ErrComposeFailed",
            Self::ErrRedemptionItemNotExist => "ErrRedemptionItemNotExist",
            Self::ErrRedemptionItemMaxCount => "ErrRedemptionItemMaxCount",
            Self::ErrRedemptionItemNotEnough => "ErrRedemptionItemNotEnough",
            Self::ErrRedemptionItemGender => "ErrRedemptionItemGender",
            Self::ErrAwardConfigNotFound => "ErrAwardConfigNotFound",
            Self::ErrAwardConfigWeightError => "ErrAwardConfigWeightError",
            Self::ErrAwardConfigLimitAndContentNotMatch => "ErrAwardConfigLimitAndContentNotMatch",
            Self::ErrAwardConfigContentSizeError => "ErrAwardConfigContentSizeError",
            Self::ErrAwardConfigContentRatesSizeError => "ErrAwardConfigContentRatesSizeError",
            Self::ErrAwardConfigContentWeightSizeError => "ErrAwardConfigContentWeightSizeError",
            Self::ErrAwardConfigGroupContentEmpty => "ErrAwardConfigGroupContentEmpty",
            Self::ErrAwardConfigGroupNumEmpty => "ErrAwardConfigGroupNumEmpty",
            Self::ErrAwardConfigGroupContentNoMatchGroupNum => "ErrAwardConfigGroupContentNoMatchGroupNum",
            Self::ErrAwardConfigNoRandomDrop => "ErrAwardConfigNoRandomDrop",
            Self::ErrAwardConfigNoSelectAward => "ErrAwardConfigNoSelectAward",
            Self::ErrAwardConfigSelfSelectContentNoItem => "ErrAwardConfigSelfSelectContentNoItem",
            Self::ErrAwardConfigWeightRateMustOne => "ErrAwardConfigWeightRateMustOne",
            Self::ErrAwardConfigGroupContentRandomNoMatch => "ErrAwardConfigGroupContentRandomNoMatch",
            Self::ErrAwardConfigGroupContentError => "ErrAwardConfigGroupContentError",
            Self::ErrAwardConfigPackageContentRandomNoMatch => "ErrAwardConfigPackageContentRandomNoMatch",
            Self::ErrAwardConfigLevelUpPackConfigPackageNoMatch => "ErrAwardConfigLevelUpPackConfigPackageNoMatch",
            Self::ErrAwardConfigProItemRuleNoMatch => "ErrAwardConfigProItemRuleNoMatch",
            Self::ErrAwardConfigPackageContentEmpty => "ErrAwardConfigPackageContentEmpty",
            Self::ErrAwardConfigDropContentSize => "ErrAwardConfigDropContentSize",
            Self::ErrAwardConfigDropContentNum => "ErrAwardConfigDropContentNum",
            Self::ErrAwardConfigGroupRateEmpty => "ErrAwardConfigGroupRateEmpty",
            Self::ErrAwardConfigGroupWeightEmpty => "ErrAwardConfigGroupWeightEmpty",
            Self::ErrAwardInnerError => "ErrAwardInnerError",
            Self::ErrAwardIllegalRandomType => "ErrAwardIllegalRandomType",
            Self::ErrAwardConditionNoMeet => "ErrAwardConditionNoMeet",
            Self::ErrAwardRandomTypeNone => "ErrAwardRandomTypeNone",
            Self::ErrAwardRandomTypeNoMatch => "ErrAwardRandomTypeNoMatch",
            Self::ErrAwardActorIsNull => "ErrAwardActorIsNull",
            Self::ErrEquipWashAttrNotExist => "ErrEquipWashAttrNotExist",
            Self::ErrNotEquipInCombat => "ErrNotEquipInCombat",
            Self::ErrEquipPart => "ErrEquipPart",
            Self::ErrComposeItemNotExist => "ErrComposeItemNotExist",
            Self::ErrPickupDropItemDistance => "ErrPickupDropItemDistance",
            Self::ErrPickupDropItemPackageFull => "ErrPickupDropItemPackageFull",
            Self::ErrPickupDropItemNoAuthority => "ErrPickupDropItemNoAuthority",
            Self::ErrLayerActorExist => "ErrLayerActorExist",
            Self::ErrTeamCreateHas => "ErrTeamCreateHas",
            Self::ErrTeamIllTarget => "ErrTeamIllTarget",
            Self::ErrTeamCreateTryLater => "ErrTeamCreateTryLater",
            Self::ErrTeamGetNo => "ErrTeamGetNo",
            Self::ErrTeamListEmpty => "ErrTeamListEmpty",
            Self::ErrTeamInner => "ErrTeamInner",
            Self::ErrTeamNoLeader => "ErrTeamNoLeader",
            Self::ErrTeamInMatch => "ErrTeamInMatch",
            Self::ErrTeamCustomizeTarget => "ErrTeamCustomizeTarget",
            Self::ErrTeamNoOwn => "ErrTeamNoOwn",
            Self::ErrTeamTickSelf => "ErrTeamTickSelf",
            Self::ErrTeamNoMem => "ErrTeamNoMem",
            Self::ErrTeamApplyingLeader => "ErrTeamApplyingLeader",
            Self::ErrTeamHasBeLeader => "ErrTeamHasBeLeader",
            Self::ErrTeamNoTransferSelf => "ErrTeamNoTransferSelf",
            Self::ErrTeamNoLeaderTransfer => "ErrTeamNoLeaderTransfer",
            Self::ErrTeamHasOwnTeam => "ErrTeamHasOwnTeam",
            Self::ErrTeamNoExist => "ErrTeamNoExist",
            Self::ErrTeamApplyInCd => "ErrTeamApplyInCD",
            Self::ErrTeamApplyExpire => "ErrTeamApplyExpire",
            Self::ErrTeamJoinOther => "ErrTeamJoinOther",
            Self::ErrTeamMemMax => "ErrTeamMemMax",
            Self::ErrTeamNoInvited => "ErrTeamNoInvited",
            Self::ErrTeamIsMatching => "ErrTeamIsMatching",
            Self::ErrTeamIllegalTag => "ErrTeamIllegalTag",
            Self::ErrTeamNoMatching => "ErrTeamNoMatching",
            Self::ErrTeamIllegalActivity => "ErrTeamIllegalActivity",
            Self::ErrTeamInActivity => "ErrTeamInActivity",
            Self::ErrTeamNoMeetCondition => "ErrTeamNoMeetCondition",
            Self::ErrTeamWaitVoting => "ErrTeamWaitVoting",
            Self::ErrTeamDoingActivity => "ErrTeamDoingActivity",
            Self::ErrTeamNoInVoting => "ErrTeamNoInVoting",
            Self::ErrTeamVoteEnd => "ErrTeamVoteEnd",
            Self::ErrTeamHasVoted => "ErrTeamHasVoted",
            Self::ErrTeamInviteCd => "ErrTeamInviteCD",
            Self::ErrTeamApplyLeadCd => "ErrTeamApplyLeadCD",
            Self::ErrTeamMoreMaxWorlds => "ErrTeamMoreMaxWorlds",
            Self::ErrTeamValidApplyInfo => "ErrTeamValidApplyInfo",
            Self::ErrTeamInMatchCancelCd => "ErrTeamInMatchCancelCD",
            Self::ErrTeamMatchFinished => "ErrTeamMatchFinished",
            Self::ErrTeamMatchWaitSec => "ErrTeamMatchWaitSec",
            Self::ErrTeamMemWorldFull => "ErrTeamMemWorldFull",
            Self::ErrTeamMemNotLeader => "ErrTeamMemNotLeader",
            Self::ErrTeamLeaderNotStaticScene => "ErrTeamLeaderNotStaticScene",
            Self::ErrTeamLeaderCallDoing => "ErrTeamLeaderCallDoing",
            Self::ErrTeamIllegalCallOperator => "ErrTeamIllegalCallOperator",
            Self::ErrTeamLeaderIllegalCallOperator => "ErrTeamLeaderIllegalCallOperator",
            Self::ErrTeamNoMemCall => "ErrTeamNoMemCall",
            Self::ErrTeamLeaderCallEnd => "ErrTeamLeaderCallEnd",
            Self::ErrTeamSameScene => "ErrTeamSameScene",
            Self::ErrTeamNotSameScene => "ErrTeamNotSameScene",
            Self::ErrTeamMemTooMore => "ErrTeamMemTooMore",
            Self::ErrTeamMemInDungeon => "ErrTeamMemInDungeon",
            Self::ErrTeamMemTooLess => "ErrTeamMemTooLess",
            Self::ErrTeamIllegalInviteType => "ErrTeamIllegalInviteType",
            Self::ErrTeamMemberNotInScene => "ErrTeamMemberNotInScene",
            Self::ErrTeamLeaderReadyCheckTimeNotReady => "ErrTeamLeaderReadyCheckTimeNotReady",
            Self::ErrTeamExistDungeonCheck => "ErrTeamExistDungeonCheck",
            Self::ErrTeamTargetMatchTalentLimit => "ErrTeamTargetMatchTalentLimit",
            Self::ErrTeamEditGroupNotAllowed => "ErrTeamEditGroupNotAllowed",
            Self::ErrTeamGroupNotExist => "ErrTeamGroupNotExist",
            Self::ErrTeamTargetNoMatchMemberType => "ErrTeamTargetNoMatchMemberType",
            Self::ErrDecomposeItemNotExist => "ErrDecomposeItemNotExist",
            Self::ErrDecomposeItemNotEnough => "ErrDecomposeItemNotEnough",
            Self::ErrRefineEnergyNotEnough => "ErrRefineEnergyNotEnough",
            Self::ErrRefineItemMaxCount => "ErrRefineItemMaxCount",
            Self::ErrRefineItemNotExist => "ErrRefineItemNotExist",
            Self::ErrRefineItemColumnNotUnlock => "ErrRefineItemColumnNotUnlock",
            Self::ErrRefineItemColumnUnlock => "ErrRefineItemColumnUnlock",
            Self::ErrRefineItemExist => "ErrRefineItemExist",
            Self::ErrEnergyLimitMax => "ErrEnergyLimitMax",
            Self::ErrRefineItemColumnNotEmpty => "ErrRefineItemColumnNotEmpty",
            Self::ErrProfessionNotExist => "ErrProfessionNotExist",
            Self::ErrModSlotNotUnlock => "ErrModSlotNotUnlock",
            Self::ErrChangeProfessionStateFail => "ErrChangeProfessionStateFail",
            Self::ErrChangeProfessionCdFail => "ErrChangeProfessionCDFail",
            Self::ErrProfessionSkinNotActive => "ErrProfessionSkinNotActive",
            Self::ErrProfessionSkinActive => "ErrProfessionSkinActive",
            Self::ErrProfessionNotUseSkin => "ErrProfessionNotUseSkin",
            Self::ErrProfessionSkillSkinActive => "ErrProfessionSkillSkinActive",
            Self::ErrProfessionSkillSkinNotActive => "ErrProfessionSkillSkinNotActive",
            Self::ErrProfessionSkillNotActive => "ErrProfessionSkillNotActive",
            Self::ErrCharOffline => "ErrCharOffline",
            Self::ErrUserDataBaseError => "ErrUserDataBaseError",
            Self::ErrCharGetFail => "ErrCharGetFail",
            Self::ErrAlreadyAlive => "ErrAlreadyAlive",
            Self::ErrReviveParam => "ErrReviveParam",
            Self::ErrStateIllegal => "ErrStateIllegal",
            Self::ErrStateNoChange => "ErrStateNoChange",
            Self::ErrReviveConsumeNotEnough => "ErrReviveConsumeNotEnough",
            Self::ErrReviveByOtherForbid => "ErrReviveByOtherForbid",
            Self::ErrReviveTimeNotArrived => "ErrReviveTimeNotArrived",
            Self::ErrReviveBossBattle => "ErrReviveBossBattle",
            Self::ErrReviveCountLimit => "ErrReviveCountLimit",
            Self::ErrReviveInDeadTp => "ErrReviveInDeadTp",
            Self::ErrDungeonPlayTypeError => "ErrDungeonPlayTypeError",
            Self::ErrDungeonNotExist => "ErrDungeonNotExist",
            Self::ErrDungeonCreateError => "ErrDungeonCreateError",
            Self::ErrCantChangeDungeon => "ErrCantChangeDungeon",
            Self::ErrDungeonLock => "ErrDungeonLock",
            Self::ErrPioneerFail => "ErrPioneerFail",
            Self::ErrAwardFail => "ErrAwardFail",
            Self::ErrGsNotEnough => "ErrGsNotEnough",
            Self::ErrQuestNotCompleted => "ErrQuestNotCompleted",
            Self::ErrDungeonNotClear => "ErrDungeonNotClear",
            Self::ErrConditionNotExist => "ErrConditionNotExist",
            Self::ErrAwardReceived => "ErrAwardReceived",
            Self::ErrCantRepeatedPlay => "ErrCantRepeatedPlay",
            Self::ErrNeedPassPreRoom => "ErrNeedPassPreRoom",
            Self::ErrDungeonEnterCountLimit => "ErrDungeonEnterCountLimit",
            Self::ErrDungeonScoreError => "ErrDungeonScoreError",
            Self::ErrDungeonRepeatedVote => "ErrDungeonRepeatedVote",
            Self::ErrDungeonChallengeAwardState => "ErrDungeonChallengeAwardState",
            Self::ErrDungeonChallengeAffixNotFound => "ErrDungeonChallengeAffixNotFound",
            Self::ErrDungeonStateNotActive => "ErrDungeonStateNotActive",
            Self::ErrDungeonCantVoteSelf => "ErrDungeonCantVoteSelf",
            Self::ErrDungeonPlayerNotEnough => "ErrDungeonPlayerNotEnough",
            Self::ErrDungeonPlayerFull => "ErrDungeonPlayerFull",
            Self::ErrDungeonCantHeroKey => "ErrDungeonCantHeroKey",
            Self::ErrDungeonNotSettlement => "ErrDungeonNotSettlement",
            Self::ErrDungeonNotFindRollItem => "ErrDungeonNotFindRollItem",
            Self::ErrDungeonCantRoll => "ErrDungeonCantRoll",
            Self::ErrDungeonRollFinish => "ErrDungeonRollFinish",
            Self::ErrDungeonSelectError => "ErrDungeonSelectError",
            Self::ErrDungeonAiModeError => "ErrDungeonAiModeError",
            Self::ErrDungeonTargetNotFinish => "ErrDungeonTargetNotFinish",
            Self::ErrDungeonTargetBeAward => "ErrDungeonTargetBeAward",
            Self::ErrDungeonSinglePlayerMore => "ErrDungeonSinglePlayerMore",
            Self::ErrDungeonAiGroupNotEnough => "ErrDungeonAiGroupNotEnough",
            Self::ErrDungeonNoPass => "ErrDungeonNoPass",
            Self::ErrDungeonCloseSceneId => "ErrDungeonCloseSceneId",
            Self::ErrDungeonEnterTypeError => "ErrDungeonEnterTypeError",
            Self::ErrDungeonActorCount => "ErrDungeonActorCount",
            Self::ErrDungeonDiffLocked => "ErrDungeonDiffLocked",
            Self::ErrDungeonPreBattleVoteCd => "ErrDungeonPreBattleVoteCd",
            Self::ErrDungeonBossInvalid => "ErrDungeonBossInvalid",
            Self::ErrDungeonNoUser => "ErrDungeonNoUser",
            Self::ErrDungeonUserInvalid => "ErrDungeonUserInvalid",
            Self::ErrDungeonAwardualification => "ErrDungeonAwardualification",
            Self::ErrDungeonAwardTriesLimit => "ErrDungeonAwardTriesLimit",
            Self::ErrFashionIsLimit => "ErrFashionIsLimit",
            Self::ErrFashionNotFound => "ErrFashionNotFound",
            Self::ErrFashionSlotEmpty => "ErrFashionSlotEmpty",
            Self::ErrFashionIdNotFound => "ErrFashionIDNotFound",
            Self::ErrFashionLock => "ErrFashionLock",
            Self::ErrFashCollectionAwardAlread => "ErrFashCollectionAwardAlread",
            Self::ErrFashCollectionScoreNotEnough => "ErrFashCollectionScoreNotEnough",
            Self::ErrFashCollectionAwardAlreadMonth => "ErrFashCollectionAwardAlreadMonth",
            Self::ErrFashionAlreadUnlock => "ErrFashionAlreadUnlock",
            Self::ErrFashionAdvanceNotExist => "ErrFashionAdvanceNotExist",
            Self::ErrFashionBaseNotUnlock => "ErrFashionBaseNotUnlock",
            Self::ErrFashionAdvanceAlreadyUnlock => "ErrFashionAdvanceAlreadyUnlock",
            Self::ErrCameraNoExistAlbum => "ErrCameraNoExistAlbum",
            Self::ErrCameraBeyondPhotoNum => "ErrCameraBeyondPhotoNum",
            Self::ErrCameraBeyondAlumNum => "ErrCameraBeyondAlumNum",
            Self::ErrCameraNoAccessRight => "ErrCameraNoAccessRight",
            Self::ErrCameraNoExistPhoto => "ErrCameraNoExistPhoto",
            Self::ErrCameraBeyondWordNum => "ErrCameraBeyondWordNum",
            Self::ErrCameraPhotoNoInAlbum => "ErrCameraPhotoNoInAlbum",
            Self::ErrCameraInnerError => "ErrCameraInnerError",
            Self::ErrCameraIllegalRight => "ErrCameraIllegalRight",
            Self::ErrCameraNoExistChar => "ErrCameraNoExistChar",
            Self::ErrCameraNoDelCloudAlbum => "ErrCameraNoDelCloudAlbum",
            Self::ErrCameraBeyondMaxURlLen => "ErrCameraBeyondMaxURlLen",
            Self::ErrCameraBeyondMaxXmlLen => "ErrCameraBeyondMaxXMLLen",
            Self::ErrCameraBeyondMaxNameLen => "ErrCameraBeyondMaxNameLen",
            Self::ErrCameraIllegalUrl => "ErrCameraIllegalUrl",
            Self::ErrCameraRenderInfoEmpty => "ErrCameraRenderInfoEmpty",
            Self::ErrCameraBeyondPhotoMaxSize => "ErrCameraBeyondPhotoMaxSize",
            Self::ErrCameraIllegalPictureType => "ErrCameraIllegalPictureType",
            Self::ErrCameraTypeRepeated => "ErrCameraTypeRepeated",
            Self::ErrCameraWithoutOriginal => "ErrCameraWithoutOriginal",
            Self::ErrCameraWithoutThumbnailOrRender => "ErrCameraWithoutThumbnailOrRender",
            Self::ErrCameraPhotoNameEmpty => "ErrCameraPhotoNameEmpty",
            Self::ErrCameraPhotoNameOutMaxLen => "ErrCameraPhotoNameOutMaxLen",
            Self::ErrCameraAlbumNameEmpty => "ErrCameraAlbumNameEmpty",
            Self::ErrCameraPhotoHasDel => "ErrCameraPhotoHasDel",
            Self::ErrCameraSysInnerError => "ErrCameraSysInnerError",
            Self::ErrCameraIllegalPictureId => "ErrCameraIllegalPictureId",
            Self::ErrCameraBeyondMaxExtraLen => "ErrCameraBeyondMaxExtraLen",
            Self::ErrCameraNoIncludeOriginal => "ErrCameraNoIncludeOriginal",
            Self::ErrCameraNoDealingPhoto => "ErrCameraNoDealingPhoto",
            Self::ErrCameraNoDealingPhotoType => "ErrCameraNoDealingPhotoType",
            Self::ErrCameraNoAnyAlbum => "ErrCameraNoAnyAlbum",
            Self::ErrCameraNoPassReview => "ErrCameraNoPassReview",
            Self::ErrCameraPhotoMissImage => "ErrCameraPhotoMissImage",
            Self::ErrCameraWithoutThumbnail => "ErrCameraWithoutThumbnail",
            Self::ErrCameraBeyondMaxUploadTimes => "ErrCameraBeyondMaxUploadTimes",
            Self::ErrInvalidLifeProfessionId => "ErrInvalidLifeProfessionId",
            Self::ErrLifeProfessionIsUnlock => "ErrLifeProfessionIsUnlock",
            Self::ErrLifeProfessionMaxLevel => "ErrLifeProfessionMaxLevel",
            Self::ErrLifeProfessionLevelNotEnough => "ErrLifeProfessionLevelNotEnough",
            Self::ErrLifeProfessionLevelRewardGot => "ErrLifeProfessionLevelRewardGot",
            Self::ErrInvalidLifeProfessionSpecializationId => "ErrInvalidLifeProfessionSpecializationId",
            Self::ErrLifeProfessionSpecializationNotEnough => "ErrLifeProfessionSpecializationNotEnough",
            Self::ErrLifeProfessionSpecializationUpgradeError => "ErrLifeProfessionSpecializationUpgradeError",
            Self::ErrLifeProfessionPointNotEnough => "ErrLifeProfessionPointNotEnough",
            Self::ErrInvalidLifeProfessionTargetId => "ErrInvalidLifeProfessionTargetId",
            Self::ErrLifeProfessionTargetNotEnough => "ErrLifeProfessionTargetNotEnough",
            Self::ErrLifeProfessionRewardCanNotGet => "ErrLifeProfessionRewardCanNotGet",
            Self::ErrLifeProfessionEnergyChange => "ErrLifeProfessionEnergyChange",
            Self::ErrLifeProfessionRecipeIsUnlock => "ErrLifeProfessionRecipeIsUnlock",
            Self::ErrLifeProfessionRecipeNotExist => "ErrLifeProfessionRecipeNotExist",
            Self::ErrLifeProfessionRecipeNotUnlock => "ErrLifeProfessionRecipeNotUnlock",
            Self::ErrLifeProfessionMaxRdRecipeCount => "ErrLifeProfessionMaxRDRecipeCount",
            Self::ErrLifeProfessionWorkingNotEnd => "ErrLifeProfessionWorkingNotEnd",
            Self::ErrLifeProfessionAlreadyWorking => "ErrLifeProfessionAlreadyWorking",
            Self::ErrLifeProfessionNotWorking => "ErrLifeProfessionNotWorking",
            Self::ErrLifeProfessionWorkingIsEnd => "ErrLifeProfessionWorkingIsEnd",
            Self::ErrLifeProfessionUnActiveSpecialization => "ErrLifeProfessionUnActiveSpecialization",
            Self::ErrCurLevelConfigNotExist => "ErrCurLevelConfigNotExist",
            Self::ErrNeedBreakthrough => "ErrNeedBreakthrough",
            Self::ErrExperienceConfigNotExist => "ErrExperienceConfigNotExist",
            Self::ErrExperienceMismatch => "ErrExperienceMismatch",
            Self::ErrNotNeedToBreakthrough => "ErrNotNeedToBreakthrough",
            Self::ErrConsumeConfigError => "ErrConsumeConfigError",
            Self::ErrSkillNotExist => "ErrSkillNotExist",
            Self::ErrSkillLevelMax => "ErrSkillLevelMax",
            Self::ErrSkillLevelNotExist => "ErrSkillLevelNotExist",
            Self::ErrSkillConfigError => "ErrSkillConfigError",
            Self::ErrStarNotExist => "ErrStarNotExist",
            Self::ErrMaxStar => "ErrMaxStar",
            Self::ErrMaxLevel => "ErrMaxLevel",
            Self::ErrSkillLevelNotEnough => "ErrSkillLevelNotEnough",
            Self::ErrCanNotChangeActionState => "ErrCanNotChangeActionState",
            Self::ErrActionNotExist => "ErrActionNotExist",
            Self::ErrIsInteracting => "ErrIsInteracting",
            Self::ErrState => "ErrState",
            Self::ErrRequestExpired => "ErrRequestExpired",
            Self::ErrStateSetFailed => "ErrStateSetFailed",
            Self::ErrCollectIdError => "ErrCollectIdError",
            Self::ErrCollectStateFailed => "ErrCollectStateFailed",
            Self::ErrCollectActorErr => "ErrCollectActorErr",
            Self::ErrCollectOutRange => "ErrCollectOutRange",
            Self::ErrCollectConditionEquip => "ErrCollectConditionEquip",
            Self::ErrCollectConditionQuest => "ErrCollectConditionQuest",
            Self::ErrAlreadyCollected => "ErrAlreadyCollected",
            Self::ErrMailGetFailed => "ErrMailGetFailed",
            Self::ErrMailIllegality => "ErrMailIllegality",
            Self::ErrMailIsGet => "ErrMailIsGet",
            Self::ErrMailIsDel => "ErrMailIsDel",
            Self::ErrMailAcceptorEmpty => "ErrMailAcceptorEmpty",
            Self::ErrMailTokenInvalid => "ErrMailTokenInvalid",
            Self::ErrUnRegisterType => "ErrUnRegisterType",
            Self::ErrIndexNotFound => "ErrIndexNotFound",
            Self::ErrCantOpenTreasureBox => "ErrCantOpenTreasureBox",
            Self::ErrPersonalStateEnd => "ErrPersonalStateEnd",
            Self::ErrPersonalObjectStatus => "ErrPersonalObjectStatus",
            Self::ErrExp => "ErrExp",
            Self::ErrLevel => "ErrLevel",
            Self::ErrAward => "ErrAward",
            Self::ErrReceivedLevelAward => "ErrReceivedLevelAward",
            Self::ErrLevelNotEnough => "ErrLevelNotEnough",
            Self::ErrRoleLevelNoRewards => "ErrRoleLevelNoRewards",
            Self::ErrUnionNotHaveLimit => "ErrUnionNotHaveLimit",
            Self::ErrUnionIsNotMember => "ErrUnionIsNotMember",
            Self::ErrUnionOfficialNotExits => "ErrUnionOfficialNotExits",
            Self::ErrUnionOfficialTooMany => "ErrUnionOfficialTooMany",
            Self::ErrUnionHas => "ErrUnionHas",
            Self::ErrUnionReqCd => "ErrUnionReqCd",
            Self::ErrUnionReqHas => "ErrUnionReqHas",
            Self::ErrUnionFull => "ErrUnionFull",
            Self::ErrUnionFailed => "ErrUnionFailed",
            Self::ErrUnionNameWrongful => "ErrUnionNameWrongful",
            Self::ErrUnionNameUsed => "ErrUnionNameUsed",
            Self::ErrUnionNameOccupied => "ErrUnionNameOccupied",
            Self::ErrApplyMax => "ErrApplyMax",
            Self::ErrUnionChangeNameCd => "ErrUnionChangeNameCD",
            Self::ErrUnionNameSizeError => "ErrUnionNameSizeError",
            Self::ErrDeclarationSize => "ErrDeclarationSize",
            Self::ErrDeclarationError => "ErrDeclarationError",
            Self::ErrOfficialNameRepeat => "ErrOfficialNameRepeat",
            Self::ErrDeclarationCd => "ErrDeclarationCd",
            Self::ErrUnionInfoCd => "ErrUnionInfoCd",
            Self::ErrUnionNotExist => "ErrUnionNotExist",
            Self::ErrUnionIllegalConditionType => "ErrUnionIllegalConditionType",
            Self::ErrUnionRecruitSloganTooLong => "ErrUnionRecruitSloganTooLong",
            Self::ErrUnionRecruitDescriptionTooLong => "ErrUnionRecruitDescriptionTooLong",
            Self::ErrUnionCreateTooOften => "ErrUnionCreateTooOften",
            Self::ErrUnionTagNoExist => "ErrUnionTagNoExist",
            Self::ErrUnionIconTooMuch => "ErrUnionIconTooMuch",
            Self::ErrUnionGetListCd => "ErrUnionGetListCd",
            Self::ErrUnionBatchSearchUnionIdsTooMuch => "ErrUnionBatchSearchUnionIdsTooMuch",
            Self::ErrUnionBatchSearchCd => "ErrUnionBatchSearchCd",
            Self::ErrUnionGetCollectedIdsCd => "ErrUnionGetCollectedIdsCd",
            Self::ErrUnionBeyondMaxCollectedNum => "ErrUnionBeyondMaxCollectedNum",
            Self::ErrUnionIdHasCollected => "ErrUnionIdHasCollected",
            Self::ErrUnionIdNoCollected => "ErrUnionIdNoCollected",
            Self::ErrUnionActiveValueNotEnough => "ErrUnionActiveValueNotEnough",
            Self::ErrUnionIllegalActiveId => "ErrUnionIllegalActiveId",
            Self::ErrUnionTooShortForAwards => "ErrUnionTooShortForAwards",
            Self::ErrUnionHasActiveAwards => "ErrUnionHasActiveAwards",
            Self::ErrUnionNoJoin => "ErrUnionNoJoin",
            Self::ErrUnionOnlyEnterSelf => "ErrUnionOnlyEnterSelf",
            Self::ErrUnionNoUnlockScene => "ErrUnionNoUnlockScene",
            Self::ErrUnionBuildingMaxLevel => "ErrUnionBuildingMaxLevel",
            Self::ErrUnionBuildingUpgrading => "ErrUnionBuildingUpgrading",
            Self::ErrUnionBuildingUpgradeNoFinish => "ErrUnionBuildingUpgradeNoFinish",
            Self::ErrUnionPrefixBuildNoMeet => "ErrUnionPrefixBuildNoMeet",
            Self::ErrUnionExperienceNoEnough => "ErrUnionExperienceNoEnough",
            Self::ErrUnionMoneyNoEnough => "ErrUnionMoneyNoEnough",
            Self::ErrUnionBuildingNoUpgrading => "ErrUnionBuildingNoUpgrading",
            Self::ErrUnionSpeedUpItemNoEnough => "ErrUnionSpeedUpItemNoEnough",
            Self::ErrUnionSpeedUpTimesOut => "ErrUnionSpeedUpTimesOut",
            Self::ErrUnionTryLater => "ErrUnionTryLater",
            Self::ErrUnionSpeedUpLevelError => "ErrUnionSpeedUpLevelError",
            Self::ErrUnionUpgradeHasCompleted => "ErrUnionUpgradeHasCompleted",
            Self::ErrUnionIllegalBuildIdLv => "ErrUnionIllegalBuildIdLv",
            Self::ErrUnionBeyMaxCount => "ErrUnionBeyMaxCount",
            Self::ErrUnionUserNoApply => "ErrUnionUserNoApply",
            Self::ErrUnionNoOneKeyNoMuch => "ErrUnionNoOneKeyNoMuch",
            Self::ErrUnionActivityNotStart => "ErrUnionActivityNotStart",
            Self::ErrUnionActivityNotProgress => "ErrUnionActivityNotProgress",
            Self::ErrUnionActivityAwardGet => "ErrUnionActivityAwardGet",
            Self::ErrUnionActivityNotEnjoy => "ErrUnionActivityNotEnjoy",
            Self::ErrUnionCreateTimeTooShort => "ErrUnionCreateTimeTooShort",
            Self::ErrUnionFunctionLock => "ErrUnionFunctionLock",
            Self::ErrUnionEScreenLock => "ErrUnionEScreenLock",
            Self::ErrUnionEScreenPositionLock => "ErrUnionEScreenPositionLock",
            Self::ErrUnionEScreenNoSet => "ErrUnionEScreenNoSet",
            Self::ErrUnionEScreenPositionNoSet => "ErrUnionEScreenPositionNoSet",
            Self::ErrUnionEffectGridLock => "ErrUnionEffectGridLock",
            Self::ErrUnionEffectIdLock => "ErrUnionEffectIdLock",
            Self::ErrUnionEffectPosNoSet => "ErrUnionEffectPosNoSet",
            Self::ErrUnionEffectPosHasEnd => "ErrUnionEffectPosHasEnd",
            Self::ErrUnionCrowFuncHasEnd => "ErrUnionCrowFuncHasEnd",
            Self::ErrUnionCrowFuncPosHasUsed => "ErrUnionCrowFuncPosHasUsed",
            Self::ErrUnionCrowFuncHasJoined => "ErrUnionCrowFuncHasJoined",
            Self::ErrUnionCrowFuncNoBegin => "ErrUnionCrowFuncNoBegin",
            Self::ErrUnionNoFinishBaseBuilding => "ErrUnionNoFinishBaseBuilding",
            Self::ErrUnionCrowFuncIllegalFuncPos => "ErrUnionCrowFuncIllegalFuncPos",
            Self::ErrUnionEScreenBeyondMaxTimes => "ErrUnionEScreenBeyondMaxTimes",
            Self::ErrUnionTargetFunctionLock => "ErrUnionTargetFunctionLock",
            Self::ErrUnionNoMeet => "ErrUnionNoMeet",
            Self::ErrUnionActivityAwardCd => "ErrUnionActivityAwardCd",
            Self::ErrUnionManagerNoKicked => "ErrUnionManagerNoKicked",
            Self::ErrUnionDanceNoBegin => "ErrUnionDanceNoBegin",
            Self::ErrUnionDanceEnd => "ErrUnionDanceEnd",
            Self::ErrUnionDanceDrawnBox => "ErrUnionDanceDrawnBox",
            Self::ErrUnionDanceBoxDrawn => "ErrUnionDanceBoxDrawn",
            Self::ErrUnionDanceNoDanceId => "ErrUnionDanceNoDanceId",
            Self::ErrUnionNoJoinDance => "ErrUnionNoJoinDance",
            Self::ErrUnionDanceNoDancing => "ErrUnionDanceNoDancing",
            Self::ErrUnionRejectInvite => "ErrUnionRejectInvite",
            Self::ErrUnionActivityHuntEnd => "ErrUnionActivityHuntEnd",
            Self::ErrUnionApplyListFull => "ErrUnionApplyListFull",
            Self::ErrUionApplyListExist => "ErrUionApplyListExist",
            Self::ErrUnionGroupIvalid => "ErrUnionGroupIvalid",
            Self::ErrRepeatedRequest => "ErrRepeatedRequest",
            Self::ErrHasBeenBlackened => "ErrHasBeenBlackened",
            Self::ErrNotFoundCharInfo => "ErrNotFoundCharInfo",
            Self::ErrInner => "ErrInner",
            Self::ErrParam => "ErrParam",
            Self::ErrSetShowPicture => "ErrSetShowPicture",
            Self::ErrSetSignature => "ErrSetSignature",
            Self::ErrSetHobbyMark => "ErrSetHobbyMark",
            Self::ErrSetTimeMark => "ErrSetTimeMark",
            Self::ErrSetRemind => "ErrSetRemind",
            Self::ErrSetTop => "ErrSetTop",
            Self::ErrAddFriend => "ErrAddFriend",
            Self::ErrSetProcessed => "ErrSetProcessed",
            Self::ErrSetRemark => "ErrSetRemark",
            Self::ErrDeleteFriend => "ErrDeleteFriend",
            Self::ErrNotFoundGroup => "ErrNotFoundGroup",
            Self::ErrNotExistInGroup => "ErrNotExistInGroup",
            Self::ErrChangeGroup => "ErrChangeGroup",
            Self::ErrPersonalState => "ErrPersonalState",
            Self::ErrOtherFriendMax => "ErrOtherFriendMax",
            Self::ErrCurFriendMax => "ErrCurFriendMax",
            Self::ErrConfig => "ErrConfig",
            Self::ErrAlreadyFriend => "ErrAlreadyFriend",
            Self::ErrSearchSelf => "ErrSearchSelf",
            Self::ErrSuggestionCd => "ErrSuggestionCd",
            Self::ErrGroupMax => "ErrGroupMax",
            Self::ErrGroupNotExist => "ErrGroupNotExist",
            Self::ErrGroupNameEmpty => "ErrGroupNameEmpty",
            Self::ErrIllegalCharacter => "ErrIllegalCharacter",
            Self::ErrStringMax => "ErrStringMax",
            Self::ErrOtherApplicationMax => "ErrOtherApplicationMax",
            Self::ErrFriendlinessAwardHasRecord => "ErrFriendlinessAwardHasRecord",
            Self::ErrFriendlinessLevelLowAwardLevel => "ErrFriendlinessLevelLowAwardLevel",
            Self::ErrFriendBeyondAllFriendNum => "ErrFriendBeyondAllFriendNum",
            Self::ErrFriendIsNoUserFriend => "ErrFriendIsNoUserFriend",
            Self::ErrFriendlinessIllegalAwardLevel => "ErrFriendlinessIllegalAwardLevel",
            Self::ErrFriendlinessLevelAwardIsEmpty => "ErrFriendlinessLevelAwardIsEmpty",
            Self::ErrFriendBeBlackenedByTarget => "ErrFriendBeBlackenedByTarget",
            Self::ErrFriendApplyEachOther => "ErrFriendApplyEachOther",
            Self::ErrFriendCallBySmallerCharId => "ErrFriendCallBySmallerCharId",
            Self::ErrFriendCallByBiggerCharId => "ErrFriendCallByBiggerCharId",
            Self::ErrFriendBeBlackenedBySmaller => "ErrFriendBeBlackenedBySmaller",
            Self::ErrFriendBeBlackenedByBigger => "ErrFriendBeBlackenedByBigger",
            Self::ErrFriendNoApply => "ErrFriendNoApply",
            Self::ErrFriendApplySelf => "ErrFriendApplySelf",
            Self::ErrUserNameFormat => "ErrUserNameFormat",
            Self::ErrFriendGetBaseTooOften => "ErrFriendGetBaseTooOften",
            Self::ErrFriendOnlyGetSelfBaseInfo => "ErrFriendOnlyGetSelfBaseInfo",
            Self::ErrActorGetFailed => "ErrActorGetFailed",
            Self::ErrPivotIsActive => "ErrPivotIsActive",
            Self::ErrPivotIsNotActive => "ErrPivotIsNotActive",
            Self::ErrBreakPointIsGet => "ErrBreakPointIsGet",
            Self::ErrActorIsNotPivot => "ErrActorIsNotPivot",
            Self::ErrActorIsNotBreakPoint => "ErrActorIsNotBreakPoint",
            Self::ErrActorIsBreakPointNotFull => "ErrActorIsBreakPointNotFull",
            Self::ErrPivotRewardIsGiven => "ErrPivotRewardIsGiven",
            Self::ErrNotInsight => "ErrNotInsight",
            Self::ErrLearnSkillFail => "ErrLearnSkillFail",
            Self::ErrRemoveSkillFail => "ErrRemoveSkillFail",
            Self::ErrUpdateSkillFail => "ErrUpdateSkillFail",
            Self::ErrSkillOperatorType => "ErrSkillOperatorType",
            Self::ErrContainerOperator => "ErrContainerOperator",
            Self::ErrExchangeFail => "ErrExchangeFail",
            Self::ErrExchangeFailInCombat => "ErrExchangeFailInCombat",
            Self::ErrAvatarBeyondMaxPictureSize => "ErrAvatarBeyondMaxPictureSize",
            Self::ErrGetTokenFailed => "ErrGetTokenFailed",
            Self::ErrPictureVerifyFailed => "ErrPictureVerifyFailed",
            Self::ErrPictureIllegalType => "ErrPictureIllegalType",
            Self::ErrPictureErrorInfo => "ErrPictureErrorInfo",
            Self::ErrPictureSizeInconsistent => "ErrPictureSizeInconsistent",
            Self::ErrPictureFuncTypeIllegal => "ErrPictureFuncTypeIllegal",
            Self::ErrPictureCallBackJudgeIllegal => "ErrPictureCallBackJudgeIllegal",
            Self::ErrPictureVerifyNoPass => "ErrPictureVerifyNoPass",
            Self::ErrPictureVerifyBackParamIllegal => "ErrPictureVerifyBackParamIllegal",
            Self::ErrPictureCallBackParamIllegal => "ErrPictureCallBackParamIllegal",
            Self::ErrPictureIllegalId => "ErrPictureIllegalId",
            Self::ErrPictureCosErrors => "ErrPictureCosErrors",
            Self::ErrPictureInnerSysErr => "ErrPictureInnerSysErr",
            Self::ErrPictureNoSetEnvCosSecretId => "ErrPictureNoSetEnvCosSecretId",
            Self::ErrPictureNoSetEnvCosSecretKey => "ErrPictureNoSetEnvCosSecretKey",
            Self::ErrPictureCheckInMachineLocked => "ErrPictureCheckInMachineLocked",
            Self::ErrPictureNoTryOutItem => "ErrPictureNoTryOutItem",
            Self::ErrPictureNoUploadItem => "ErrPictureNoUploadItem",
            Self::ErrPictureNoUnion => "ErrPictureNoUnion",
            Self::ErrNameSizeError => "ErrNameSizeError",
            Self::ErrSensitiveContent => "ErrSensitiveContent",
            Self::ErrChangeNameFail => "ErrChangeNameFail",
            Self::ErrChangeNameCardNotEnough => "ErrChangeNameCardNotEnough",
            Self::ErrChangeSameName => "ErrChangeSameName",
            Self::ErrCheckMuteWordsFailed => "ErrCheckMuteWordsFailed",
            Self::ErrCheckMuteWordsEmpty => "ErrCheckMuteWordsEmpty",
            Self::ErrChangeShowIdFail => "ErrChangeShowIdFail",
            Self::ErrChangeShowIdDuplicated => "ErrChangeShowIdDuplicated",
            Self::ErrChangeShowIdCardNotEnough => "ErrChangeShowIdCardNotEnough",
            Self::ErrFaceItemLock => "ErrFaceItemLock",
            Self::ErrFaceItemGender => "ErrFaceItemGender",
            Self::ErrFaceNoUploading => "ErrFaceNoUploading",
            Self::ErrFaceNoSupportFileSuffix => "ErrFaceNoSupportFileSuffix",
            Self::ErrFaceFileSuffixEmpty => "ErrFaceFileSuffixEmpty",
            Self::ErrFaceIllegalCosKey => "ErrFaceIllegalCosKey",
            Self::ErrFaceParseSuffixFailed => "ErrFaceParseSuffixFailed",
            Self::ErrFaceParseShortGuidFailed => "ErrFaceParseShortGuidFailed",
            Self::ErrProficiencyNeedUnlock => "ErrProficiencyNeedUnlock",
            Self::ErrProficiencyUnlock => "ErrProficiencyUnlock",
            Self::ErrUnlockItemNotEnough => "ErrUnlockItemNotEnough",
            Self::ErrTaskNotFinish => "ErrTaskNotFinish",
            Self::ErrStickerAwardIsGet => "ErrStickerAwardIsGet",
            Self::ErrBookAwardIsGet => "ErrBookAwardIsGet",
            Self::ErrInCd => "ErrInCd",
            Self::ErrMoneyNotEnough => "ErrMoneyNotEnough",
            Self::ErrShopItemCantBuy => "ErrShopItemCantBuy",
            Self::ErrShopBuyBusy => "ErrShopBuyBusy",
            Self::ErrPaymentConfigNotFound => "ErrPaymentConfigNotFound",
            Self::ErrRefreshShopCountExceed => "ErrRefreshShopCountExceed",
            Self::ErrShopCouponNotEnough => "ErrShopCouponNotEnough",
            Self::ErrShopCouponLimitNum => "ErrShopCouponLimitNum",
            Self::ErrShopCantBuyNoPrice => "ErrShopCantBuyNoPrice",
            Self::ErrNotFoundMonster => "ErrNotFoundMonster",
            Self::ErrNotMonster => "ErrNotMonster",
            Self::ErrMonsterUnlockExist => "ErrMonsterUnlockExist",
            Self::ErrMonsterAwardIsGet => "ErrMonsterAwardIsGet",
            Self::ErrMonsterTargetNotFinish => "ErrMonsterTargetNotFinish",
            Self::ErrDropTypeNotSupport => "ErrDropTypeNotSupport",
            Self::ErrCounterNotEnough => "ErrCounterNotEnough",
            Self::ErrDropItemAlreadyPicked => "ErrDropItemAlreadyPicked",
            Self::ErrInteractionDoing => "ErrInteractionDoing",
            Self::ErrInteractionCondition => "ErrInteractionCondition",
            Self::ErrInteractionNotMore => "ErrInteractionNotMore",
            Self::ErrInteractionExistPos => "ErrInteractionExistPos",
            Self::ErrInteractionNotExist => "ErrInteractionNotExist",
            Self::ErrInteractionEntityNotExist => "ErrInteractionEntityNotExist",
            Self::ErrInteractionHandleNotExist => "ErrInteractionHandleNotExist",
            Self::ErrInteractionType => "ErrInteractionType",
            Self::ErrInteractionBan => "ErrInteractionBan",
            Self::ErrInteractionConfig => "ErrInteractionConfig",
            Self::ErrInteractionNotOneself => "ErrInteractionNotOneself",
            Self::ErrInteractionDistance => "ErrInteractionDistance",
            Self::ErrShowPieceIllegalPieceType => "ErrShowPieceIllegalPieceType",
            Self::ErrShowPieceIllegalPieceId => "ErrShowPieceIllegalPieceId",
            Self::ErrShowPieceNoInOftenUseList => "ErrShowPieceNoInOftenUseList",
            Self::ErrShowPieceNoUnlockList => "ErrShowPieceNoUnlockList",
            Self::ErrShowPieceRoulettePositionNoSet => "ErrShowPieceRoulettePositionNoSet",
            Self::ErrShowPieceBeyondOftenUseMaxLen => "ErrShowPieceBeyondOftenUseMaxLen",
            Self::ErrShowPieceBeyondOftenRoulettePositionNum => "ErrShowPieceBeyondOftenRoulettePositionNum",
            Self::ErrShowPieceNoCommonPiece => "ErrShowPieceNoCommonPiece",
            Self::ErrShowPieceNoTakeOn => "ErrShowPieceNoTakeOn",
            Self::ErrProfessionActivated => "ErrProfessionActivated",
            Self::ErrProfessionNotHas => "ErrProfessionNotHas",
            Self::ErrProfessionSlotErr => "ErrProfessionSlotErr",
            Self::ErrProfessionRemoveErr => "ErrProfessionRemoveErr",
            Self::ErrProfessionChangePlanFail => "ErrProfessionChangePlanFail",
            Self::ErrProfessionStarConfigNotExist => "ErrProfessionStarConfigNotExist",
            Self::ErrProfessionStarNodeUnlock => "ErrProfessionStarNodeUnlock",
            Self::ErrProfessionStarNodeNotUnlock => "ErrProfessionStarNodeNotUnlock",
            Self::ErrProfessionReplaceSkillNotExist => "ErrProfessionReplaceSkillNotExist",
            Self::ErrProfessionUpgradeNotGreaterCurLevel => "ErrProfessionUpgradeNotGreaterCurLevel",
            Self::ErrProfessionProfessionBeForged => "ErrProfessionProfessionBeForged",
            Self::ErrProfessionSlotTwoNotUnlock => "ErrProfessionSlotTwoNotUnlock",
            Self::ErrProfessionSkillAlreadyActive => "ErrProfessionSkillAlreadyActive",
            Self::ErrProfessionSkillRemodelLevelWrong => "ErrProfessionSkillRemodelLevelWrong",
            Self::ErrAoyiSkillAlreadyActive => "ErrAoyiSkillAlreadyActive",
            Self::ErrAoyiSkillRemodelConfigNotExist => "ErrAoyiSkillRemodelConfigNotExist",
            Self::ErrAoyiSkillRemodelLevelWrong => "ErrAoyiSkillRemodelLevelWrong",
            Self::ErrProfessionEquipInCombat => "ErrProfessionEquipInCombat",
            Self::ErrProfessionSwitchInCombat => "ErrProfessionSwitchInCombat",
            Self::ErrProfessionDungeonNotAllowSwitch => "ErrProfessionDungeonNotAllowSwitch",
            Self::ErrTalentIllegalTalentPoolId => "ErrTalentIllegalTalentPoolId",
            Self::ErrTalentBeyondCurTalentMaxPlanNum => "ErrTalentBeyondCurTalentMaxPlanNum",
            Self::ErrTalentPoolNoActive => "ErrTalentPoolNoActive",
            Self::ErrTalentPlanNoActive => "ErrTalentPlanNoActive",
            Self::ErrTalentIllegalTalentId => "ErrTalentIllegalTalentId",
            Self::ErrTalentTalentHasUnlocked => "ErrTalentTalentHasUnlocked",
            Self::ErrTalentTalentNoUnlocked => "ErrTalentTalentNoUnlocked",
            Self::ErrTalentChangeLvPassiveTalentMoreThanInPool => "ErrTalentChangeLvPassiveTalentMoreThanInPool",
            Self::ErrTalentRepeatedTalentId => "ErrTalentRepeatedTalentId",
            Self::ErrTalentNoPoolPassiveTalent => "ErrTalentNoPoolPassiveTalent",
            Self::ErrTalentTalentPointsNoEnough => "ErrTalentTalentPointsNoEnough",
            Self::ErrTalentPassiveTalentListNoEmpty => "ErrTalentPassiveTalentListNoEmpty",
            Self::ErrTalentIllegalTalentLevel => "ErrTalentIllegalTalentLevel",
            Self::ErrTalentNoMeetUpgradeCondition => "ErrTalentNoMeetUpgradeCondition",
            Self::ErrTalentNoSupportDownLevelNow => "ErrTalentNoSupportDownLevelNow",
            Self::ErrTalentNoMeetPrevTalentLv => "ErrTalentNoMeetPrevTalentLv",
            Self::ErrTalentNoMeetPrevTalentPoint => "ErrTalentNoMeetPrevTalentPoint",
            Self::ErrTalentTreeNodeBdExclusive => "ErrTalentTreeNodeBDExclusive",
            Self::ErrTalentTotalTalentPointNotEnough => "ErrTalentTotalTalentPointNotEnough",
            Self::ErrTalentPreTalentNodeNotActivated => "ErrTalentPreTalentNodeNotActivated",
            Self::ErrTalentResetTalentInCombat => "ErrTalentResetTalentInCombat",
            Self::ErrCookBookNotExist => "ErrCookBookNotExist",
            Self::ErrCookFoodNotEnough => "ErrCookFoodNotEnough",
            Self::ErrCookTypeMore => "ErrCookTypeMore",
            Self::ErrCookCountMore => "ErrCookCountMore",
            Self::ErrCookHasBook => "ErrCookHasBook",
            Self::ErrCookMaterialNotMatch => "ErrCookMaterialNotMatch",
            Self::ErrChatIllegalPrivateChatTarget => "ErrChatIllegalPrivateChatTarget",
            Self::ErrChatInTargetBlockList => "ErrChatInTargetBlockList",
            Self::ErrChatSendMsgBeyondMaxWords => "ErrChatSendMsgBeyondMaxWords",
            Self::ErrChatWorldChannelIdIsZero => "ErrChatWorldChannelIdIsZero",
            Self::ErrChatWorldChannelIdBeyondMaxId => "ErrChatWorldChannelIdBeyondMaxId",
            Self::ErrChatIllegalChannelType => "ErrChatIllegalChannelType",
            Self::ErrChatIllegalMsgType => "ErrChatIllegalMsgType",
            Self::ErrChatNoInGoalChannel => "ErrChatNoInGoalChannel",
            Self::ErrChatNeedConfigIdNotZero => "ErrChatNeedConfigIdNotZero",
            Self::ErrChatNeedMsgTextNotEmpty => "ErrChatNeedMsgTextNotEmpty",
            Self::ErrChatSendCdNoEnd => "ErrChatSendCdNoEnd",
            Self::ErrChatRecordListIsEmpty => "ErrChatRecordListIsEmpty",
            Self::ErrChatTargetNotInPrivateList => "ErrChatTargetNotInPrivateList",
            Self::ErrChatMsgIdMoreThanMaxReadMsgId => "ErrChatMsgIdMoreThanMaxReadMsgId",
            Self::ErrChatBeyondBlockListLimit => "ErrChatBeyondBlockListLimit",
            Self::ErrChatWorldChannelIdBeyondMaxNum => "ErrChatWorldChannelIdBeyondMaxNum",
            Self::ErrChatBeyondMaxRecordId => "ErrChatBeyondMaxRecordId",
            Self::ErrChatNoCreatePrivateSession => "ErrChatNoCreatePrivateSession",
            Self::ErrChatPrivateSessionHasExit => "ErrChatPrivateSessionHasExit",
            Self::ErrChatBeBan => "ErrChatBeBan",
            Self::ErrChatFileIdTooLong => "ErrChatFileIdTooLong",
            Self::ErrChatFileIdEmpty => "ErrChatFileIdEmpty",
            Self::ErrChatMsgInfoEmpty => "ErrChatMsgInfoEmpty",
            Self::ErrChatNoShareChannel => "ErrChatNoShareChannel",
            Self::ErrChatIllegalShareType => "ErrChatIllegalShareType",
            Self::ErrChatIllegalHolderType => "ErrChatIllegalHolderType",
            Self::ErrChatNoSupportShareType => "ErrChatNoSupportShareType",
            Self::ErrChatShareTpeNoChatId => "ErrChatShareTpeNoChatId",
            Self::ErrChatShareNoFishRank => "ErrChatShareNoFishRank",
            Self::ErrChatLevelLimit => "ErrChatLevelLimit",
            Self::ErrChatNoFoundBlockListLimit => "ErrChatNoFoundBlockListLimit",
            Self::ErrTalentModTalentTagNotExist => "ErrTalentModTalentTagNotExist",
            Self::ErrTextCheckForbidden => "ErrTextCheckForbidden",
            Self::ErrTextCheckNoSceneType => "ErrTextCheckNoSceneType",
            Self::ErrTextCheckIllegal => "ErrTextCheckIllegal",
            Self::ErrTextCheckHttpError => "ErrTextCheckHttpError",
            Self::ErrTextCheckTooManyItems => "ErrTextCheckTooManyItems",
            Self::ErrConditionTimerOpen => "ErrConditionTimerOpen",
            Self::ErrConditionOpenServer => "ErrConditionOpenServer",
            Self::ErrSkillDisable => "ErrSkillDisable",
            Self::ErrSkillIsCd => "ErrSkillIsCD",
            Self::ErrSkillMaxPassiveCount => "ErrSkillMaxPassiveCount",
            Self::ErrSkillInit => "ErrSkillInit",
            Self::ErrSkillInfo => "ErrSkillInfo",
            Self::ErrUseSkillFightResInsufficient => "ErrUseSkillFightResInsufficient",
            Self::ErrUseSkillBuffNotEnough => "ErrUseSkillBuffNotEnough",
            Self::ErrUseSkillItemInsufficient => "ErrUseSkillItemInsufficient",
            Self::ErrUseSkillAttrInsufficient => "ErrUseSkillAttrInsufficient",
            Self::ErrUseSkillEnduranceInsufficient => "ErrUseSkillEnduranceInsufficient",
            Self::ErrUseSkillStateChange => "ErrUseSkillStateChange",
            Self::ErrUseSkillClientSkillUuid => "ErrUseSkillClientSkillUuid",
            Self::ErrFightLogicConditionBlockInvalid => "ErrFightLogicConditionBlockInvalid",
            Self::ErrFightLogicActionGroupInvalid => "ErrFightLogicActionGroupInvalid",
            Self::ErrFightLogicConditionNotMatch => "ErrFightLogicConditionNotMatch",
            Self::ErrFightLogicRunDataInvalid => "ErrFightLogicRunDataInvalid",
            Self::ErrSkillStageNotFind => "ErrSkillStageNotFind",
            Self::ErrConditionCfgSize => "ErrConditionCfgSize",
            Self::ErrConditionDissatisfy => "ErrConditionDissatisfy",
            Self::ErrConditionObjectIsNull => "ErrConditionObjectIsNull",
            Self::ErrConditionTypeNotFound => "ErrConditionTypeNotFound",
            Self::ErrConditionEntityDeath => "ErrConditionEntityDeath",
            Self::ErrConditionUnionLevel => "ErrConditionUnionLevel",
            Self::ErrConditionUnionMoney => "ErrConditionUnionMoney",
            Self::ErrConditionNotMeet => "ErrConditionNotMeet",
            Self::ErrConditionNotInShapeShift => "ErrConditionNotInShapeShift",
            Self::ErrSeasonAchievementNoExist => "ErrSeasonAchievementNoExist",
            Self::ErrSeasonAchievementNoFinish => "ErrSeasonAchievementNoFinish",
            Self::ErrSeasonAchievementHasReceived => "ErrSeasonAchievementHasReceived",
            Self::ErrSeasonAchievementPrevIdNoReceived => "ErrSeasonAchievementPrevIdNoReceived",
            Self::ErrSeasonAchievementPrevIdNoExist => "ErrSeasonAchievementPrevIdNoExist",
            Self::ErrSeasonAchievementTargetConfigError => "ErrSeasonAchievementTargetConfigError",
            Self::ErrSeasonRankHasMax => "ErrSeasonRankHasMax",
            Self::ErrSeasonRankHasReceived => "ErrSeasonRankHasReceived",
            Self::ErrSeasonRankNoAchieve => "ErrSeasonRankNoAchieve",
            Self::ErrSeasonRankCurSeasonIdZero => "ErrSeasonRankCurSeasonIdZero",
            Self::ErrSeasonRankNoMeetCondition => "ErrSeasonRankNoMeetCondition",
            Self::ErrSeasonRankSeasonNoSame => "ErrSeasonRankSeasonNoSame",
            Self::ErrBattlePassBuyLevel => "ErrBattlePassBuyLevel",
            Self::ErrBattlePassBuyMaterial => "ErrBattlePassBuyMaterial",
            Self::ErrBattlePassAwardGet => "ErrBattlePassAwardGet",
            Self::ErrBattlePassAwardNotUnlock => "ErrBattlePassAwardNotUnlock",
            Self::ErrBattlePassBuyWeekExpLimit => "ErrBattlePassBuyWeekExpLimit",
            Self::ErrBattlePassLevelError => "ErrBattlePassLevelError",
            Self::ErrNoRefreshTimes => "ErrNoRefreshTimes",
            Self::ErrTargetNotCompleted => "ErrTargetNotCompleted",
            Self::ErrOnlinePeriodTooMore => "ErrOnlinePeriodTooMore",
            Self::ErrPersonalTagTooMore => "ErrPersonalTagTooMore",
            Self::ErrPersonalTagNotFound => "ErrPersonalTagNotFound",
            Self::ErrPersonalAvatarUnearned => "ErrPersonalAvatarUnearned",
            Self::ErrPersonalAvatarFrameUnearned => "ErrPersonalAvatarFrameUnearned",
            Self::ErrPersonalCardStyleUnearned => "ErrPersonalCardStyleUnearned",
            Self::ErrPersonalPhotoTooMore => "ErrPersonalPhotoTooMore",
            Self::ErrPersonalMedalUnearned => "ErrPersonalMedalUnearned",
            Self::ErrPersonalTargetUnlock => "ErrPersonalTargetUnlock",
            Self::ErrPersonalTargetAlreadyGet => "ErrPersonalTargetAlreadyGet",
            Self::ErrPersonalMedalInvalidSlot => "ErrPersonalMedalInvalidSlot",
            Self::ErrPersonalMedalDuplicateValue => "ErrPersonalMedalDuplicateValue",
            Self::ErrOnlinePeriodDuplicate => "ErrOnlinePeriodDuplicate",
            Self::ErrPersonalTagDuplicate => "ErrPersonalTagDuplicate",
            Self::ErrPersonalPhotoInvalidSlot => "ErrPersonalPhotoInvalidSlot",
            Self::ErrPersonalPhotoDuplicateValue => "ErrPersonalPhotoDuplicateValue",
            Self::ErrSeasonMedalNoMeetActiveCondition => "ErrSeasonMedalNoMeetActiveCondition",
            Self::ErrSeasonMedalNoMeetUpgradeCondition => "ErrSeasonMedalNoMeetUpgradeCondition",
            Self::ErrSeasonMedalActiveMeetNoEnough => "ErrSeasonMedalActiveMeetNoEnough",
            Self::ErrSeasonMedalUpgradeMeetNoEnough => "ErrSeasonMedalUpgradeMeetNoEnough",
            Self::ErrSeasonMedalIllegalNodeId => "ErrSeasonMedalIllegalNodeId",
            Self::ErrSeasonMedalChooseNodeIdBeyondMax => "ErrSeasonMedalChooseNodeIdBeyondMax",
            Self::ErrSeasonMedalHoleNoExist => "ErrSeasonMedalHoleNoExist",
            Self::ErrSeasonMedalHoleLock => "ErrSeasonMedalHoleLock",
            Self::ErrSeasonMedalNodeNoExist => "ErrSeasonMedalNodeNoExist",
            Self::ErrSeasonMedalHoleNoGet => "ErrSeasonMedalHoleNoGet",
            Self::ErrSeasonMedalMaxHoleLevel => "ErrSeasonMedalMaxHoleLevel",
            Self::ErrSeasonMedalCoreHoleLock => "ErrSeasonMedalCoreHoleLock",
            Self::ErrSeasonMedalUpgradeMoneyNoEnough => "ErrSeasonMedalUpgradeMoneyNoEnough",
            Self::ErrSeasonNoCoreHole => "ErrSeasonNoCoreHole",
            Self::ErrSeasonNoNormalHole => "ErrSeasonNoNormalHole",
            Self::ErrSeasonMedalNoUpgradeNormalHoleItem => "ErrSeasonMedalNoUpgradeNormalHoleItem",
            Self::ErrSceneLineNotExists => "ErrSceneLineNotExists",
            Self::ErrSceneLineRefreshCd => "ErrSceneLineRefreshCd",
            Self::ErrSceneLineNotSameScene => "ErrSceneLineNotSameScene",
            Self::ErrSceneLineSameLine => "ErrSceneLineSameLine",
            Self::ErrSceneLineInteracting => "ErrSceneLineInteracting",
            Self::ErrSceneLineUserDead => "ErrSceneLineUserDead",
            Self::ErrSceneLineFull => "ErrSceneLineFull",
            Self::ErrSceneLineChangeCd => "ErrSceneLineChangeCd",
            Self::ErrSceneVersionRecycle => "ErrSceneVersionRecycle",
            Self::ErrSceneLineKick => "ErrSceneLineKick",
            Self::ErrInstallSlotFailed => "ErrInstallSlotFailed",
            Self::ErrUseSlotFailed => "ErrUseSlotFailed",
            Self::ErrUseSlotInCd => "ErrUseSlotInCd",
            Self::ErrInstatallSlotFailedInCombat => "ErrInstatallSlotFailedInCombat",
            Self::ErrSlotSkillUnLoad => "ErrSlotSkillUnLoad",
            Self::ErrUseCfgSkillFailed => "ErrUseCfgSkillFailed",
            Self::ErrResonanceNotExists => "ErrResonanceNotExists",
            Self::ErrResonanceUnLoad => "ErrResonanceUnLoad",
            Self::ErrUseDodgeFailed => "ErrUseDodgeFailed",
            Self::ErrUseFixedSkillFailed => "ErrUseFixedSkillFailed",
            Self::ErrUseBlockedSkill => "ErrUseBlockedSkill",
            Self::ErrInstallBlockedSkill => "ErrInstallBlockedSkill",
            Self::ErrExchangeNotFound => "ErrExchangeNotFound",
            Self::ErrExchangeNotEnough => "ErrExchangeNotEnough",
            Self::ErrExchangeItemLimit => "ErrExchangeItemLimit",
            Self::ErrExchangeStepRange => "ErrExchangeStepRange",
            Self::ErrExchangeItemFull => "ErrExchangeItemFull",
            Self::ErrExchangePackageFull => "ErrExchangePackageFull",
            Self::ErrExchangePriceItemNotFind => "ErrExchangePriceItemNotFind",
            Self::ErrExchangeBuyNumNotEnough => "ErrExchangeBuyNumNotEnough",
            Self::ErrExchangeBuyItemNotFound => "ErrExchangeBuyItemNotFound",
            Self::ErrExchangeTakeFailDelayTime => "ErrExchangeTakeFailDelayTime",
            Self::ErrExchangeTakeFailSellNum => "ErrExchangeTakeFailSellNum",
            Self::ErrExchangeTakeItemNotFound => "ErrExchangeTakeItemNotFound",
            Self::ErrExchangeWithdrawNoMoney => "ErrExchangeWithdrawNoMoney",
            Self::ErrExchangeDepositNotEnough => "ErrExchangeDepositNotEnough",
            Self::ErrExchangeItemNotBindOrCooldownNotExpire => "ErrExchangeItemNotBindOrCooldownNotExpire",
            Self::ErrExchangeInCd => "ErrExchangeInCd",
            Self::ErrExchangeBuyCurrencyNoEnough => "ErrExchangeBuyCurrencyNoEnough",
            Self::ErrExchangeItemDelayTimeOver => "ErrExchangeItemDelayTimeOver",
            Self::ErrExchangeItemIsNotWithdraw => "ErrExchangeItemIsNotWithdraw",
            Self::ErrExchangeBuyItemLimit => "ErrExchangeBuyItemLimit",
            Self::ErrExchangeItemIsNotNoticeShopItem => "ErrExchangeItemIsNotNoticeShopItem",
            Self::ErrExchangeItemIsPreBuyAlready => "ErrExchangeItemIsPreBuyAlready",
            Self::ErrExchangeItemNotPublic => "ErrExchangeItemNotPublic",
            Self::ErrExchangeSaleRankExist => "ErrExchangeSaleRankExist",
            Self::ErrExchangeSaleItemFull => "ErrExchangeSaleItemFull",
            Self::ErrExchangeSaleDiamondNotEnough => "ErrExchangeSaleDiamondNotEnough",
            Self::ErrExchangeSaleItemNotExists => "ErrExchangeSaleItemNotExists",
            Self::ErrExchangeBuySaleCurrencyNoEnough => "ErrExchangeBuySaleCurrencyNoEnough",
            Self::ErrExchangeDiamondNotEnough => "ErrExchangeDiamondNotEnough",
            Self::ErrExchangeSaleTakeOffCd => "ErrExchangeSaleTakeOffCd",
            Self::ErrExchangeSaleRateInvalid => "ErrExchangeSaleRateInvalid",
            Self::ErrExchangePreItemFull => "ErrExchangePreItemFull",
            Self::ErrExchangeSaleNumInvalid => "ErrExchangeSaleNumInvalid",
            Self::ErrExchangeCareItemAlready => "ErrExchangeCareItemAlready",
            Self::ErrExchangePriceRange => "ErrExchangePriceRange",
            Self::ErrExchangeRequestLimit => "ErrExchangeRequestLimit",
            Self::ErrExchangeItemBanned => "ErrExchangeItemBanned",
            Self::ErrExchangePriceNotLow => "ErrExchangePriceNotLow",
            Self::ErrExchangeItemNotFind => "ErrExchangeItemNotFind",
            Self::ErrExchangeItemExistMinPrice => "ErrExchangeItemExistMinPrice",
            Self::ErrExchangeNoticeItemMin => "ErrExchangeNoticeItemMin",
            Self::ErrExchangePreBuyUserFull => "ErrExchangePreBuyUserFull",
            Self::ErrModHoleNotUnlock => "ErrModHoleNotUnlock",
            Self::ErrModNotExist => "ErrModNotExist",
            Self::ErrModSimilarRepeated => "ErrModSimilarRepeated",
            Self::ErrModTypeLimitExceeded => "ErrModTypeLimitExceeded",
            Self::ErrModPartNotExist => "ErrModPartNotExist",
            Self::ErrModPartEnhanceLimit => "ErrModPartEnhanceLimit",
            Self::ErrModInUse => "ErrModInUse",
            Self::ErrModAlreadyInstalled => "ErrModAlreadyInstalled",
            Self::ErrModInitConfigNotExist => "ErrModInitConfigNotExist",
            Self::ErrModPartOverflow => "ErrModPartOverflow",
            Self::ErrModCanNotLink => "ErrModCanNotLink",
            Self::ErrFishingNotUseBait => "ErrFishingNotUseBait",
            Self::ErrFishingRandomFailed => "ErrFishingRandomFailed",
            Self::ErrFishingAlreadyGetFishItem => "ErrFishingAlreadyGetFishItem",
            Self::ErrFishingGetFishIdWrong => "ErrFishingGetFishIdWrong",
            Self::ErrFishingNotGet => "ErrFishingNotGet",
            Self::ErrFishingNotResearchYet => "ErrFishingNotResearchYet",
            Self::ErrFishingNotUseRod => "ErrFishingNotUseRod",
            Self::ErrFishingNoSeat => "ErrFishingNoSeat",
            Self::ErrFishingCantResearch => "ErrFishingCantResearch",
            Self::ErrFishDrawnLevelAward => "ErrFishDrawnLevelAward",
            Self::ErrFishCannotDrawLevelAward => "ErrFishCannotDrawLevelAward",
            Self::ErrFishDrawnNoLevelAward => "ErrFishDrawnNoLevelAward",
            Self::ErrFreightNoRefreshGoods => "ErrFreightNoRefreshGoods",
            Self::ErrFreightBeyondMaxValue => "ErrFreightBeyondMaxValue",
            Self::ErrFreightDownMinValue => "ErrFreightDownMinValue",
            Self::ErrFreightHasSetOff => "ErrFreightHasSetOff",
            Self::ErrFreightNoSetOff => "ErrFreightNoSetOff",
            Self::ErrFreightHasReward => "ErrFreightHasReward",
            Self::ErrFreightIllegalGoodsId => "ErrFreightIllegalGoodsId",
            Self::ErrFreightItemNoEnough => "ErrFreightItemNoEnough",
            Self::ErrFreightNoUpSetOffTime => "ErrFreightNoUpSetOffTime",
            Self::ErrFreightNoUpRewardTime => "ErrFreightNoUpRewardTime",
            Self::ErrFreightAutoSetOff => "ErrFreightAutoSetOff",
            Self::ErrTrialRoadAwardNotFinished => "ErrTrialRoadAwardNotFinished",
            Self::ErrTrialRoadAwardRoomGet => "ErrTrialRoadAwardRoomGet",
            Self::ErrNotCanRide => "ErrNotCanRide",
            Self::ErrCombatStateNotRide => "ErrCombatStateNotRide",
            Self::ErrAlreadyRide => "ErrAlreadyRide",
            Self::ErrRideNotEnough => "ErrRideNotEnough",
            Self::ErrCreateVehicleActorFailed => "ErrCreateVehicleActorFailed",
            Self::ErrNotVehicleOwner => "ErrNotVehicleOwner",
            Self::ErrVehicleHasController => "ErrVehicleHasController",
            Self::ErrVehicleNoSeat => "ErrVehicleNoSeat",
            Self::ErrVehicleHasSeat => "ErrVehicleHasSeat",
            Self::ErrNotRideVehicle => "ErrNotRideVehicle",
            Self::ErrVehicleNotExits => "ErrVehicleNotExits",
            Self::ErrInvalidRidePropertyType => "ErrInvalidRidePropertyType",
            Self::ErrRideApplyTargetUserNotExist => "ErrRideApplyTargetUserNotExist",
            Self::ErrRideConfigNotFind => "ErrRideConfigNotFind",
            Self::ErrRideNotUnlock => "ErrRideNotUnlock",
            Self::ErrRideNotFind => "ErrRideNotFind",
            Self::ErrInvalidRideType => "ErrInvalidRideType",
            Self::ErrRideApplyAlreadyExist => "ErrRideApplyAlreadyExist",
            Self::ErrRideApplyNotRideVehicle => "ErrRideApplyNotRideVehicle",
            Self::ErrRideApplyVehicleNotSeat => "ErrRideApplyVehicleNotSeat",
            Self::ErrRideAlReadyRide => "ErrRideAlReadyRide",
            Self::ErrRideApplyTargetTooFar => "ErrRideApplyTargetTooFar",
            Self::ErrRideNotTake => "ErrRideNotTake",
            Self::ErrRideInteracting => "ErrRideInteracting",
            Self::ErrShapeshiftNotRide => "ErrShapeshiftNotRide",
            Self::ErrFishingNotRide => "ErrFishingNotRide",
            Self::ErrRideStateReject => "ErrRideStateReject",
            Self::ErrRideTypeNotSupport => "ErrRideTypeNotSupport",
            Self::ErrRideNotControl => "ErrRideNotControl",
            Self::ErrRideNotFunction => "ErrRideNotFunction",
            Self::ErrRideSkinNotSupport => "ErrRideSkinNotSupport",
            Self::ErrRideSkinNotUnlock => "ErrRideSkinNotUnlock",
            Self::ErrRideSkinDataAddFailed => "ErrRideSkinDataAddFailed",
            Self::ErrRideSkinNotSkin => "ErrRideSkinNotSkin",
            Self::ErrRideSkinAlreadyActivate => "ErrRideSkinAlreadyActivate",
            Self::ErrWarehouseHas => "ErrWarehouseHas",
            Self::ErrWarehouseNoHas => "ErrWarehouseNoHas",
            Self::ErrWarehouseNoMem => "ErrWarehouseNoMem",
            Self::ErrWarehouseNoPresident => "ErrWarehouseNoPresident",
            Self::ErrWarehouseNoHasItem => "ErrWarehouseNoHasItem",
            Self::ErrWarehouseItemNoDeposit => "ErrWarehouseItemNoDeposit",
            Self::ErrWarehouseGridPosNoExist => "ErrWarehouseGridPosNoExist",
            Self::ErrWarehouseGridPosItemNoEnough => "ErrWarehouseGridPosItemNoEnough",
            Self::ErrWarehouseNoInviteSelf => "ErrWarehouseNoInviteSelf",
            Self::ErrWarehouseInviteesHas => "ErrWarehouseInviteesHas",
            Self::ErrWarehouseMemBeyondMax => "ErrWarehouseMemBeyondMax",
            Self::ErrWarehouseGridBeyondMax => "ErrWarehouseGridBeyondMax",
            Self::ErrWarehouseNoSelf => "ErrWarehouseNoSelf",
            Self::ErrWarehouseIsMem => "ErrWarehouseIsMem",
            Self::ErrWarehouseNoExist => "ErrWarehouseNoExist",
            Self::ErrWarehouseDepositBeyondMax => "ErrWarehouseDepositBeyondMax",
            Self::ErrWarehouseTakeOutBeyondMax => "ErrWarehouseTakeOutBeyondMax",
            Self::ErrWarehouseItemIdNotSame => "ErrWarehouseItemIdNotSame",
            Self::ErrWarehouseParams => "ErrWarehouseParams",
            Self::ErrWarehouseNoKickSelf => "ErrWarehouseNoKickSelf",
            Self::ErrWarehousePresidentNoExit => "ErrWarehousePresidentNoExit",
            Self::ErrGashaDrawCount => "ErrGashaDrawCount",
            Self::ErrGashaDrawLimit => "ErrGashaDrawLimit",
            Self::ErrGashaInvalidWishId => "ErrGashaInvalidWishId",
            Self::EErGashaWishRepeated => "EErGashaWishRepeated",
            Self::EErGashaWishCountNoEnough => "EErGashaWishCountNoEnough",
            Self::ErrWarehouseAuthority => "ErrWarehouseAuthority",
            Self::ErrEquipCantDecompose => "ErrEquipCantDecompose",
            Self::ErrEquipNotRecastRecord => "ErrEquipNotRecastRecord",
            Self::ErrEquipOnCantUsedRecastConsume => "ErrEquipOnCantUsedRecastConsume",
            Self::ErrEquipWeaponNotEqualProfession => "ErrEquipWeaponNotEqualProfession",
            Self::ErrEquipSlotRefineBlessNotFit => "ErrEquipSlotRefineBlessNotFit",
            Self::ErrEquipNotRecast => "ErrEquipNotRecast",
            Self::ErrEquipEnchantItemMismatch => "ErrEquipEnchantItemMismatch",
            Self::ErrEquipEnchantAlreadyEnchanted => "ErrEquipEnchantAlreadyEnchanted",
            Self::ErrEquipAnyItemMismatch => "ErrEquipAnyItemMismatch",
            Self::ErrEquipSlotRefineBlessNumTooMuch => "ErrEquipSlotRefineBlessNumTooMuch",
            Self::ErrEquipNameGroupNoMatch => "ErrEquipNameGroupNoMatch",
            Self::ErrEquipPerfectionNoMatch => "ErrEquipPerfectionNoMatch",
            Self::ErrEquipNotBreak => "ErrEquipNotBreak",
            Self::ErrEquipPutOnIng => "ErrEquipPutOnIng",
            Self::ErrUserIsMatching => "ErrUserIsMatching",
            Self::ErrUserNotInMatching => "ErrUserNotInMatching",
            Self::ErrUseNotWaitReady => "ErrUseNotWaitReady",
            Self::ErrDungeonCantMatch => "ErrDungeonCantMatch",
            Self::ErrMatchQueueFull => "ErrMatchQueueFull",
            Self::ErrCommonAwardCantReceive => "ErrCommonAwardCantReceive",
            Self::ErrCommonAwardHasReceived => "ErrCommonAwardHasReceived",
            Self::ErrCraftEnergyNotEnough => "ErrCraftEnergyNotEnough",
            Self::ErrCraftEnergyFull => "ErrCraftEnergyFull",
            Self::ErrRecommendPlayNotOpen => "ErrRecommendPlayNotOpen",
            Self::ErrWeeklyTowerNoStart => "ErrWeeklyTowerNoStart",
            Self::ErrWeeklyTowerHasEnd => "ErrWeeklyTowerHasEnd",
            Self::ErrWeeklyNoMeetProcessAward => "ErrWeeklyNoMeetProcessAward",
            Self::ErrWeeklyHasRewardProcessAward => "ErrWeeklyHasRewardProcessAward",
            Self::ErrWeeklyNoLayerStageAward => "ErrWeeklyNoLayerStageAward",
            Self::ErrWeekOnlyCurSeasonAward => "ErrWeekOnlyCurSeasonAward",
            Self::ErrWeeklyTowerCannotEnterLayer => "ErrWeeklyTowerCannotEnterLayer",
            Self::ErrWeeklyTowerBoxHasOpen => "ErrWeeklyTowerBoxHasOpen",
            Self::ErrWeeklyTowerNoBox => "ErrWeeklyTowerNoBox",
            Self::ErrWeeklyTowerNoStageAward => "ErrWeeklyTowerNoStageAward",
            Self::ErrWeeklyTowerNoTowerDungeon => "ErrWeeklyTowerNoTowerDungeon",
            Self::ErrFunctionNoAward => "ErrFunctionNoAward",
            Self::ErrFunctionHasDrawn => "ErrFunctionHasDrawn",
            Self::ErrTLogIllegalExportArea => "ErrTLogIllegalExportArea",
            Self::ErrPayOrderFail => "ErrPayOrderFail",
            Self::ErrPayCostNotEnough => "ErrPayCostNotEnough",
            Self::ErrPayCantBuy => "ErrPayCantBuy",
            Self::ErrPayCantExplore => "ErrPayCantExplore",
            Self::ErrActivityNotFind => "ErrActivityNotFind",
            Self::ErrActivityOffline => "ErrActivityOffline",
            Self::ErrActivityNotOpen => "ErrActivityNotOpen",
            Self::ErrActivityRewardNotFound => "ErrActivityRewardNotFound",
            Self::ErrActivityConditionNotFinish => "ErrActivityConditionNotFinish",
            Self::ErrActivityAlreadyObtain => "ErrActivityAlreadyObtain",
            Self::ErrActivityNotUnlock => "ErrActivityNotUnlock",
            Self::ErrEmojiConfigError => "ErrEmojiConfigError",
            Self::ErrEmojiAlreadyUnlock => "ErrEmojiAlreadyUnlock",
            Self::ErrEmojiUnlockItemError => "ErrEmojiUnlockItemError",
            Self::ErrEmojiUnlockItemErrorItemNotEnough => "ErrEmojiUnlockItemErrorItemNotEnough",
            Self::ErrEmojiUnlock => "ErrEmojiUnlock",
            Self::ErrGlobalConditionNotFound => "ErrGlobalConditionNotFound",
            Self::ErrGlobalConditionNotLuckyValue => "ErrGlobalConditionNotLuckyValue",
            Self::ErrPathFindingCant => "ErrPathFindingCant",
            Self::ErrPathFindingDataError => "ErrPathFindingDataError",
            Self::ErrPathFindingEndPosError => "ErrPathFindingEndPosError",
            Self::ErrPathFindingStartPosError => "ErrPathFindingStartPosError",
            Self::ErrPathFindingNoPath => "ErrPathFindingNoPath",
            Self::ErrSignNotOpen => "ErrSignNotOpen",
            Self::ErrSignNotSigned => "ErrSignNotSigned",
            Self::ErrSignAlreadySigned => "ErrSignAlreadySigned",
            Self::ErrSignTimeError => "ErrSignTimeError",
            Self::ErrTokenBucketLimit => "ErrTokenBucketLimit",
            Self::ErrUnknown => "ErrUnknown",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EErrorCode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ErrSuccess",
            "ErrNoRecord",
            "ErrExceptionCancel",
            "ErrDBException",
            "ErrDBSeqException",
            "ErrDBSceneException",
            "ErrDBTokenException",
            "ErrCancelled",
            "ErrUnknownRpc",
            "ErrInvalidArgument",
            "ErrDeadlineExceeded",
            "ErrNotFound",
            "ErrAlreadyExists",
            "ErrPermissionDenied",
            "ErrResourceExhausted",
            "ErrFailedPrecondition",
            "ErrAborted",
            "ErrOutOfRange",
            "ErrUnimplemented",
            "ErrInternal",
            "ErrUnavailable",
            "ErrDataLoss",
            "ErrUnauthenticated",
            "ErrSystemMax",
            "ErrDBError",
            "ErrCreateOpenInfo",
            "ErrCreateAccountInfo",
            "ErrCreateCharInfo",
            "ErrCreateAccountToken",
            "ErrGetOpenInfo",
            "ErrGetAccountInfo",
            "ErrGetCharInfo",
            "ErrGetAccountToken",
            "ErrLoginInQueue",
            "ErrOtherLogin",
            "ErrServerError",
            "ErrNoAccountInfo",
            "ErrNoCharInfo",
            "ErrTokenExpired",
            "ErrUpdateTokenFail",
            "ErrRegIntoSceneError",
            "ErrLoginTypeErr",
            "ErrChangeMapErr",
            "ErrLoginPlatformErr",
            "ErrVersionErr",
            "ErrDelayOffLineKickOff",
            "ErrServiceLanguageError",
            "NoEnterScene",
            "ModIDNotOpen",
            "ErrFaceData",
            "ErrInitProfession",
            "ErrSceneCloseKickoff",
            "ErrLoginReconnectKick",
            "ErrLoginErrorResume",
            "ErrRepeatedLogin",
            "ErrRestrictLogin",
            "ErrRestrictBlack",
            "ErrSdkVerifyFail",
            "ErrSdkTokenExpired",
            "ErrServerNotOpen",
            "ErrServerEndOpen",
            "ErrNormalKick",
            "ErrServerBusy",
            "ErrServerClose",
            "ErrExitGame",
            "ErrHopeKick",
            "ErrClientVersionError",
            "ErrInvalidDeviceId",
            "ErrInvalidSystemType",
            "ErrDeleteChar",
            "ErrCancelDeleteChar",
            "ErrCancelDeleteCharIsDelete",
            "ErrIntoSceneOwnerFail",
            "ErrSceneQueueUp",
            "ErrProtocolVersionErr",
            "ErrConfigVersionErr",
            "ErrStateEventFailed",
            "ErrSelectCharDoing",
            "ErrSelectCharDeleted",
            "ErrLoginChannelMax",
            "ErrDeleteAccountKick",
            "ErrIsDeleteAccount",
            "ErrIsVersionKick",
            "ErrNotQQChnnel",
            "ErrIncorrectLaunchPlatform",
            "ErrConditionWrong",
            "ErrNotSupportLoginType",
            "ErrSceneNotExist",
            "ErrUserNotExist",
            "ErrComponentNotExist",
            "ErrSceneConfigNotExist",
            "ErrServiceNotExist",
            "ErrDataContainerNotExist",
            "ErrAsynchronousReturn",
            "ErrConfigNotExist",
            "ErrNotUser",
            "ErrConfigError",
            "ErrActorNotExist",
            "ErrCutSceneAlreadyPlayed",
            "ErrFunctionUnlock",
            "ErrFunctionClosed",
            "ErrUserPlayerNotFurniturePackage",
            "ErrSysInnerError",
            "ErrSysWebClientNull",
            "ErrSysWebRequestTimeOut",
            "ErrSysWebReturnError",
            "ErrRequestTooFrequently",
            "ErrArgStringTooLong",
            "ErrArgStringEmpty",
            "ErrArgArrayTooBig",
            "ErrArgArrayEmpty",
            "ErrArgMapTooBig",
            "ErrArgMapEmpty",
            "ErrItemNotExist",
            "ErrPackageNotExist",
            "ErrPackageFull",
            "ErrItemExpireTime",
            "ErrItemPackageGridNotEnough",
            "ErrItemUUIDError",
            "ErrItemNotEnough",
            "ErrOptTypeError",
            "ErrItemInCoolDown",
            "ErrItemNotUse",
            "ErrItemEffectTypeError",
            "ErrItemParamError",
            "ErrItemAddBuffError",
            "ErrItemAdd",
            "ErrUseItemState",
            "ErrBatchUse",
            "ErrFullSendMail",
            "ErrItemNumZero",
            "ErrItemSelectAwardIllegalNum",
            "ErrItemSelectAwardIllegalPos",
            "ErrItemSelectLimit",
            "ErrItemPeriodGainExceeded",
            "ErrItemNoRecycle",
            "ErrItemRecycleBeyondMaxGrid",
            "ErrItemRecycleBeyondMaxNum",
            "ErrItemRecycleIdNoMatchItemId",
            "ErrItemRecycleIllegalId",
            "ErrItemLimitCount",
            "ErrItemFriendPontExceeded",
            "ErrItemToySingleEntUseExceeded",
            "ErrItemToySceneUseExceeded",
            "ErrItemToyUseInDisableArea",
            "ErrItemToySingleCellUseExceeded",
            "ErrMonthlyCardNotExists",
            "ErrMonthlyCardDataError",
            "ErrMonthlyCardDayAwardReceived",
            "ErrMonthlyCardLimitCount",
            "ErrCommunityNoHome",
            "ErrNotHouseOwner",
            "ErrHomeLandExisted",
            "ErrHomeLandContentWrongful",
            "ErrHouseLivetogetherCD",
            "ErrHomeLandNotExisted",
            "ErrHomeLandNotInScene",
            "ErrHomeLandIsInvitation",
            "ErrHomeLandInsufficientAuthority",
            "ErrHomeLandTransferRequestPending",
            "ErrHomeLandTransferRequestTimeout",
            "ErrHomeLandTransferCD",
            "ErrHomelandTargetIsHasHome",
            "ErrHomelandTargetIsOwner",
            "ErrHomelandNotOwnerCannotOperate",
            "ErrHomeLandHasHouse",
            "ErrHomeLandContentTooLong",
            "ErrHomeLandClutterNotExist",
            "ErrHouseNameOrStatementCD",
            "ErrHouseIntroductionStatementCD",
            "ErrCommunityBuildInvalidRecipeId",
            "ErrCommunityBuildRecipeIsUnlock",
            "ErrCommunityBuildMax",
            "ErrCommunityBuildNoAuthority",
            "ErrCommunityNotBuildCannotCancel",
            "ErrCommunityBuildNotSelfCannotCancel",
            "ErrCommunityNotBuildCannotAccelerate",
            "ErrCommunityBuildNotSelfCannotAccelerate",
            "ErrCommunityBuildCannotAccelerate",
            "ErrCommunityBuildAlreadyAccelerate",
            "ErrCommunityBuildInDungeon",
            "ErrCommunityBuildRecipeIsLock",
            "ErrCommunityBuildRecipeNotItemUnlock",
            "ErrCommunityBuildInvalidCount",
            "ErrCommunityNotBuildCannotReceive",
            "ErrCommunityCanNotBuild",
            "ErrHomeLandCohabitantLimit",
            "ErrHomeLandRootNotQuitCohabitant",
            "ErrHomeLandNotOwnerCannotQuitCohabitant",
            "ErrHomeLandCohabitantIsExiting",
            "ErrHomeLandCohabitantNotExists",
            "ErrHomeLandCohabitantExitRequestExists",
            "ErrHomeLandCohabitantDismiss",
            "ErrHomeLandNotInvitation",
            "ErrHomeLandCohabitantInvitationTimeout",
            "ErrHomeLandCohabitantNotFriend",
            "ErrHomeLandCohabitantFriendLevel",
            "ErrHomeLandCohabitantLevel",
            "ErrHomeLandInviteCohabitantNotOwner",
            "ErrCommunityWarehouseGridFull",
            "ErrCommunityWarehouseNoAuthority",
            "ErrCommunityWarehouseGridPosItemNoEnough",
            "ErrHomeLandInsufficientFurniture",
            "ErrCommunityWarehouseTakeOutCountLimit",
            "ErrHomeLandTaskNotExist",
            "ErrHomeLandTaskTimeNotEnough",
            "ErrHomeLandTaskAlreadyFinished",
            "ErrHomeLandTaskItemNotEnough",
            "ErrHomeLandCurLevelError",
            "ErrHomeLandExpNotEnough",
            "ErrHomeLandAlreadyMaxLevel",
            "ErrHomeLandLevelLocked",
            "ErrHomeLandLevelConfigError",
            "ErrCommunityEditorNotEditable",
            "ErrCommunityEditorNotFurniture",
            "ErrCommunityEditorNotOutdoor",
            "ErrCommunityEditorNotIndoor",
            "ErrCommunityEditorOverMax",
            "ErrCommunityEditorOverTypeMax",
            "ErrCommunityEditorFurnitureNotEnough",
            "ErrCommunityEditorFurnitureNotExist",
            "ErrCommunityEditorOverMaxGroup",
            "ErrCommunityEditorNoStructure",
            "ErrCommunityEditorGroupMaxStructure",
            "ErrCommunityEditorStructureInGroup",
            "ErrCommunityEditorGroupNotExist",
            "ErrCommunityEditorAlreadyExist",
            "ErrHomeLandSellItemNotExist",
            "ErrHomeLandLeftNumNotEnough",
            "ErrHomeLandSellShopLocked",
            "ErrHomeLandSeedExist",
            "ErrHomeLandItemNotOwner",
            "ErrHomeLandSeedStateError",
            "ErrHomeLandNoSeed",
            "ErrHomeLandNoWater",
            "ErrHomeLandFertilizerMaxNumLimit",
            "ErrHomeLandNotFertilize",
            "ErrHomeLandNotPollen",
            "ErrHomeLandAlreadyPollen",
            "ErrHomeLandNotHarvest",
            "ErrHomeLandPickUpSinglePlayerLimit",
            "ErrHomeLandPickUpTotalLimit",
            "ErrHomeLandPickUpFlowerNotFinished",
            "ErrHomeLandPickUpOwner",
            "ErrHomeLandGainNotOwner",
            "ErrHomeLandItemFullGrid",
            "ErrHomeLandFurnitureFull",
            "ErrComposeItemNotEnough",
            "ErrComposeFailed",
            "ErrRedemptionItemNotExist",
            "ErrRedemptionItemMaxCount",
            "ErrRedemptionItemNotEnough",
            "ErrRedemptionItemGender",
            "ErrAwardConfigNotFound",
            "ErrAwardConfigWeightError",
            "ErrAwardConfigLimitAndContentNotMatch",
            "ErrAwardConfigContentSizeError",
            "ErrAwardConfigContentRatesSizeError",
            "ErrAwardConfigContentWeightSizeError",
            "ErrAwardConfigGroupContentEmpty",
            "ErrAwardConfigGroupNumEmpty",
            "ErrAwardConfigGroupContentNoMatchGroupNum",
            "ErrAwardConfigNoRandomDrop",
            "ErrAwardConfigNoSelectAward",
            "ErrAwardConfigSelfSelectContentNoItem",
            "ErrAwardConfigWeightRateMustOne",
            "ErrAwardConfigGroupContentRandomNoMatch",
            "ErrAwardConfigGroupContentError",
            "ErrAwardConfigPackageContentRandomNoMatch",
            "ErrAwardConfigLevelUpPackConfigPackageNoMatch",
            "ErrAwardConfigProItemRuleNoMatch",
            "ErrAwardConfigPackageContentEmpty",
            "ErrAwardConfigDropContentSize",
            "ErrAwardConfigDropContentNum",
            "ErrAwardConfigGroupRateEmpty",
            "ErrAwardConfigGroupWeightEmpty",
            "ErrAwardInnerError",
            "ErrAwardIllegalRandomType",
            "ErrAwardConditionNoMeet",
            "ErrAwardRandomTypeNone",
            "ErrAwardRandomTypeNoMatch",
            "ErrAwardActorIsNull",
            "ErrEquipWashAttrNotExist",
            "ErrNotEquipInCombat",
            "ErrEquipPart",
            "ErrComposeItemNotExist",
            "ErrPickupDropItemDistance",
            "ErrPickupDropItemPackageFull",
            "ErrPickupDropItemNoAuthority",
            "ErrLayerActorExist",
            "ErrTeamCreateHas",
            "ErrTeamIllTarget",
            "ErrTeamCreateTryLater",
            "ErrTeamGetNo",
            "ErrTeamListEmpty",
            "ErrTeamInner",
            "ErrTeamNoLeader",
            "ErrTeamInMatch",
            "ErrTeamCustomizeTarget",
            "ErrTeamNoOwn",
            "ErrTeamTickSelf",
            "ErrTeamNoMem",
            "ErrTeamApplyingLeader",
            "ErrTeamHasBeLeader",
            "ErrTeamNoTransferSelf",
            "ErrTeamNoLeaderTransfer",
            "ErrTeamHasOwnTeam",
            "ErrTeamNoExist",
            "ErrTeamApplyInCD",
            "ErrTeamApplyExpire",
            "ErrTeamJoinOther",
            "ErrTeamMemMax",
            "ErrTeamNoInvited",
            "ErrTeamIsMatching",
            "ErrTeamIllegalTag",
            "ErrTeamNoMatching",
            "ErrTeamIllegalActivity",
            "ErrTeamInActivity",
            "ErrTeamNoMeetCondition",
            "ErrTeamWaitVoting",
            "ErrTeamDoingActivity",
            "ErrTeamNoInVoting",
            "ErrTeamVoteEnd",
            "ErrTeamHasVoted",
            "ErrTeamInviteCD",
            "ErrTeamApplyLeadCD",
            "ErrTeamMoreMaxWorlds",
            "ErrTeamValidApplyInfo",
            "ErrTeamInMatchCancelCD",
            "ErrTeamMatchFinished",
            "ErrTeamMatchWaitSec",
            "ErrTeamMemWorldFull",
            "ErrTeamMemNotLeader",
            "ErrTeamLeaderNotStaticScene",
            "ErrTeamLeaderCallDoing",
            "ErrTeamIllegalCallOperator",
            "ErrTeamLeaderIllegalCallOperator",
            "ErrTeamNoMemCall",
            "ErrTeamLeaderCallEnd",
            "ErrTeamSameScene",
            "ErrTeamNotSameScene",
            "ErrTeamMemTooMore",
            "ErrTeamMemInDungeon",
            "ErrTeamMemTooLess",
            "ErrTeamIllegalInviteType",
            "ErrTeamMemberNotInScene",
            "ErrTeamLeaderReadyCheckTimeNotReady",
            "ErrTeamExistDungeonCheck",
            "ErrTeamTargetMatchTalentLimit",
            "ErrTeamEditGroupNotAllowed",
            "ErrTeamGroupNotExist",
            "ErrTeamTargetNoMatchMemberType",
            "ErrDecomposeItemNotExist",
            "ErrDecomposeItemNotEnough",
            "ErrRefineEnergyNotEnough",
            "ErrRefineItemMaxCount",
            "ErrRefineItemNotExist",
            "ErrRefineItemColumnNotUnlock",
            "ErrRefineItemColumnUnlock",
            "ErrRefineItemExist",
            "ErrEnergyLimitMax",
            "ErrRefineItemColumnNotEmpty",
            "ErrProfessionNotExist",
            "ErrModSlotNotUnlock",
            "ErrChangeProfessionStateFail",
            "ErrChangeProfessionCDFail",
            "ErrProfessionSkinNotActive",
            "ErrProfessionSkinActive",
            "ErrProfessionNotUseSkin",
            "ErrProfessionSkillSkinActive",
            "ErrProfessionSkillSkinNotActive",
            "ErrProfessionSkillNotActive",
            "ErrCharOffline",
            "ErrUserDataBaseError",
            "ErrCharGetFail",
            "ErrAlreadyAlive",
            "ErrReviveParam",
            "ErrStateIllegal",
            "ErrStateNoChange",
            "ErrReviveConsumeNotEnough",
            "ErrReviveByOtherForbid",
            "ErrReviveTimeNotArrived",
            "ErrReviveBossBattle",
            "ErrReviveCountLimit",
            "ErrReviveInDeadTp",
            "ErrDungeonPlayTypeError",
            "ErrDungeonNotExist",
            "ErrDungeonCreateError",
            "ErrCantChangeDungeon",
            "ErrDungeonLock",
            "ErrPioneerFail",
            "ErrAwardFail",
            "ErrGsNotEnough",
            "ErrQuestNotCompleted",
            "ErrDungeonNotClear",
            "ErrConditionNotExist",
            "ErrAwardReceived",
            "ErrCantRepeatedPlay",
            "ErrNeedPassPreRoom",
            "ErrDungeonEnterCountLimit",
            "ErrDungeonScoreError",
            "ErrDungeonRepeatedVote",
            "ErrDungeonChallengeAwardState",
            "ErrDungeonChallengeAffixNotFound",
            "ErrDungeonStateNotActive",
            "ErrDungeonCantVoteSelf",
            "ErrDungeonPlayerNotEnough",
            "ErrDungeonPlayerFull",
            "ErrDungeonCantHeroKey",
            "ErrDungeonNotSettlement",
            "ErrDungeonNotFindRollItem",
            "ErrDungeonCantRoll",
            "ErrDungeonRollFinish",
            "ErrDungeonSelectError",
            "ErrDungeonAiModeError",
            "ErrDungeonTargetNotFinish",
            "ErrDungeonTargetBeAward",
            "ErrDungeonSinglePlayerMore",
            "ErrDungeonAiGroupNotEnough",
            "ErrDungeonNoPass",
            "ErrDungeonCloseSceneId",
            "ErrDungeonEnterTypeError",
            "ErrDungeonActorCount",
            "ErrDungeonDiffLocked",
            "ErrDungeonPreBattleVoteCd",
            "ErrDungeonBossInvalid",
            "ErrDungeonNoUser",
            "ErrDungeonUserInvalid",
            "ErrDungeonAwardualification",
            "ErrDungeonAwardTriesLimit",
            "ErrFashionIsLimit",
            "ErrFashionNotFound",
            "ErrFashionSlotEmpty",
            "ErrFashionIDNotFound",
            "ErrFashionLock",
            "ErrFashCollectionAwardAlread",
            "ErrFashCollectionScoreNotEnough",
            "ErrFashCollectionAwardAlreadMonth",
            "ErrFashionAlreadUnlock",
            "ErrFashionAdvanceNotExist",
            "ErrFashionBaseNotUnlock",
            "ErrFashionAdvanceAlreadyUnlock",
            "ErrCameraNoExistAlbum",
            "ErrCameraBeyondPhotoNum",
            "ErrCameraBeyondAlumNum",
            "ErrCameraNoAccessRight",
            "ErrCameraNoExistPhoto",
            "ErrCameraBeyondWordNum",
            "ErrCameraPhotoNoInAlbum",
            "ErrCameraInnerError",
            "ErrCameraIllegalRight",
            "ErrCameraNoExistChar",
            "ErrCameraNoDelCloudAlbum",
            "ErrCameraBeyondMaxURlLen",
            "ErrCameraBeyondMaxXMLLen",
            "ErrCameraBeyondMaxNameLen",
            "ErrCameraIllegalUrl",
            "ErrCameraRenderInfoEmpty",
            "ErrCameraBeyondPhotoMaxSize",
            "ErrCameraIllegalPictureType",
            "ErrCameraTypeRepeated",
            "ErrCameraWithoutOriginal",
            "ErrCameraWithoutThumbnailOrRender",
            "ErrCameraPhotoNameEmpty",
            "ErrCameraPhotoNameOutMaxLen",
            "ErrCameraAlbumNameEmpty",
            "ErrCameraPhotoHasDel",
            "ErrCameraSysInnerError",
            "ErrCameraIllegalPictureId",
            "ErrCameraBeyondMaxExtraLen",
            "ErrCameraNoIncludeOriginal",
            "ErrCameraNoDealingPhoto",
            "ErrCameraNoDealingPhotoType",
            "ErrCameraNoAnyAlbum",
            "ErrCameraNoPassReview",
            "ErrCameraPhotoMissImage",
            "ErrCameraWithoutThumbnail",
            "ErrCameraBeyondMaxUploadTimes",
            "ErrInvalidLifeProfessionId",
            "ErrLifeProfessionIsUnlock",
            "ErrLifeProfessionMaxLevel",
            "ErrLifeProfessionLevelNotEnough",
            "ErrLifeProfessionLevelRewardGot",
            "ErrInvalidLifeProfessionSpecializationId",
            "ErrLifeProfessionSpecializationNotEnough",
            "ErrLifeProfessionSpecializationUpgradeError",
            "ErrLifeProfessionPointNotEnough",
            "ErrInvalidLifeProfessionTargetId",
            "ErrLifeProfessionTargetNotEnough",
            "ErrLifeProfessionRewardCanNotGet",
            "ErrLifeProfessionEnergyChange",
            "ErrLifeProfessionRecipeIsUnlock",
            "ErrLifeProfessionRecipeNotExist",
            "ErrLifeProfessionRecipeNotUnlock",
            "ErrLifeProfessionMaxRDRecipeCount",
            "ErrLifeProfessionWorkingNotEnd",
            "ErrLifeProfessionAlreadyWorking",
            "ErrLifeProfessionNotWorking",
            "ErrLifeProfessionWorkingIsEnd",
            "ErrLifeProfessionUnActiveSpecialization",
            "ErrCurLevelConfigNotExist",
            "ErrNeedBreakthrough",
            "ErrExperienceConfigNotExist",
            "ErrExperienceMismatch",
            "ErrNotNeedToBreakthrough",
            "ErrConsumeConfigError",
            "ErrSkillNotExist",
            "ErrSkillLevelMax",
            "ErrSkillLevelNotExist",
            "ErrSkillConfigError",
            "ErrStarNotExist",
            "ErrMaxStar",
            "ErrMaxLevel",
            "ErrSkillLevelNotEnough",
            "ErrCanNotChangeActionState",
            "ErrActionNotExist",
            "ErrIsInteracting",
            "ErrState",
            "ErrRequestExpired",
            "ErrStateSetFailed",
            "ErrCollectIdError",
            "ErrCollectStateFailed",
            "ErrCollectActorErr",
            "ErrCollectOutRange",
            "ErrCollectConditionEquip",
            "ErrCollectConditionQuest",
            "ErrAlreadyCollected",
            "ErrMailGetFailed",
            "ErrMailIllegality",
            "ErrMailIsGet",
            "ErrMailIsDel",
            "ErrMailAcceptorEmpty",
            "ErrMailTokenInvalid",
            "ErrUnRegisterType",
            "ErrIndexNotFound",
            "ErrCantOpenTreasureBox",
            "ErrPersonalStateEnd",
            "ErrPersonalObjectStatus",
            "ErrExp",
            "ErrLevel",
            "ErrAward",
            "ErrReceivedLevelAward",
            "ErrLevelNotEnough",
            "ErrRoleLevelNoRewards",
            "ErrUnionNotHaveLimit",
            "ErrUnionIsNotMember",
            "ErrUnionOfficialNotExits",
            "ErrUnionOfficialTooMany",
            "ErrUnionHas",
            "ErrUnionReqCd",
            "ErrUnionReqHas",
            "ErrUnionFull",
            "ErrUnionFailed",
            "ErrUnionNameWrongful",
            "ErrUnionNameUsed",
            "ErrUnionNameOccupied",
            "ErrApplyMax",
            "ErrUnionChangeNameCD",
            "ErrUnionNameSizeError",
            "ErrDeclarationSize",
            "ErrDeclarationError",
            "ErrOfficialNameRepeat",
            "ErrDeclarationCd",
            "ErrUnionInfoCd",
            "ErrUnionNotExist",
            "ErrUnionIllegalConditionType",
            "ErrUnionRecruitSloganTooLong",
            "ErrUnionRecruitDescriptionTooLong",
            "ErrUnionCreateTooOften",
            "ErrUnionTagNoExist",
            "ErrUnionIconTooMuch",
            "ErrUnionGetListCd",
            "ErrUnionBatchSearchUnionIdsTooMuch",
            "ErrUnionBatchSearchCd",
            "ErrUnionGetCollectedIdsCd",
            "ErrUnionBeyondMaxCollectedNum",
            "ErrUnionIdHasCollected",
            "ErrUnionIdNoCollected",
            "ErrUnionActiveValueNotEnough",
            "ErrUnionIllegalActiveId",
            "ErrUnionTooShortForAwards",
            "ErrUnionHasActiveAwards",
            "ErrUnionNoJoin",
            "ErrUnionOnlyEnterSelf",
            "ErrUnionNoUnlockScene",
            "ErrUnionBuildingMaxLevel",
            "ErrUnionBuildingUpgrading",
            "ErrUnionBuildingUpgradeNoFinish",
            "ErrUnionPrefixBuildNoMeet",
            "ErrUnionExperienceNoEnough",
            "ErrUnionMoneyNoEnough",
            "ErrUnionBuildingNoUpgrading",
            "ErrUnionSpeedUpItemNoEnough",
            "ErrUnionSpeedUpTimesOut",
            "ErrUnionTryLater",
            "ErrUnionSpeedUpLevelError",
            "ErrUnionUpgradeHasCompleted",
            "ErrUnionIllegalBuildIdLv",
            "ErrUnionBeyMaxCount",
            "ErrUnionUserNoApply",
            "ErrUnionNoOneKeyNoMuch",
            "ErrUnionActivityNotStart",
            "ErrUnionActivityNotProgress",
            "ErrUnionActivityAwardGet",
            "ErrUnionActivityNotEnjoy",
            "ErrUnionCreateTimeTooShort",
            "ErrUnionFunctionLock",
            "ErrUnionEScreenLock",
            "ErrUnionEScreenPositionLock",
            "ErrUnionEScreenNoSet",
            "ErrUnionEScreenPositionNoSet",
            "ErrUnionEffectGridLock",
            "ErrUnionEffectIdLock",
            "ErrUnionEffectPosNoSet",
            "ErrUnionEffectPosHasEnd",
            "ErrUnionCrowFuncHasEnd",
            "ErrUnionCrowFuncPosHasUsed",
            "ErrUnionCrowFuncHasJoined",
            "ErrUnionCrowFuncNoBegin",
            "ErrUnionNoFinishBaseBuilding",
            "ErrUnionCrowFuncIllegalFuncPos",
            "ErrUnionEScreenBeyondMaxTimes",
            "ErrUnionTargetFunctionLock",
            "ErrUnionNoMeet",
            "ErrUnionActivityAwardCd",
            "ErrUnionManagerNoKicked",
            "ErrUnionDanceNoBegin",
            "ErrUnionDanceEnd",
            "ErrUnionDanceDrawnBox",
            "ErrUnionDanceBoxDrawn",
            "ErrUnionDanceNoDanceId",
            "ErrUnionNoJoinDance",
            "ErrUnionDanceNoDancing",
            "ErrUnionRejectInvite",
            "ErrUnionActivityHuntEnd",
            "ErrUnionApplyListFull",
            "ErrUionApplyListExist",
            "ErrUnionGroupIvalid",
            "ErrRepeatedRequest",
            "ErrHasBeenBlackened",
            "ErrNotFoundCharInfo",
            "ErrInner",
            "ErrParam",
            "ErrSetShowPicture",
            "ErrSetSignature",
            "ErrSetHobbyMark",
            "ErrSetTimeMark",
            "ErrSetRemind",
            "ErrSetTop",
            "ErrAddFriend",
            "ErrSetProcessed",
            "ErrSetRemark",
            "ErrDeleteFriend",
            "ErrNotFoundGroup",
            "ErrNotExistInGroup",
            "ErrChangeGroup",
            "ErrPersonalState",
            "ErrOtherFriendMax",
            "ErrCurFriendMax",
            "ErrConfig",
            "ErrAlreadyFriend",
            "ErrSearchSelf",
            "ErrSuggestionCd",
            "ErrGroupMax",
            "ErrGroupNotExist",
            "ErrGroupNameEmpty",
            "ErrIllegalCharacter",
            "ErrStringMax",
            "ErrOtherApplicationMax",
            "ErrFriendlinessAwardHasRecord",
            "ErrFriendlinessLevelLowAwardLevel",
            "ErrFriendBeyondAllFriendNum",
            "ErrFriendIsNoUserFriend",
            "ErrFriendlinessIllegalAwardLevel",
            "ErrFriendlinessLevelAwardIsEmpty",
            "ErrFriendBeBlackenedByTarget",
            "ErrFriendApplyEachOther",
            "ErrFriendCallBySmallerCharId",
            "ErrFriendCallByBiggerCharId",
            "ErrFriendBeBlackenedBySmaller",
            "ErrFriendBeBlackenedByBigger",
            "ErrFriendNoApply",
            "ErrFriendApplySelf",
            "ErrUserNameFormat",
            "ErrFriendGetBaseTooOften",
            "ErrFriendOnlyGetSelfBaseInfo",
            "ErrActorGetFailed",
            "ErrPivotIsActive",
            "ErrPivotIsNotActive",
            "ErrBreakPointIsGet",
            "ErrActorIsNotPivot",
            "ErrActorIsNotBreakPoint",
            "ErrActorIsBreakPointNotFull",
            "ErrPivotRewardIsGiven",
            "ErrNotInsight",
            "ErrLearnSkillFail",
            "ErrRemoveSkillFail",
            "ErrUpdateSkillFail",
            "ErrSkillOperatorType",
            "ErrContainerOperator",
            "ErrExchangeFail",
            "ErrExchangeFailInCombat",
            "ErrAvatarBeyondMaxPictureSize",
            "ErrGetTokenFailed",
            "ErrPictureVerifyFailed",
            "ErrPictureIllegalType",
            "ErrPictureErrorInfo",
            "ErrPictureSizeInconsistent",
            "ErrPictureFuncTypeIllegal",
            "ErrPictureCallBackJudgeIllegal",
            "ErrPictureVerifyNoPass",
            "ErrPictureVerifyBackParamIllegal",
            "ErrPictureCallBackParamIllegal",
            "ErrPictureIllegalId",
            "ErrPictureCosErrors",
            "ErrPictureInnerSysErr",
            "ErrPictureNoSetEnvCosSecretId",
            "ErrPictureNoSetEnvCosSecretKey",
            "ErrPictureCheckInMachineLocked",
            "ErrPictureNoTryOutItem",
            "ErrPictureNoUploadItem",
            "ErrPictureNoUnion",
            "ErrNameSizeError",
            "ErrSensitiveContent",
            "ErrChangeNameFail",
            "ErrChangeNameCardNotEnough",
            "ErrChangeSameName",
            "ErrCheckMuteWordsFailed",
            "ErrCheckMuteWordsEmpty",
            "ErrChangeShowIdFail",
            "ErrChangeShowIdDuplicated",
            "ErrChangeShowIdCardNotEnough",
            "ErrFaceItemLock",
            "ErrFaceItemGender",
            "ErrFaceNoUploading",
            "ErrFaceNoSupportFileSuffix",
            "ErrFaceFileSuffixEmpty",
            "ErrFaceIllegalCosKey",
            "ErrFaceParseSuffixFailed",
            "ErrFaceParseShortGuidFailed",
            "ErrProficiencyNeedUnlock",
            "ErrProficiencyUnlock",
            "ErrUnlockItemNotEnough",
            "ErrTaskNotFinish",
            "ErrStickerAwardIsGet",
            "ErrBookAwardIsGet",
            "ErrInCd",
            "ErrMoneyNotEnough",
            "ErrShopItemCantBuy",
            "ErrShopBuyBusy",
            "ErrPaymentConfigNotFound",
            "ErrRefreshShopCountExceed",
            "ErrShopCouponNotEnough",
            "ErrShopCouponLimitNum",
            "ErrShopCantBuyNoPrice",
            "ErrNotFoundMonster",
            "ErrNotMonster",
            "ErrMonsterUnlockExist",
            "ErrMonsterAwardIsGet",
            "ErrMonsterTargetNotFinish",
            "ErrDropTypeNotSupport",
            "ErrCounterNotEnough",
            "ErrDropItemAlreadyPicked",
            "ErrInteractionDoing",
            "ErrInteractionCondition",
            "ErrInteractionNotMore",
            "ErrInteractionExistPos",
            "ErrInteractionNotExist",
            "ErrInteractionEntityNotExist",
            "ErrInteractionHandleNotExist",
            "ErrInteractionType",
            "ErrInteractionBan",
            "ErrInteractionConfig",
            "ErrInteractionNotOneself",
            "ErrInteractionDistance",
            "ErrShowPieceIllegalPieceType",
            "ErrShowPieceIllegalPieceId",
            "ErrShowPieceNoInOftenUseList",
            "ErrShowPieceNoUnlockList",
            "ErrShowPieceRoulettePositionNoSet",
            "ErrShowPieceBeyondOftenUseMaxLen",
            "ErrShowPieceBeyondOftenRoulettePositionNum",
            "ErrShowPieceNoCommonPiece",
            "ErrShowPieceNoTakeOn",
            "ErrProfessionActivated",
            "ErrProfessionNotHas",
            "ErrProfessionSlotErr",
            "ErrProfessionRemoveErr",
            "ErrProfessionChangePlanFail",
            "ErrProfessionStarConfigNotExist",
            "ErrProfessionStarNodeUnlock",
            "ErrProfessionStarNodeNotUnlock",
            "ErrProfessionReplaceSkillNotExist",
            "ErrProfessionUpgradeNotGreaterCurLevel",
            "ErrProfessionProfessionBeForged",
            "ErrProfessionSlotTwoNotUnlock",
            "ErrProfessionSkillAlreadyActive",
            "ErrProfessionSkillRemodelLevelWrong",
            "ErrAoyiSkillAlreadyActive",
            "ErrAoyiSkillRemodelConfigNotExist",
            "ErrAoyiSkillRemodelLevelWrong",
            "ErrProfessionEquipInCombat",
            "ErrProfessionSwitchInCombat",
            "ErrProfessionDungeonNotAllowSwitch",
            "ErrTalentIllegalTalentPoolId",
            "ErrTalentBeyondCurTalentMaxPlanNum",
            "ErrTalentPoolNoActive",
            "ErrTalentPlanNoActive",
            "ErrTalentIllegalTalentId",
            "ErrTalentTalentHasUnlocked",
            "ErrTalentTalentNoUnlocked",
            "ErrTalentChangeLvPassiveTalentMoreThanInPool",
            "ErrTalentRepeatedTalentId",
            "ErrTalentNoPoolPassiveTalent",
            "ErrTalentTalentPointsNoEnough",
            "ErrTalentPassiveTalentListNoEmpty",
            "ErrTalentIllegalTalentLevel",
            "ErrTalentNoMeetUpgradeCondition",
            "ErrTalentNoSupportDownLevelNow",
            "ErrTalentNoMeetPrevTalentLv",
            "ErrTalentNoMeetPrevTalentPoint",
            "ErrTalentTreeNodeBDExclusive",
            "ErrTalentTotalTalentPointNotEnough",
            "ErrTalentPreTalentNodeNotActivated",
            "ErrTalentResetTalentInCombat",
            "ErrCookBookNotExist",
            "ErrCookFoodNotEnough",
            "ErrCookTypeMore",
            "ErrCookCountMore",
            "ErrCookHasBook",
            "ErrCookMaterialNotMatch",
            "ErrChatIllegalPrivateChatTarget",
            "ErrChatInTargetBlockList",
            "ErrChatSendMsgBeyondMaxWords",
            "ErrChatWorldChannelIdIsZero",
            "ErrChatWorldChannelIdBeyondMaxId",
            "ErrChatIllegalChannelType",
            "ErrChatIllegalMsgType",
            "ErrChatNoInGoalChannel",
            "ErrChatNeedConfigIdNotZero",
            "ErrChatNeedMsgTextNotEmpty",
            "ErrChatSendCdNoEnd",
            "ErrChatRecordListIsEmpty",
            "ErrChatTargetNotInPrivateList",
            "ErrChatMsgIdMoreThanMaxReadMsgId",
            "ErrChatBeyondBlockListLimit",
            "ErrChatWorldChannelIdBeyondMaxNum",
            "ErrChatBeyondMaxRecordId",
            "ErrChatNoCreatePrivateSession",
            "ErrChatPrivateSessionHasExit",
            "ErrChatBeBan",
            "ErrChatFileIdTooLong",
            "ErrChatFileIdEmpty",
            "ErrChatMsgInfoEmpty",
            "ErrChatNoShareChannel",
            "ErrChatIllegalShareType",
            "ErrChatIllegalHolderType",
            "ErrChatNoSupportShareType",
            "ErrChatShareTpeNoChatId",
            "ErrChatShareNoFishRank",
            "ErrChatLevelLimit",
            "ErrChatNoFoundBlockListLimit",
            "ErrTalentModTalentTagNotExist",
            "ErrTextCheckForbidden",
            "ErrTextCheckNoSceneType",
            "ErrTextCheckIllegal",
            "ErrTextCheckHttpError",
            "ErrTextCheckTooManyItems",
            "ErrConditionTimerOpen",
            "ErrConditionOpenServer",
            "ErrSkillDisable",
            "ErrSkillIsCD",
            "ErrSkillMaxPassiveCount",
            "ErrSkillInit",
            "ErrSkillInfo",
            "ErrUseSkillFightResInsufficient",
            "ErrUseSkillBuffNotEnough",
            "ErrUseSkillItemInsufficient",
            "ErrUseSkillAttrInsufficient",
            "ErrUseSkillEnduranceInsufficient",
            "ErrUseSkillStateChange",
            "ErrUseSkillClientSkillUuid",
            "ErrFightLogicConditionBlockInvalid",
            "ErrFightLogicActionGroupInvalid",
            "ErrFightLogicConditionNotMatch",
            "ErrFightLogicRunDataInvalid",
            "ErrSkillStageNotFind",
            "ErrConditionCfgSize",
            "ErrConditionDissatisfy",
            "ErrConditionObjectIsNull",
            "ErrConditionTypeNotFound",
            "ErrConditionEntityDeath",
            "ErrConditionUnionLevel",
            "ErrConditionUnionMoney",
            "ErrConditionNotMeet",
            "ErrConditionNotInShapeShift",
            "ErrSeasonAchievementNoExist",
            "ErrSeasonAchievementNoFinish",
            "ErrSeasonAchievementHasReceived",
            "ErrSeasonAchievementPrevIdNoReceived",
            "ErrSeasonAchievementPrevIdNoExist",
            "ErrSeasonAchievementTargetConfigError",
            "ErrSeasonRankHasMax",
            "ErrSeasonRankHasReceived",
            "ErrSeasonRankNoAchieve",
            "ErrSeasonRankCurSeasonIdZero",
            "ErrSeasonRankNoMeetCondition",
            "ErrSeasonRankSeasonNoSame",
            "ErrBattlePassBuyLevel",
            "ErrBattlePassBuyMaterial",
            "ErrBattlePassAwardGet",
            "ErrBattlePassAwardNotUnlock",
            "ErrBattlePassBuyWeekExpLimit",
            "ErrBattlePassLevelError",
            "ErrNoRefreshTimes",
            "ErrTargetNotCompleted",
            "ErrOnlinePeriodTooMore",
            "ErrPersonalTagTooMore",
            "ErrPersonalTagNotFound",
            "ErrPersonalAvatarUnearned",
            "ErrPersonalAvatarFrameUnearned",
            "ErrPersonalCardStyleUnearned",
            "ErrPersonalPhotoTooMore",
            "ErrPersonalMedalUnearned",
            "ErrPersonalTargetUnlock",
            "ErrPersonalTargetAlreadyGet",
            "ErrPersonalMedalInvalidSlot",
            "ErrPersonalMedalDuplicateValue",
            "ErrOnlinePeriodDuplicate",
            "ErrPersonalTagDuplicate",
            "ErrPersonalPhotoInvalidSlot",
            "ErrPersonalPhotoDuplicateValue",
            "ErrSeasonMedalNoMeetActiveCondition",
            "ErrSeasonMedalNoMeetUpgradeCondition",
            "ErrSeasonMedalActiveMeetNoEnough",
            "ErrSeasonMedalUpgradeMeetNoEnough",
            "ErrSeasonMedalIllegalNodeId",
            "ErrSeasonMedalChooseNodeIdBeyondMax",
            "ErrSeasonMedalHoleNoExist",
            "ErrSeasonMedalHoleLock",
            "ErrSeasonMedalNodeNoExist",
            "ErrSeasonMedalHoleNoGet",
            "ErrSeasonMedalMaxHoleLevel",
            "ErrSeasonMedalCoreHoleLock",
            "ErrSeasonMedalUpgradeMoneyNoEnough",
            "ErrSeasonNoCoreHole",
            "ErrSeasonNoNormalHole",
            "ErrSeasonMedalNoUpgradeNormalHoleItem",
            "ErrSceneLineNotExists",
            "ErrSceneLineRefreshCd",
            "ErrSceneLineNotSameScene",
            "ErrSceneLineSameLine",
            "ErrSceneLineInteracting",
            "ErrSceneLineUserDead",
            "ErrSceneLineFull",
            "ErrSceneLineChangeCd",
            "ErrSceneVersionRecycle",
            "ErrSceneLineKick",
            "ErrInstallSlotFailed",
            "ErrUseSlotFailed",
            "ErrUseSlotInCd",
            "ErrInstatallSlotFailedInCombat",
            "ErrSlotSkillUnLoad",
            "ErrUseCfgSkillFailed",
            "ErrResonanceNotExists",
            "ErrResonanceUnLoad",
            "ErrUseDodgeFailed",
            "ErrUseFixedSkillFailed",
            "ErrUseBlockedSkill",
            "ErrInstallBlockedSkill",
            "ErrExchangeNotFound",
            "ErrExchangeNotEnough",
            "ErrExchangeItemLimit",
            "ErrExchangeStepRange",
            "ErrExchangeItemFull",
            "ErrExchangePackageFull",
            "ErrExchangePriceItemNotFind",
            "ErrExchangeBuyNumNotEnough",
            "ErrExchangeBuyItemNotFound",
            "ErrExchangeTakeFailDelayTime",
            "ErrExchangeTakeFailSellNum",
            "ErrExchangeTakeItemNotFound",
            "ErrExchangeWithdrawNoMoney",
            "ErrExchangeDepositNotEnough",
            "ErrExchangeItemNotBindOrCooldownNotExpire",
            "ErrExchangeInCd",
            "ErrExchangeBuyCurrencyNoEnough",
            "ErrExchangeItemDelayTimeOver",
            "ErrExchangeItemIsNotWithdraw",
            "ErrExchangeBuyItemLimit",
            "ErrExchangeItemIsNotNoticeShopItem",
            "ErrExchangeItemIsPreBuyAlready",
            "ErrExchangeItemNotPublic",
            "ErrExchangeSaleRankExist",
            "ErrExchangeSaleItemFull",
            "ErrExchangeSaleDiamondNotEnough",
            "ErrExchangeSaleItemNotExists",
            "ErrExchangeBuySaleCurrencyNoEnough",
            "ErrExchangeDiamondNotEnough",
            "ErrExchangeSaleTakeOffCd",
            "ErrExchangeSaleRateInvalid",
            "ErrExchangePreItemFull",
            "ErrExchangeSaleNumInvalid",
            "ErrExchangeCareItemAlready",
            "ErrExchangePriceRange",
            "ErrExchangeRequestLimit",
            "ErrExchangeItemBanned",
            "ErrExchangePriceNotLow",
            "ErrExchangeItemNotFind",
            "ErrExchangeItemExistMinPrice",
            "ErrExchangeNoticeItemMin",
            "ErrExchangePreBuyUserFull",
            "ErrModHoleNotUnlock",
            "ErrModNotExist",
            "ErrModSimilarRepeated",
            "ErrModTypeLimitExceeded",
            "ErrModPartNotExist",
            "ErrModPartEnhanceLimit",
            "ErrModInUse",
            "ErrModAlreadyInstalled",
            "ErrModInitConfigNotExist",
            "ErrModPartOverflow",
            "ErrModCanNotLink",
            "ErrFishingNotUseBait",
            "ErrFishingRandomFailed",
            "ErrFishingAlreadyGetFishItem",
            "ErrFishingGetFishIdWrong",
            "ErrFishingNotGet",
            "ErrFishingNotResearchYet",
            "ErrFishingNotUseRod",
            "ErrFishingNoSeat",
            "ErrFishingCantResearch",
            "ErrFishDrawnLevelAward",
            "ErrFishCannotDrawLevelAward",
            "ErrFishDrawnNoLevelAward",
            "ErrFreightNoRefreshGoods",
            "ErrFreightBeyondMaxValue",
            "ErrFreightDownMinValue",
            "ErrFreightHasSetOff",
            "ErrFreightNoSetOff",
            "ErrFreightHasReward",
            "ErrFreightIllegalGoodsId",
            "ErrFreightItemNoEnough",
            "ErrFreightNoUpSetOffTime",
            "ErrFreightNoUpRewardTime",
            "ErrFreightAutoSetOff",
            "ErrTrialRoadAwardNotFinished",
            "ErrTrialRoadAwardRoomGet",
            "ErrNotCanRide",
            "ErrCombatStateNotRide",
            "ErrAlreadyRide",
            "ErrRideNotEnough",
            "ErrCreateVehicleActorFailed",
            "ErrNotVehicleOwner",
            "ErrVehicleHasController",
            "ErrVehicleNoSeat",
            "ErrVehicleHasSeat",
            "ErrNotRideVehicle",
            "ErrVehicleNotExits",
            "ErrInvalidRidePropertyType",
            "ErrRideApplyTargetUserNotExist",
            "ErrRideConfigNotFind",
            "ErrRideNotUnlock",
            "ErrRideNotFind",
            "ErrInvalidRideType",
            "ErrRideApplyAlreadyExist",
            "ErrRideApplyNotRideVehicle",
            "ErrRideApplyVehicleNotSeat",
            "ErrRideAlReadyRide",
            "ErrRideApplyTargetTooFar",
            "ErrRideNotTake",
            "ErrRideInteracting",
            "ErrShapeshiftNotRide",
            "ErrFishingNotRide",
            "ErrRideStateReject",
            "ErrRideTypeNotSupport",
            "ErrRideNotControl",
            "ErrRideNotFunction",
            "ErrRideSkinNotSupport",
            "ErrRideSkinNotUnlock",
            "ErrRideSkinDataAddFailed",
            "ErrRideSkinNotSkin",
            "ErrRideSkinAlreadyActivate",
            "ErrWarehouseHas",
            "ErrWarehouseNoHas",
            "ErrWarehouseNoMem",
            "ErrWarehouseNoPresident",
            "ErrWarehouseNoHasItem",
            "ErrWarehouseItemNoDeposit",
            "ErrWarehouseGridPosNoExist",
            "ErrWarehouseGridPosItemNoEnough",
            "ErrWarehouseNoInviteSelf",
            "ErrWarehouseInviteesHas",
            "ErrWarehouseMemBeyondMax",
            "ErrWarehouseGridBeyondMax",
            "ErrWarehouseNoSelf",
            "ErrWarehouseIsMem",
            "ErrWarehouseNoExist",
            "ErrWarehouseDepositBeyondMax",
            "ErrWarehouseTakeOutBeyondMax",
            "ErrWarehouseItemIdNotSame",
            "ErrWarehouseParams",
            "ErrWarehouseNoKickSelf",
            "ErrWarehousePresidentNoExit",
            "ErrGashaDrawCount",
            "ErrGashaDrawLimit",
            "ErrGashaInvalidWishId",
            "EErGashaWishRepeated",
            "EErGashaWishCountNoEnough",
            "ErrWarehouseAuthority",
            "ErrEquipCantDecompose",
            "ErrEquipNotRecastRecord",
            "ErrEquipOnCantUsedRecastConsume",
            "ErrEquipWeaponNotEqualProfession",
            "ErrEquipSlotRefineBlessNotFit",
            "ErrEquipNotRecast",
            "ErrEquipEnchantItemMismatch",
            "ErrEquipEnchantAlreadyEnchanted",
            "ErrEquipAnyItemMismatch",
            "ErrEquipSlotRefineBlessNumTooMuch",
            "ErrEquipNameGroupNoMatch",
            "ErrEquipPerfectionNoMatch",
            "ErrEquipNotBreak",
            "ErrEquipPutOnIng",
            "ErrUserIsMatching",
            "ErrUserNotInMatching",
            "ErrUseNotWaitReady",
            "ErrDungeonCantMatch",
            "ErrMatchQueueFull",
            "ErrCommonAwardCantReceive",
            "ErrCommonAwardHasReceived",
            "ErrCraftEnergyNotEnough",
            "ErrCraftEnergyFull",
            "ErrRecommendPlayNotOpen",
            "ErrWeeklyTowerNoStart",
            "ErrWeeklyTowerHasEnd",
            "ErrWeeklyNoMeetProcessAward",
            "ErrWeeklyHasRewardProcessAward",
            "ErrWeeklyNoLayerStageAward",
            "ErrWeekOnlyCurSeasonAward",
            "ErrWeeklyTowerCannotEnterLayer",
            "ErrWeeklyTowerBoxHasOpen",
            "ErrWeeklyTowerNoBox",
            "ErrWeeklyTowerNoStageAward",
            "ErrWeeklyTowerNoTowerDungeon",
            "ErrFunctionNoAward",
            "ErrFunctionHasDrawn",
            "ErrTLogIllegalExportArea",
            "ErrPayOrderFail",
            "ErrPayCostNotEnough",
            "ErrPayCantBuy",
            "ErrPayCantExplore",
            "ErrActivityNotFind",
            "ErrActivityOffline",
            "ErrActivityNotOpen",
            "ErrActivityRewardNotFound",
            "ErrActivityConditionNotFinish",
            "ErrActivityAlreadyObtain",
            "ErrActivityNotUnlock",
            "ErrEmojiConfigError",
            "ErrEmojiAlreadyUnlock",
            "ErrEmojiUnlockItemError",
            "ErrEmojiUnlockItemErrorItemNotEnough",
            "ErrEmojiUnlock",
            "ErrGlobalConditionNotFound",
            "ErrGlobalConditionNotLuckyValue",
            "ErrPathFindingCant",
            "ErrPathFindingDataError",
            "ErrPathFindingEndPosError",
            "ErrPathFindingStartPosError",
            "ErrPathFindingNoPath",
            "ErrSignNotOpen",
            "ErrSignNotSigned",
            "ErrSignAlreadySigned",
            "ErrSignTimeError",
            "ErrTokenBucketLimit",
            "ErrUnknown",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EErrorCode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ErrSuccess" => Ok(EErrorCode::ErrSuccess),
                    "ErrNoRecord" => Ok(EErrorCode::ErrNoRecord),
                    "ErrExceptionCancel" => Ok(EErrorCode::ErrExceptionCancel),
                    "ErrDBException" => Ok(EErrorCode::ErrDbException),
                    "ErrDBSeqException" => Ok(EErrorCode::ErrDbSeqException),
                    "ErrDBSceneException" => Ok(EErrorCode::ErrDbSceneException),
                    "ErrDBTokenException" => Ok(EErrorCode::ErrDbTokenException),
                    "ErrCancelled" => Ok(EErrorCode::ErrCancelled),
                    "ErrUnknownRpc" => Ok(EErrorCode::ErrUnknownRpc),
                    "ErrInvalidArgument" => Ok(EErrorCode::ErrInvalidArgument),
                    "ErrDeadlineExceeded" => Ok(EErrorCode::ErrDeadlineExceeded),
                    "ErrNotFound" => Ok(EErrorCode::ErrNotFound),
                    "ErrAlreadyExists" => Ok(EErrorCode::ErrAlreadyExists),
                    "ErrPermissionDenied" => Ok(EErrorCode::ErrPermissionDenied),
                    "ErrResourceExhausted" => Ok(EErrorCode::ErrResourceExhausted),
                    "ErrFailedPrecondition" => Ok(EErrorCode::ErrFailedPrecondition),
                    "ErrAborted" => Ok(EErrorCode::ErrAborted),
                    "ErrOutOfRange" => Ok(EErrorCode::ErrOutOfRange),
                    "ErrUnimplemented" => Ok(EErrorCode::ErrUnimplemented),
                    "ErrInternal" => Ok(EErrorCode::ErrInternal),
                    "ErrUnavailable" => Ok(EErrorCode::ErrUnavailable),
                    "ErrDataLoss" => Ok(EErrorCode::ErrDataLoss),
                    "ErrUnauthenticated" => Ok(EErrorCode::ErrUnauthenticated),
                    "ErrSystemMax" => Ok(EErrorCode::ErrSystemMax),
                    "ErrDBError" => Ok(EErrorCode::ErrDbError),
                    "ErrCreateOpenInfo" => Ok(EErrorCode::ErrCreateOpenInfo),
                    "ErrCreateAccountInfo" => Ok(EErrorCode::ErrCreateAccountInfo),
                    "ErrCreateCharInfo" => Ok(EErrorCode::ErrCreateCharInfo),
                    "ErrCreateAccountToken" => Ok(EErrorCode::ErrCreateAccountToken),
                    "ErrGetOpenInfo" => Ok(EErrorCode::ErrGetOpenInfo),
                    "ErrGetAccountInfo" => Ok(EErrorCode::ErrGetAccountInfo),
                    "ErrGetCharInfo" => Ok(EErrorCode::ErrGetCharInfo),
                    "ErrGetAccountToken" => Ok(EErrorCode::ErrGetAccountToken),
                    "ErrLoginInQueue" => Ok(EErrorCode::ErrLoginInQueue),
                    "ErrOtherLogin" => Ok(EErrorCode::ErrOtherLogin),
                    "ErrServerError" => Ok(EErrorCode::ErrServerError),
                    "ErrNoAccountInfo" => Ok(EErrorCode::ErrNoAccountInfo),
                    "ErrNoCharInfo" => Ok(EErrorCode::ErrNoCharInfo),
                    "ErrTokenExpired" => Ok(EErrorCode::ErrTokenExpired),
                    "ErrUpdateTokenFail" => Ok(EErrorCode::ErrUpdateTokenFail),
                    "ErrRegIntoSceneError" => Ok(EErrorCode::ErrRegIntoSceneError),
                    "ErrLoginTypeErr" => Ok(EErrorCode::ErrLoginTypeErr),
                    "ErrChangeMapErr" => Ok(EErrorCode::ErrChangeMapErr),
                    "ErrLoginPlatformErr" => Ok(EErrorCode::ErrLoginPlatformErr),
                    "ErrVersionErr" => Ok(EErrorCode::ErrVersionErr),
                    "ErrDelayOffLineKickOff" => Ok(EErrorCode::ErrDelayOffLineKickOff),
                    "ErrServiceLanguageError" => Ok(EErrorCode::ErrServiceLanguageError),
                    "NoEnterScene" => Ok(EErrorCode::NoEnterScene),
                    "ModIDNotOpen" => Ok(EErrorCode::ModIdNotOpen),
                    "ErrFaceData" => Ok(EErrorCode::ErrFaceData),
                    "ErrInitProfession" => Ok(EErrorCode::ErrInitProfession),
                    "ErrSceneCloseKickoff" => Ok(EErrorCode::ErrSceneCloseKickoff),
                    "ErrLoginReconnectKick" => Ok(EErrorCode::ErrLoginReconnectKick),
                    "ErrLoginErrorResume" => Ok(EErrorCode::ErrLoginErrorResume),
                    "ErrRepeatedLogin" => Ok(EErrorCode::ErrRepeatedLogin),
                    "ErrRestrictLogin" => Ok(EErrorCode::ErrRestrictLogin),
                    "ErrRestrictBlack" => Ok(EErrorCode::ErrRestrictBlack),
                    "ErrSdkVerifyFail" => Ok(EErrorCode::ErrSdkVerifyFail),
                    "ErrSdkTokenExpired" => Ok(EErrorCode::ErrSdkTokenExpired),
                    "ErrServerNotOpen" => Ok(EErrorCode::ErrServerNotOpen),
                    "ErrServerEndOpen" => Ok(EErrorCode::ErrServerEndOpen),
                    "ErrNormalKick" => Ok(EErrorCode::ErrNormalKick),
                    "ErrServerBusy" => Ok(EErrorCode::ErrServerBusy),
                    "ErrServerClose" => Ok(EErrorCode::ErrServerClose),
                    "ErrExitGame" => Ok(EErrorCode::ErrExitGame),
                    "ErrHopeKick" => Ok(EErrorCode::ErrHopeKick),
                    "ErrClientVersionError" => Ok(EErrorCode::ErrClientVersionError),
                    "ErrInvalidDeviceId" => Ok(EErrorCode::ErrInvalidDeviceId),
                    "ErrInvalidSystemType" => Ok(EErrorCode::ErrInvalidSystemType),
                    "ErrDeleteChar" => Ok(EErrorCode::ErrDeleteChar),
                    "ErrCancelDeleteChar" => Ok(EErrorCode::ErrCancelDeleteChar),
                    "ErrCancelDeleteCharIsDelete" => Ok(EErrorCode::ErrCancelDeleteCharIsDelete),
                    "ErrIntoSceneOwnerFail" => Ok(EErrorCode::ErrIntoSceneOwnerFail),
                    "ErrSceneQueueUp" => Ok(EErrorCode::ErrSceneQueueUp),
                    "ErrProtocolVersionErr" => Ok(EErrorCode::ErrProtocolVersionErr),
                    "ErrConfigVersionErr" => Ok(EErrorCode::ErrConfigVersionErr),
                    "ErrStateEventFailed" => Ok(EErrorCode::ErrStateEventFailed),
                    "ErrSelectCharDoing" => Ok(EErrorCode::ErrSelectCharDoing),
                    "ErrSelectCharDeleted" => Ok(EErrorCode::ErrSelectCharDeleted),
                    "ErrLoginChannelMax" => Ok(EErrorCode::ErrLoginChannelMax),
                    "ErrDeleteAccountKick" => Ok(EErrorCode::ErrDeleteAccountKick),
                    "ErrIsDeleteAccount" => Ok(EErrorCode::ErrIsDeleteAccount),
                    "ErrIsVersionKick" => Ok(EErrorCode::ErrIsVersionKick),
                    "ErrNotQQChnnel" => Ok(EErrorCode::ErrNotQqChnnel),
                    "ErrIncorrectLaunchPlatform" => Ok(EErrorCode::ErrIncorrectLaunchPlatform),
                    "ErrConditionWrong" => Ok(EErrorCode::ErrConditionWrong),
                    "ErrNotSupportLoginType" => Ok(EErrorCode::ErrNotSupportLoginType),
                    "ErrSceneNotExist" => Ok(EErrorCode::ErrSceneNotExist),
                    "ErrUserNotExist" => Ok(EErrorCode::ErrUserNotExist),
                    "ErrComponentNotExist" => Ok(EErrorCode::ErrComponentNotExist),
                    "ErrSceneConfigNotExist" => Ok(EErrorCode::ErrSceneConfigNotExist),
                    "ErrServiceNotExist" => Ok(EErrorCode::ErrServiceNotExist),
                    "ErrDataContainerNotExist" => Ok(EErrorCode::ErrDataContainerNotExist),
                    "ErrAsynchronousReturn" => Ok(EErrorCode::ErrAsynchronousReturn),
                    "ErrConfigNotExist" => Ok(EErrorCode::ErrConfigNotExist),
                    "ErrNotUser" => Ok(EErrorCode::ErrNotUser),
                    "ErrConfigError" => Ok(EErrorCode::ErrConfigError),
                    "ErrActorNotExist" => Ok(EErrorCode::ErrActorNotExist),
                    "ErrCutSceneAlreadyPlayed" => Ok(EErrorCode::ErrCutSceneAlreadyPlayed),
                    "ErrFunctionUnlock" => Ok(EErrorCode::ErrFunctionUnlock),
                    "ErrFunctionClosed" => Ok(EErrorCode::ErrFunctionClosed),
                    "ErrUserPlayerNotFurniturePackage" => Ok(EErrorCode::ErrUserPlayerNotFurniturePackage),
                    "ErrSysInnerError" => Ok(EErrorCode::ErrSysInnerError),
                    "ErrSysWebClientNull" => Ok(EErrorCode::ErrSysWebClientNull),
                    "ErrSysWebRequestTimeOut" => Ok(EErrorCode::ErrSysWebRequestTimeOut),
                    "ErrSysWebReturnError" => Ok(EErrorCode::ErrSysWebReturnError),
                    "ErrRequestTooFrequently" => Ok(EErrorCode::ErrRequestTooFrequently),
                    "ErrArgStringTooLong" => Ok(EErrorCode::ErrArgStringTooLong),
                    "ErrArgStringEmpty" => Ok(EErrorCode::ErrArgStringEmpty),
                    "ErrArgArrayTooBig" => Ok(EErrorCode::ErrArgArrayTooBig),
                    "ErrArgArrayEmpty" => Ok(EErrorCode::ErrArgArrayEmpty),
                    "ErrArgMapTooBig" => Ok(EErrorCode::ErrArgMapTooBig),
                    "ErrArgMapEmpty" => Ok(EErrorCode::ErrArgMapEmpty),
                    "ErrItemNotExist" => Ok(EErrorCode::ErrItemNotExist),
                    "ErrPackageNotExist" => Ok(EErrorCode::ErrPackageNotExist),
                    "ErrPackageFull" => Ok(EErrorCode::ErrPackageFull),
                    "ErrItemExpireTime" => Ok(EErrorCode::ErrItemExpireTime),
                    "ErrItemPackageGridNotEnough" => Ok(EErrorCode::ErrItemPackageGridNotEnough),
                    "ErrItemUUIDError" => Ok(EErrorCode::ErrItemUuidError),
                    "ErrItemNotEnough" => Ok(EErrorCode::ErrItemNotEnough),
                    "ErrOptTypeError" => Ok(EErrorCode::ErrOptTypeError),
                    "ErrItemInCoolDown" => Ok(EErrorCode::ErrItemInCoolDown),
                    "ErrItemNotUse" => Ok(EErrorCode::ErrItemNotUse),
                    "ErrItemEffectTypeError" => Ok(EErrorCode::ErrItemEffectTypeError),
                    "ErrItemParamError" => Ok(EErrorCode::ErrItemParamError),
                    "ErrItemAddBuffError" => Ok(EErrorCode::ErrItemAddBuffError),
                    "ErrItemAdd" => Ok(EErrorCode::ErrItemAdd),
                    "ErrUseItemState" => Ok(EErrorCode::ErrUseItemState),
                    "ErrBatchUse" => Ok(EErrorCode::ErrBatchUse),
                    "ErrFullSendMail" => Ok(EErrorCode::ErrFullSendMail),
                    "ErrItemNumZero" => Ok(EErrorCode::ErrItemNumZero),
                    "ErrItemSelectAwardIllegalNum" => Ok(EErrorCode::ErrItemSelectAwardIllegalNum),
                    "ErrItemSelectAwardIllegalPos" => Ok(EErrorCode::ErrItemSelectAwardIllegalPos),
                    "ErrItemSelectLimit" => Ok(EErrorCode::ErrItemSelectLimit),
                    "ErrItemPeriodGainExceeded" => Ok(EErrorCode::ErrItemPeriodGainExceeded),
                    "ErrItemNoRecycle" => Ok(EErrorCode::ErrItemNoRecycle),
                    "ErrItemRecycleBeyondMaxGrid" => Ok(EErrorCode::ErrItemRecycleBeyondMaxGrid),
                    "ErrItemRecycleBeyondMaxNum" => Ok(EErrorCode::ErrItemRecycleBeyondMaxNum),
                    "ErrItemRecycleIdNoMatchItemId" => Ok(EErrorCode::ErrItemRecycleIdNoMatchItemId),
                    "ErrItemRecycleIllegalId" => Ok(EErrorCode::ErrItemRecycleIllegalId),
                    "ErrItemLimitCount" => Ok(EErrorCode::ErrItemLimitCount),
                    "ErrItemFriendPontExceeded" => Ok(EErrorCode::ErrItemFriendPontExceeded),
                    "ErrItemToySingleEntUseExceeded" => Ok(EErrorCode::ErrItemToySingleEntUseExceeded),
                    "ErrItemToySceneUseExceeded" => Ok(EErrorCode::ErrItemToySceneUseExceeded),
                    "ErrItemToyUseInDisableArea" => Ok(EErrorCode::ErrItemToyUseInDisableArea),
                    "ErrItemToySingleCellUseExceeded" => Ok(EErrorCode::ErrItemToySingleCellUseExceeded),
                    "ErrMonthlyCardNotExists" => Ok(EErrorCode::ErrMonthlyCardNotExists),
                    "ErrMonthlyCardDataError" => Ok(EErrorCode::ErrMonthlyCardDataError),
                    "ErrMonthlyCardDayAwardReceived" => Ok(EErrorCode::ErrMonthlyCardDayAwardReceived),
                    "ErrMonthlyCardLimitCount" => Ok(EErrorCode::ErrMonthlyCardLimitCount),
                    "ErrCommunityNoHome" => Ok(EErrorCode::ErrCommunityNoHome),
                    "ErrNotHouseOwner" => Ok(EErrorCode::ErrNotHouseOwner),
                    "ErrHomeLandExisted" => Ok(EErrorCode::ErrHomeLandExisted),
                    "ErrHomeLandContentWrongful" => Ok(EErrorCode::ErrHomeLandContentWrongful),
                    "ErrHouseLivetogetherCD" => Ok(EErrorCode::ErrHouseLivetogetherCd),
                    "ErrHomeLandNotExisted" => Ok(EErrorCode::ErrHomeLandNotExisted),
                    "ErrHomeLandNotInScene" => Ok(EErrorCode::ErrHomeLandNotInScene),
                    "ErrHomeLandIsInvitation" => Ok(EErrorCode::ErrHomeLandIsInvitation),
                    "ErrHomeLandInsufficientAuthority" => Ok(EErrorCode::ErrHomeLandInsufficientAuthority),
                    "ErrHomeLandTransferRequestPending" => Ok(EErrorCode::ErrHomeLandTransferRequestPending),
                    "ErrHomeLandTransferRequestTimeout" => Ok(EErrorCode::ErrHomeLandTransferRequestTimeout),
                    "ErrHomeLandTransferCD" => Ok(EErrorCode::ErrHomeLandTransferCd),
                    "ErrHomelandTargetIsHasHome" => Ok(EErrorCode::ErrHomelandTargetIsHasHome),
                    "ErrHomelandTargetIsOwner" => Ok(EErrorCode::ErrHomelandTargetIsOwner),
                    "ErrHomelandNotOwnerCannotOperate" => Ok(EErrorCode::ErrHomelandNotOwnerCannotOperate),
                    "ErrHomeLandHasHouse" => Ok(EErrorCode::ErrHomeLandHasHouse),
                    "ErrHomeLandContentTooLong" => Ok(EErrorCode::ErrHomeLandContentTooLong),
                    "ErrHomeLandClutterNotExist" => Ok(EErrorCode::ErrHomeLandClutterNotExist),
                    "ErrHouseNameOrStatementCD" => Ok(EErrorCode::ErrHouseNameOrStatementCd),
                    "ErrHouseIntroductionStatementCD" => Ok(EErrorCode::ErrHouseIntroductionStatementCd),
                    "ErrCommunityBuildInvalidRecipeId" => Ok(EErrorCode::ErrCommunityBuildInvalidRecipeId),
                    "ErrCommunityBuildRecipeIsUnlock" => Ok(EErrorCode::ErrCommunityBuildRecipeIsUnlock),
                    "ErrCommunityBuildMax" => Ok(EErrorCode::ErrCommunityBuildMax),
                    "ErrCommunityBuildNoAuthority" => Ok(EErrorCode::ErrCommunityBuildNoAuthority),
                    "ErrCommunityNotBuildCannotCancel" => Ok(EErrorCode::ErrCommunityNotBuildCannotCancel),
                    "ErrCommunityBuildNotSelfCannotCancel" => Ok(EErrorCode::ErrCommunityBuildNotSelfCannotCancel),
                    "ErrCommunityNotBuildCannotAccelerate" => Ok(EErrorCode::ErrCommunityNotBuildCannotAccelerate),
                    "ErrCommunityBuildNotSelfCannotAccelerate" => Ok(EErrorCode::ErrCommunityBuildNotSelfCannotAccelerate),
                    "ErrCommunityBuildCannotAccelerate" => Ok(EErrorCode::ErrCommunityBuildCannotAccelerate),
                    "ErrCommunityBuildAlreadyAccelerate" => Ok(EErrorCode::ErrCommunityBuildAlreadyAccelerate),
                    "ErrCommunityBuildInDungeon" => Ok(EErrorCode::ErrCommunityBuildInDungeon),
                    "ErrCommunityBuildRecipeIsLock" => Ok(EErrorCode::ErrCommunityBuildRecipeIsLock),
                    "ErrCommunityBuildRecipeNotItemUnlock" => Ok(EErrorCode::ErrCommunityBuildRecipeNotItemUnlock),
                    "ErrCommunityBuildInvalidCount" => Ok(EErrorCode::ErrCommunityBuildInvalidCount),
                    "ErrCommunityNotBuildCannotReceive" => Ok(EErrorCode::ErrCommunityNotBuildCannotReceive),
                    "ErrCommunityCanNotBuild" => Ok(EErrorCode::ErrCommunityCanNotBuild),
                    "ErrHomeLandCohabitantLimit" => Ok(EErrorCode::ErrHomeLandCohabitantLimit),
                    "ErrHomeLandRootNotQuitCohabitant" => Ok(EErrorCode::ErrHomeLandRootNotQuitCohabitant),
                    "ErrHomeLandNotOwnerCannotQuitCohabitant" => Ok(EErrorCode::ErrHomeLandNotOwnerCannotQuitCohabitant),
                    "ErrHomeLandCohabitantIsExiting" => Ok(EErrorCode::ErrHomeLandCohabitantIsExiting),
                    "ErrHomeLandCohabitantNotExists" => Ok(EErrorCode::ErrHomeLandCohabitantNotExists),
                    "ErrHomeLandCohabitantExitRequestExists" => Ok(EErrorCode::ErrHomeLandCohabitantExitRequestExists),
                    "ErrHomeLandCohabitantDismiss" => Ok(EErrorCode::ErrHomeLandCohabitantDismiss),
                    "ErrHomeLandNotInvitation" => Ok(EErrorCode::ErrHomeLandNotInvitation),
                    "ErrHomeLandCohabitantInvitationTimeout" => Ok(EErrorCode::ErrHomeLandCohabitantInvitationTimeout),
                    "ErrHomeLandCohabitantNotFriend" => Ok(EErrorCode::ErrHomeLandCohabitantNotFriend),
                    "ErrHomeLandCohabitantFriendLevel" => Ok(EErrorCode::ErrHomeLandCohabitantFriendLevel),
                    "ErrHomeLandCohabitantLevel" => Ok(EErrorCode::ErrHomeLandCohabitantLevel),
                    "ErrHomeLandInviteCohabitantNotOwner" => Ok(EErrorCode::ErrHomeLandInviteCohabitantNotOwner),
                    "ErrCommunityWarehouseGridFull" => Ok(EErrorCode::ErrCommunityWarehouseGridFull),
                    "ErrCommunityWarehouseNoAuthority" => Ok(EErrorCode::ErrCommunityWarehouseNoAuthority),
                    "ErrCommunityWarehouseGridPosItemNoEnough" => Ok(EErrorCode::ErrCommunityWarehouseGridPosItemNoEnough),
                    "ErrHomeLandInsufficientFurniture" => Ok(EErrorCode::ErrHomeLandInsufficientFurniture),
                    "ErrCommunityWarehouseTakeOutCountLimit" => Ok(EErrorCode::ErrCommunityWarehouseTakeOutCountLimit),
                    "ErrHomeLandTaskNotExist" => Ok(EErrorCode::ErrHomeLandTaskNotExist),
                    "ErrHomeLandTaskTimeNotEnough" => Ok(EErrorCode::ErrHomeLandTaskTimeNotEnough),
                    "ErrHomeLandTaskAlreadyFinished" => Ok(EErrorCode::ErrHomeLandTaskAlreadyFinished),
                    "ErrHomeLandTaskItemNotEnough" => Ok(EErrorCode::ErrHomeLandTaskItemNotEnough),
                    "ErrHomeLandCurLevelError" => Ok(EErrorCode::ErrHomeLandCurLevelError),
                    "ErrHomeLandExpNotEnough" => Ok(EErrorCode::ErrHomeLandExpNotEnough),
                    "ErrHomeLandAlreadyMaxLevel" => Ok(EErrorCode::ErrHomeLandAlreadyMaxLevel),
                    "ErrHomeLandLevelLocked" => Ok(EErrorCode::ErrHomeLandLevelLocked),
                    "ErrHomeLandLevelConfigError" => Ok(EErrorCode::ErrHomeLandLevelConfigError),
                    "ErrCommunityEditorNotEditable" => Ok(EErrorCode::ErrCommunityEditorNotEditable),
                    "ErrCommunityEditorNotFurniture" => Ok(EErrorCode::ErrCommunityEditorNotFurniture),
                    "ErrCommunityEditorNotOutdoor" => Ok(EErrorCode::ErrCommunityEditorNotOutdoor),
                    "ErrCommunityEditorNotIndoor" => Ok(EErrorCode::ErrCommunityEditorNotIndoor),
                    "ErrCommunityEditorOverMax" => Ok(EErrorCode::ErrCommunityEditorOverMax),
                    "ErrCommunityEditorOverTypeMax" => Ok(EErrorCode::ErrCommunityEditorOverTypeMax),
                    "ErrCommunityEditorFurnitureNotEnough" => Ok(EErrorCode::ErrCommunityEditorFurnitureNotEnough),
                    "ErrCommunityEditorFurnitureNotExist" => Ok(EErrorCode::ErrCommunityEditorFurnitureNotExist),
                    "ErrCommunityEditorOverMaxGroup" => Ok(EErrorCode::ErrCommunityEditorOverMaxGroup),
                    "ErrCommunityEditorNoStructure" => Ok(EErrorCode::ErrCommunityEditorNoStructure),
                    "ErrCommunityEditorGroupMaxStructure" => Ok(EErrorCode::ErrCommunityEditorGroupMaxStructure),
                    "ErrCommunityEditorStructureInGroup" => Ok(EErrorCode::ErrCommunityEditorStructureInGroup),
                    "ErrCommunityEditorGroupNotExist" => Ok(EErrorCode::ErrCommunityEditorGroupNotExist),
                    "ErrCommunityEditorAlreadyExist" => Ok(EErrorCode::ErrCommunityEditorAlreadyExist),
                    "ErrHomeLandSellItemNotExist" => Ok(EErrorCode::ErrHomeLandSellItemNotExist),
                    "ErrHomeLandLeftNumNotEnough" => Ok(EErrorCode::ErrHomeLandLeftNumNotEnough),
                    "ErrHomeLandSellShopLocked" => Ok(EErrorCode::ErrHomeLandSellShopLocked),
                    "ErrHomeLandSeedExist" => Ok(EErrorCode::ErrHomeLandSeedExist),
                    "ErrHomeLandItemNotOwner" => Ok(EErrorCode::ErrHomeLandItemNotOwner),
                    "ErrHomeLandSeedStateError" => Ok(EErrorCode::ErrHomeLandSeedStateError),
                    "ErrHomeLandNoSeed" => Ok(EErrorCode::ErrHomeLandNoSeed),
                    "ErrHomeLandNoWater" => Ok(EErrorCode::ErrHomeLandNoWater),
                    "ErrHomeLandFertilizerMaxNumLimit" => Ok(EErrorCode::ErrHomeLandFertilizerMaxNumLimit),
                    "ErrHomeLandNotFertilize" => Ok(EErrorCode::ErrHomeLandNotFertilize),
                    "ErrHomeLandNotPollen" => Ok(EErrorCode::ErrHomeLandNotPollen),
                    "ErrHomeLandAlreadyPollen" => Ok(EErrorCode::ErrHomeLandAlreadyPollen),
                    "ErrHomeLandNotHarvest" => Ok(EErrorCode::ErrHomeLandNotHarvest),
                    "ErrHomeLandPickUpSinglePlayerLimit" => Ok(EErrorCode::ErrHomeLandPickUpSinglePlayerLimit),
                    "ErrHomeLandPickUpTotalLimit" => Ok(EErrorCode::ErrHomeLandPickUpTotalLimit),
                    "ErrHomeLandPickUpFlowerNotFinished" => Ok(EErrorCode::ErrHomeLandPickUpFlowerNotFinished),
                    "ErrHomeLandPickUpOwner" => Ok(EErrorCode::ErrHomeLandPickUpOwner),
                    "ErrHomeLandGainNotOwner" => Ok(EErrorCode::ErrHomeLandGainNotOwner),
                    "ErrHomeLandItemFullGrid" => Ok(EErrorCode::ErrHomeLandItemFullGrid),
                    "ErrHomeLandFurnitureFull" => Ok(EErrorCode::ErrHomeLandFurnitureFull),
                    "ErrComposeItemNotEnough" => Ok(EErrorCode::ErrComposeItemNotEnough),
                    "ErrComposeFailed" => Ok(EErrorCode::ErrComposeFailed),
                    "ErrRedemptionItemNotExist" => Ok(EErrorCode::ErrRedemptionItemNotExist),
                    "ErrRedemptionItemMaxCount" => Ok(EErrorCode::ErrRedemptionItemMaxCount),
                    "ErrRedemptionItemNotEnough" => Ok(EErrorCode::ErrRedemptionItemNotEnough),
                    "ErrRedemptionItemGender" => Ok(EErrorCode::ErrRedemptionItemGender),
                    "ErrAwardConfigNotFound" => Ok(EErrorCode::ErrAwardConfigNotFound),
                    "ErrAwardConfigWeightError" => Ok(EErrorCode::ErrAwardConfigWeightError),
                    "ErrAwardConfigLimitAndContentNotMatch" => Ok(EErrorCode::ErrAwardConfigLimitAndContentNotMatch),
                    "ErrAwardConfigContentSizeError" => Ok(EErrorCode::ErrAwardConfigContentSizeError),
                    "ErrAwardConfigContentRatesSizeError" => Ok(EErrorCode::ErrAwardConfigContentRatesSizeError),
                    "ErrAwardConfigContentWeightSizeError" => Ok(EErrorCode::ErrAwardConfigContentWeightSizeError),
                    "ErrAwardConfigGroupContentEmpty" => Ok(EErrorCode::ErrAwardConfigGroupContentEmpty),
                    "ErrAwardConfigGroupNumEmpty" => Ok(EErrorCode::ErrAwardConfigGroupNumEmpty),
                    "ErrAwardConfigGroupContentNoMatchGroupNum" => Ok(EErrorCode::ErrAwardConfigGroupContentNoMatchGroupNum),
                    "ErrAwardConfigNoRandomDrop" => Ok(EErrorCode::ErrAwardConfigNoRandomDrop),
                    "ErrAwardConfigNoSelectAward" => Ok(EErrorCode::ErrAwardConfigNoSelectAward),
                    "ErrAwardConfigSelfSelectContentNoItem" => Ok(EErrorCode::ErrAwardConfigSelfSelectContentNoItem),
                    "ErrAwardConfigWeightRateMustOne" => Ok(EErrorCode::ErrAwardConfigWeightRateMustOne),
                    "ErrAwardConfigGroupContentRandomNoMatch" => Ok(EErrorCode::ErrAwardConfigGroupContentRandomNoMatch),
                    "ErrAwardConfigGroupContentError" => Ok(EErrorCode::ErrAwardConfigGroupContentError),
                    "ErrAwardConfigPackageContentRandomNoMatch" => Ok(EErrorCode::ErrAwardConfigPackageContentRandomNoMatch),
                    "ErrAwardConfigLevelUpPackConfigPackageNoMatch" => Ok(EErrorCode::ErrAwardConfigLevelUpPackConfigPackageNoMatch),
                    "ErrAwardConfigProItemRuleNoMatch" => Ok(EErrorCode::ErrAwardConfigProItemRuleNoMatch),
                    "ErrAwardConfigPackageContentEmpty" => Ok(EErrorCode::ErrAwardConfigPackageContentEmpty),
                    "ErrAwardConfigDropContentSize" => Ok(EErrorCode::ErrAwardConfigDropContentSize),
                    "ErrAwardConfigDropContentNum" => Ok(EErrorCode::ErrAwardConfigDropContentNum),
                    "ErrAwardConfigGroupRateEmpty" => Ok(EErrorCode::ErrAwardConfigGroupRateEmpty),
                    "ErrAwardConfigGroupWeightEmpty" => Ok(EErrorCode::ErrAwardConfigGroupWeightEmpty),
                    "ErrAwardInnerError" => Ok(EErrorCode::ErrAwardInnerError),
                    "ErrAwardIllegalRandomType" => Ok(EErrorCode::ErrAwardIllegalRandomType),
                    "ErrAwardConditionNoMeet" => Ok(EErrorCode::ErrAwardConditionNoMeet),
                    "ErrAwardRandomTypeNone" => Ok(EErrorCode::ErrAwardRandomTypeNone),
                    "ErrAwardRandomTypeNoMatch" => Ok(EErrorCode::ErrAwardRandomTypeNoMatch),
                    "ErrAwardActorIsNull" => Ok(EErrorCode::ErrAwardActorIsNull),
                    "ErrEquipWashAttrNotExist" => Ok(EErrorCode::ErrEquipWashAttrNotExist),
                    "ErrNotEquipInCombat" => Ok(EErrorCode::ErrNotEquipInCombat),
                    "ErrEquipPart" => Ok(EErrorCode::ErrEquipPart),
                    "ErrComposeItemNotExist" => Ok(EErrorCode::ErrComposeItemNotExist),
                    "ErrPickupDropItemDistance" => Ok(EErrorCode::ErrPickupDropItemDistance),
                    "ErrPickupDropItemPackageFull" => Ok(EErrorCode::ErrPickupDropItemPackageFull),
                    "ErrPickupDropItemNoAuthority" => Ok(EErrorCode::ErrPickupDropItemNoAuthority),
                    "ErrLayerActorExist" => Ok(EErrorCode::ErrLayerActorExist),
                    "ErrTeamCreateHas" => Ok(EErrorCode::ErrTeamCreateHas),
                    "ErrTeamIllTarget" => Ok(EErrorCode::ErrTeamIllTarget),
                    "ErrTeamCreateTryLater" => Ok(EErrorCode::ErrTeamCreateTryLater),
                    "ErrTeamGetNo" => Ok(EErrorCode::ErrTeamGetNo),
                    "ErrTeamListEmpty" => Ok(EErrorCode::ErrTeamListEmpty),
                    "ErrTeamInner" => Ok(EErrorCode::ErrTeamInner),
                    "ErrTeamNoLeader" => Ok(EErrorCode::ErrTeamNoLeader),
                    "ErrTeamInMatch" => Ok(EErrorCode::ErrTeamInMatch),
                    "ErrTeamCustomizeTarget" => Ok(EErrorCode::ErrTeamCustomizeTarget),
                    "ErrTeamNoOwn" => Ok(EErrorCode::ErrTeamNoOwn),
                    "ErrTeamTickSelf" => Ok(EErrorCode::ErrTeamTickSelf),
                    "ErrTeamNoMem" => Ok(EErrorCode::ErrTeamNoMem),
                    "ErrTeamApplyingLeader" => Ok(EErrorCode::ErrTeamApplyingLeader),
                    "ErrTeamHasBeLeader" => Ok(EErrorCode::ErrTeamHasBeLeader),
                    "ErrTeamNoTransferSelf" => Ok(EErrorCode::ErrTeamNoTransferSelf),
                    "ErrTeamNoLeaderTransfer" => Ok(EErrorCode::ErrTeamNoLeaderTransfer),
                    "ErrTeamHasOwnTeam" => Ok(EErrorCode::ErrTeamHasOwnTeam),
                    "ErrTeamNoExist" => Ok(EErrorCode::ErrTeamNoExist),
                    "ErrTeamApplyInCD" => Ok(EErrorCode::ErrTeamApplyInCd),
                    "ErrTeamApplyExpire" => Ok(EErrorCode::ErrTeamApplyExpire),
                    "ErrTeamJoinOther" => Ok(EErrorCode::ErrTeamJoinOther),
                    "ErrTeamMemMax" => Ok(EErrorCode::ErrTeamMemMax),
                    "ErrTeamNoInvited" => Ok(EErrorCode::ErrTeamNoInvited),
                    "ErrTeamIsMatching" => Ok(EErrorCode::ErrTeamIsMatching),
                    "ErrTeamIllegalTag" => Ok(EErrorCode::ErrTeamIllegalTag),
                    "ErrTeamNoMatching" => Ok(EErrorCode::ErrTeamNoMatching),
                    "ErrTeamIllegalActivity" => Ok(EErrorCode::ErrTeamIllegalActivity),
                    "ErrTeamInActivity" => Ok(EErrorCode::ErrTeamInActivity),
                    "ErrTeamNoMeetCondition" => Ok(EErrorCode::ErrTeamNoMeetCondition),
                    "ErrTeamWaitVoting" => Ok(EErrorCode::ErrTeamWaitVoting),
                    "ErrTeamDoingActivity" => Ok(EErrorCode::ErrTeamDoingActivity),
                    "ErrTeamNoInVoting" => Ok(EErrorCode::ErrTeamNoInVoting),
                    "ErrTeamVoteEnd" => Ok(EErrorCode::ErrTeamVoteEnd),
                    "ErrTeamHasVoted" => Ok(EErrorCode::ErrTeamHasVoted),
                    "ErrTeamInviteCD" => Ok(EErrorCode::ErrTeamInviteCd),
                    "ErrTeamApplyLeadCD" => Ok(EErrorCode::ErrTeamApplyLeadCd),
                    "ErrTeamMoreMaxWorlds" => Ok(EErrorCode::ErrTeamMoreMaxWorlds),
                    "ErrTeamValidApplyInfo" => Ok(EErrorCode::ErrTeamValidApplyInfo),
                    "ErrTeamInMatchCancelCD" => Ok(EErrorCode::ErrTeamInMatchCancelCd),
                    "ErrTeamMatchFinished" => Ok(EErrorCode::ErrTeamMatchFinished),
                    "ErrTeamMatchWaitSec" => Ok(EErrorCode::ErrTeamMatchWaitSec),
                    "ErrTeamMemWorldFull" => Ok(EErrorCode::ErrTeamMemWorldFull),
                    "ErrTeamMemNotLeader" => Ok(EErrorCode::ErrTeamMemNotLeader),
                    "ErrTeamLeaderNotStaticScene" => Ok(EErrorCode::ErrTeamLeaderNotStaticScene),
                    "ErrTeamLeaderCallDoing" => Ok(EErrorCode::ErrTeamLeaderCallDoing),
                    "ErrTeamIllegalCallOperator" => Ok(EErrorCode::ErrTeamIllegalCallOperator),
                    "ErrTeamLeaderIllegalCallOperator" => Ok(EErrorCode::ErrTeamLeaderIllegalCallOperator),
                    "ErrTeamNoMemCall" => Ok(EErrorCode::ErrTeamNoMemCall),
                    "ErrTeamLeaderCallEnd" => Ok(EErrorCode::ErrTeamLeaderCallEnd),
                    "ErrTeamSameScene" => Ok(EErrorCode::ErrTeamSameScene),
                    "ErrTeamNotSameScene" => Ok(EErrorCode::ErrTeamNotSameScene),
                    "ErrTeamMemTooMore" => Ok(EErrorCode::ErrTeamMemTooMore),
                    "ErrTeamMemInDungeon" => Ok(EErrorCode::ErrTeamMemInDungeon),
                    "ErrTeamMemTooLess" => Ok(EErrorCode::ErrTeamMemTooLess),
                    "ErrTeamIllegalInviteType" => Ok(EErrorCode::ErrTeamIllegalInviteType),
                    "ErrTeamMemberNotInScene" => Ok(EErrorCode::ErrTeamMemberNotInScene),
                    "ErrTeamLeaderReadyCheckTimeNotReady" => Ok(EErrorCode::ErrTeamLeaderReadyCheckTimeNotReady),
                    "ErrTeamExistDungeonCheck" => Ok(EErrorCode::ErrTeamExistDungeonCheck),
                    "ErrTeamTargetMatchTalentLimit" => Ok(EErrorCode::ErrTeamTargetMatchTalentLimit),
                    "ErrTeamEditGroupNotAllowed" => Ok(EErrorCode::ErrTeamEditGroupNotAllowed),
                    "ErrTeamGroupNotExist" => Ok(EErrorCode::ErrTeamGroupNotExist),
                    "ErrTeamTargetNoMatchMemberType" => Ok(EErrorCode::ErrTeamTargetNoMatchMemberType),
                    "ErrDecomposeItemNotExist" => Ok(EErrorCode::ErrDecomposeItemNotExist),
                    "ErrDecomposeItemNotEnough" => Ok(EErrorCode::ErrDecomposeItemNotEnough),
                    "ErrRefineEnergyNotEnough" => Ok(EErrorCode::ErrRefineEnergyNotEnough),
                    "ErrRefineItemMaxCount" => Ok(EErrorCode::ErrRefineItemMaxCount),
                    "ErrRefineItemNotExist" => Ok(EErrorCode::ErrRefineItemNotExist),
                    "ErrRefineItemColumnNotUnlock" => Ok(EErrorCode::ErrRefineItemColumnNotUnlock),
                    "ErrRefineItemColumnUnlock" => Ok(EErrorCode::ErrRefineItemColumnUnlock),
                    "ErrRefineItemExist" => Ok(EErrorCode::ErrRefineItemExist),
                    "ErrEnergyLimitMax" => Ok(EErrorCode::ErrEnergyLimitMax),
                    "ErrRefineItemColumnNotEmpty" => Ok(EErrorCode::ErrRefineItemColumnNotEmpty),
                    "ErrProfessionNotExist" => Ok(EErrorCode::ErrProfessionNotExist),
                    "ErrModSlotNotUnlock" => Ok(EErrorCode::ErrModSlotNotUnlock),
                    "ErrChangeProfessionStateFail" => Ok(EErrorCode::ErrChangeProfessionStateFail),
                    "ErrChangeProfessionCDFail" => Ok(EErrorCode::ErrChangeProfessionCdFail),
                    "ErrProfessionSkinNotActive" => Ok(EErrorCode::ErrProfessionSkinNotActive),
                    "ErrProfessionSkinActive" => Ok(EErrorCode::ErrProfessionSkinActive),
                    "ErrProfessionNotUseSkin" => Ok(EErrorCode::ErrProfessionNotUseSkin),
                    "ErrProfessionSkillSkinActive" => Ok(EErrorCode::ErrProfessionSkillSkinActive),
                    "ErrProfessionSkillSkinNotActive" => Ok(EErrorCode::ErrProfessionSkillSkinNotActive),
                    "ErrProfessionSkillNotActive" => Ok(EErrorCode::ErrProfessionSkillNotActive),
                    "ErrCharOffline" => Ok(EErrorCode::ErrCharOffline),
                    "ErrUserDataBaseError" => Ok(EErrorCode::ErrUserDataBaseError),
                    "ErrCharGetFail" => Ok(EErrorCode::ErrCharGetFail),
                    "ErrAlreadyAlive" => Ok(EErrorCode::ErrAlreadyAlive),
                    "ErrReviveParam" => Ok(EErrorCode::ErrReviveParam),
                    "ErrStateIllegal" => Ok(EErrorCode::ErrStateIllegal),
                    "ErrStateNoChange" => Ok(EErrorCode::ErrStateNoChange),
                    "ErrReviveConsumeNotEnough" => Ok(EErrorCode::ErrReviveConsumeNotEnough),
                    "ErrReviveByOtherForbid" => Ok(EErrorCode::ErrReviveByOtherForbid),
                    "ErrReviveTimeNotArrived" => Ok(EErrorCode::ErrReviveTimeNotArrived),
                    "ErrReviveBossBattle" => Ok(EErrorCode::ErrReviveBossBattle),
                    "ErrReviveCountLimit" => Ok(EErrorCode::ErrReviveCountLimit),
                    "ErrReviveInDeadTp" => Ok(EErrorCode::ErrReviveInDeadTp),
                    "ErrDungeonPlayTypeError" => Ok(EErrorCode::ErrDungeonPlayTypeError),
                    "ErrDungeonNotExist" => Ok(EErrorCode::ErrDungeonNotExist),
                    "ErrDungeonCreateError" => Ok(EErrorCode::ErrDungeonCreateError),
                    "ErrCantChangeDungeon" => Ok(EErrorCode::ErrCantChangeDungeon),
                    "ErrDungeonLock" => Ok(EErrorCode::ErrDungeonLock),
                    "ErrPioneerFail" => Ok(EErrorCode::ErrPioneerFail),
                    "ErrAwardFail" => Ok(EErrorCode::ErrAwardFail),
                    "ErrGsNotEnough" => Ok(EErrorCode::ErrGsNotEnough),
                    "ErrQuestNotCompleted" => Ok(EErrorCode::ErrQuestNotCompleted),
                    "ErrDungeonNotClear" => Ok(EErrorCode::ErrDungeonNotClear),
                    "ErrConditionNotExist" => Ok(EErrorCode::ErrConditionNotExist),
                    "ErrAwardReceived" => Ok(EErrorCode::ErrAwardReceived),
                    "ErrCantRepeatedPlay" => Ok(EErrorCode::ErrCantRepeatedPlay),
                    "ErrNeedPassPreRoom" => Ok(EErrorCode::ErrNeedPassPreRoom),
                    "ErrDungeonEnterCountLimit" => Ok(EErrorCode::ErrDungeonEnterCountLimit),
                    "ErrDungeonScoreError" => Ok(EErrorCode::ErrDungeonScoreError),
                    "ErrDungeonRepeatedVote" => Ok(EErrorCode::ErrDungeonRepeatedVote),
                    "ErrDungeonChallengeAwardState" => Ok(EErrorCode::ErrDungeonChallengeAwardState),
                    "ErrDungeonChallengeAffixNotFound" => Ok(EErrorCode::ErrDungeonChallengeAffixNotFound),
                    "ErrDungeonStateNotActive" => Ok(EErrorCode::ErrDungeonStateNotActive),
                    "ErrDungeonCantVoteSelf" => Ok(EErrorCode::ErrDungeonCantVoteSelf),
                    "ErrDungeonPlayerNotEnough" => Ok(EErrorCode::ErrDungeonPlayerNotEnough),
                    "ErrDungeonPlayerFull" => Ok(EErrorCode::ErrDungeonPlayerFull),
                    "ErrDungeonCantHeroKey" => Ok(EErrorCode::ErrDungeonCantHeroKey),
                    "ErrDungeonNotSettlement" => Ok(EErrorCode::ErrDungeonNotSettlement),
                    "ErrDungeonNotFindRollItem" => Ok(EErrorCode::ErrDungeonNotFindRollItem),
                    "ErrDungeonCantRoll" => Ok(EErrorCode::ErrDungeonCantRoll),
                    "ErrDungeonRollFinish" => Ok(EErrorCode::ErrDungeonRollFinish),
                    "ErrDungeonSelectError" => Ok(EErrorCode::ErrDungeonSelectError),
                    "ErrDungeonAiModeError" => Ok(EErrorCode::ErrDungeonAiModeError),
                    "ErrDungeonTargetNotFinish" => Ok(EErrorCode::ErrDungeonTargetNotFinish),
                    "ErrDungeonTargetBeAward" => Ok(EErrorCode::ErrDungeonTargetBeAward),
                    "ErrDungeonSinglePlayerMore" => Ok(EErrorCode::ErrDungeonSinglePlayerMore),
                    "ErrDungeonAiGroupNotEnough" => Ok(EErrorCode::ErrDungeonAiGroupNotEnough),
                    "ErrDungeonNoPass" => Ok(EErrorCode::ErrDungeonNoPass),
                    "ErrDungeonCloseSceneId" => Ok(EErrorCode::ErrDungeonCloseSceneId),
                    "ErrDungeonEnterTypeError" => Ok(EErrorCode::ErrDungeonEnterTypeError),
                    "ErrDungeonActorCount" => Ok(EErrorCode::ErrDungeonActorCount),
                    "ErrDungeonDiffLocked" => Ok(EErrorCode::ErrDungeonDiffLocked),
                    "ErrDungeonPreBattleVoteCd" => Ok(EErrorCode::ErrDungeonPreBattleVoteCd),
                    "ErrDungeonBossInvalid" => Ok(EErrorCode::ErrDungeonBossInvalid),
                    "ErrDungeonNoUser" => Ok(EErrorCode::ErrDungeonNoUser),
                    "ErrDungeonUserInvalid" => Ok(EErrorCode::ErrDungeonUserInvalid),
                    "ErrDungeonAwardualification" => Ok(EErrorCode::ErrDungeonAwardualification),
                    "ErrDungeonAwardTriesLimit" => Ok(EErrorCode::ErrDungeonAwardTriesLimit),
                    "ErrFashionIsLimit" => Ok(EErrorCode::ErrFashionIsLimit),
                    "ErrFashionNotFound" => Ok(EErrorCode::ErrFashionNotFound),
                    "ErrFashionSlotEmpty" => Ok(EErrorCode::ErrFashionSlotEmpty),
                    "ErrFashionIDNotFound" => Ok(EErrorCode::ErrFashionIdNotFound),
                    "ErrFashionLock" => Ok(EErrorCode::ErrFashionLock),
                    "ErrFashCollectionAwardAlread" => Ok(EErrorCode::ErrFashCollectionAwardAlread),
                    "ErrFashCollectionScoreNotEnough" => Ok(EErrorCode::ErrFashCollectionScoreNotEnough),
                    "ErrFashCollectionAwardAlreadMonth" => Ok(EErrorCode::ErrFashCollectionAwardAlreadMonth),
                    "ErrFashionAlreadUnlock" => Ok(EErrorCode::ErrFashionAlreadUnlock),
                    "ErrFashionAdvanceNotExist" => Ok(EErrorCode::ErrFashionAdvanceNotExist),
                    "ErrFashionBaseNotUnlock" => Ok(EErrorCode::ErrFashionBaseNotUnlock),
                    "ErrFashionAdvanceAlreadyUnlock" => Ok(EErrorCode::ErrFashionAdvanceAlreadyUnlock),
                    "ErrCameraNoExistAlbum" => Ok(EErrorCode::ErrCameraNoExistAlbum),
                    "ErrCameraBeyondPhotoNum" => Ok(EErrorCode::ErrCameraBeyondPhotoNum),
                    "ErrCameraBeyondAlumNum" => Ok(EErrorCode::ErrCameraBeyondAlumNum),
                    "ErrCameraNoAccessRight" => Ok(EErrorCode::ErrCameraNoAccessRight),
                    "ErrCameraNoExistPhoto" => Ok(EErrorCode::ErrCameraNoExistPhoto),
                    "ErrCameraBeyondWordNum" => Ok(EErrorCode::ErrCameraBeyondWordNum),
                    "ErrCameraPhotoNoInAlbum" => Ok(EErrorCode::ErrCameraPhotoNoInAlbum),
                    "ErrCameraInnerError" => Ok(EErrorCode::ErrCameraInnerError),
                    "ErrCameraIllegalRight" => Ok(EErrorCode::ErrCameraIllegalRight),
                    "ErrCameraNoExistChar" => Ok(EErrorCode::ErrCameraNoExistChar),
                    "ErrCameraNoDelCloudAlbum" => Ok(EErrorCode::ErrCameraNoDelCloudAlbum),
                    "ErrCameraBeyondMaxURlLen" => Ok(EErrorCode::ErrCameraBeyondMaxURlLen),
                    "ErrCameraBeyondMaxXMLLen" => Ok(EErrorCode::ErrCameraBeyondMaxXmlLen),
                    "ErrCameraBeyondMaxNameLen" => Ok(EErrorCode::ErrCameraBeyondMaxNameLen),
                    "ErrCameraIllegalUrl" => Ok(EErrorCode::ErrCameraIllegalUrl),
                    "ErrCameraRenderInfoEmpty" => Ok(EErrorCode::ErrCameraRenderInfoEmpty),
                    "ErrCameraBeyondPhotoMaxSize" => Ok(EErrorCode::ErrCameraBeyondPhotoMaxSize),
                    "ErrCameraIllegalPictureType" => Ok(EErrorCode::ErrCameraIllegalPictureType),
                    "ErrCameraTypeRepeated" => Ok(EErrorCode::ErrCameraTypeRepeated),
                    "ErrCameraWithoutOriginal" => Ok(EErrorCode::ErrCameraWithoutOriginal),
                    "ErrCameraWithoutThumbnailOrRender" => Ok(EErrorCode::ErrCameraWithoutThumbnailOrRender),
                    "ErrCameraPhotoNameEmpty" => Ok(EErrorCode::ErrCameraPhotoNameEmpty),
                    "ErrCameraPhotoNameOutMaxLen" => Ok(EErrorCode::ErrCameraPhotoNameOutMaxLen),
                    "ErrCameraAlbumNameEmpty" => Ok(EErrorCode::ErrCameraAlbumNameEmpty),
                    "ErrCameraPhotoHasDel" => Ok(EErrorCode::ErrCameraPhotoHasDel),
                    "ErrCameraSysInnerError" => Ok(EErrorCode::ErrCameraSysInnerError),
                    "ErrCameraIllegalPictureId" => Ok(EErrorCode::ErrCameraIllegalPictureId),
                    "ErrCameraBeyondMaxExtraLen" => Ok(EErrorCode::ErrCameraBeyondMaxExtraLen),
                    "ErrCameraNoIncludeOriginal" => Ok(EErrorCode::ErrCameraNoIncludeOriginal),
                    "ErrCameraNoDealingPhoto" => Ok(EErrorCode::ErrCameraNoDealingPhoto),
                    "ErrCameraNoDealingPhotoType" => Ok(EErrorCode::ErrCameraNoDealingPhotoType),
                    "ErrCameraNoAnyAlbum" => Ok(EErrorCode::ErrCameraNoAnyAlbum),
                    "ErrCameraNoPassReview" => Ok(EErrorCode::ErrCameraNoPassReview),
                    "ErrCameraPhotoMissImage" => Ok(EErrorCode::ErrCameraPhotoMissImage),
                    "ErrCameraWithoutThumbnail" => Ok(EErrorCode::ErrCameraWithoutThumbnail),
                    "ErrCameraBeyondMaxUploadTimes" => Ok(EErrorCode::ErrCameraBeyondMaxUploadTimes),
                    "ErrInvalidLifeProfessionId" => Ok(EErrorCode::ErrInvalidLifeProfessionId),
                    "ErrLifeProfessionIsUnlock" => Ok(EErrorCode::ErrLifeProfessionIsUnlock),
                    "ErrLifeProfessionMaxLevel" => Ok(EErrorCode::ErrLifeProfessionMaxLevel),
                    "ErrLifeProfessionLevelNotEnough" => Ok(EErrorCode::ErrLifeProfessionLevelNotEnough),
                    "ErrLifeProfessionLevelRewardGot" => Ok(EErrorCode::ErrLifeProfessionLevelRewardGot),
                    "ErrInvalidLifeProfessionSpecializationId" => Ok(EErrorCode::ErrInvalidLifeProfessionSpecializationId),
                    "ErrLifeProfessionSpecializationNotEnough" => Ok(EErrorCode::ErrLifeProfessionSpecializationNotEnough),
                    "ErrLifeProfessionSpecializationUpgradeError" => Ok(EErrorCode::ErrLifeProfessionSpecializationUpgradeError),
                    "ErrLifeProfessionPointNotEnough" => Ok(EErrorCode::ErrLifeProfessionPointNotEnough),
                    "ErrInvalidLifeProfessionTargetId" => Ok(EErrorCode::ErrInvalidLifeProfessionTargetId),
                    "ErrLifeProfessionTargetNotEnough" => Ok(EErrorCode::ErrLifeProfessionTargetNotEnough),
                    "ErrLifeProfessionRewardCanNotGet" => Ok(EErrorCode::ErrLifeProfessionRewardCanNotGet),
                    "ErrLifeProfessionEnergyChange" => Ok(EErrorCode::ErrLifeProfessionEnergyChange),
                    "ErrLifeProfessionRecipeIsUnlock" => Ok(EErrorCode::ErrLifeProfessionRecipeIsUnlock),
                    "ErrLifeProfessionRecipeNotExist" => Ok(EErrorCode::ErrLifeProfessionRecipeNotExist),
                    "ErrLifeProfessionRecipeNotUnlock" => Ok(EErrorCode::ErrLifeProfessionRecipeNotUnlock),
                    "ErrLifeProfessionMaxRDRecipeCount" => Ok(EErrorCode::ErrLifeProfessionMaxRdRecipeCount),
                    "ErrLifeProfessionWorkingNotEnd" => Ok(EErrorCode::ErrLifeProfessionWorkingNotEnd),
                    "ErrLifeProfessionAlreadyWorking" => Ok(EErrorCode::ErrLifeProfessionAlreadyWorking),
                    "ErrLifeProfessionNotWorking" => Ok(EErrorCode::ErrLifeProfessionNotWorking),
                    "ErrLifeProfessionWorkingIsEnd" => Ok(EErrorCode::ErrLifeProfessionWorkingIsEnd),
                    "ErrLifeProfessionUnActiveSpecialization" => Ok(EErrorCode::ErrLifeProfessionUnActiveSpecialization),
                    "ErrCurLevelConfigNotExist" => Ok(EErrorCode::ErrCurLevelConfigNotExist),
                    "ErrNeedBreakthrough" => Ok(EErrorCode::ErrNeedBreakthrough),
                    "ErrExperienceConfigNotExist" => Ok(EErrorCode::ErrExperienceConfigNotExist),
                    "ErrExperienceMismatch" => Ok(EErrorCode::ErrExperienceMismatch),
                    "ErrNotNeedToBreakthrough" => Ok(EErrorCode::ErrNotNeedToBreakthrough),
                    "ErrConsumeConfigError" => Ok(EErrorCode::ErrConsumeConfigError),
                    "ErrSkillNotExist" => Ok(EErrorCode::ErrSkillNotExist),
                    "ErrSkillLevelMax" => Ok(EErrorCode::ErrSkillLevelMax),
                    "ErrSkillLevelNotExist" => Ok(EErrorCode::ErrSkillLevelNotExist),
                    "ErrSkillConfigError" => Ok(EErrorCode::ErrSkillConfigError),
                    "ErrStarNotExist" => Ok(EErrorCode::ErrStarNotExist),
                    "ErrMaxStar" => Ok(EErrorCode::ErrMaxStar),
                    "ErrMaxLevel" => Ok(EErrorCode::ErrMaxLevel),
                    "ErrSkillLevelNotEnough" => Ok(EErrorCode::ErrSkillLevelNotEnough),
                    "ErrCanNotChangeActionState" => Ok(EErrorCode::ErrCanNotChangeActionState),
                    "ErrActionNotExist" => Ok(EErrorCode::ErrActionNotExist),
                    "ErrIsInteracting" => Ok(EErrorCode::ErrIsInteracting),
                    "ErrState" => Ok(EErrorCode::ErrState),
                    "ErrRequestExpired" => Ok(EErrorCode::ErrRequestExpired),
                    "ErrStateSetFailed" => Ok(EErrorCode::ErrStateSetFailed),
                    "ErrCollectIdError" => Ok(EErrorCode::ErrCollectIdError),
                    "ErrCollectStateFailed" => Ok(EErrorCode::ErrCollectStateFailed),
                    "ErrCollectActorErr" => Ok(EErrorCode::ErrCollectActorErr),
                    "ErrCollectOutRange" => Ok(EErrorCode::ErrCollectOutRange),
                    "ErrCollectConditionEquip" => Ok(EErrorCode::ErrCollectConditionEquip),
                    "ErrCollectConditionQuest" => Ok(EErrorCode::ErrCollectConditionQuest),
                    "ErrAlreadyCollected" => Ok(EErrorCode::ErrAlreadyCollected),
                    "ErrMailGetFailed" => Ok(EErrorCode::ErrMailGetFailed),
                    "ErrMailIllegality" => Ok(EErrorCode::ErrMailIllegality),
                    "ErrMailIsGet" => Ok(EErrorCode::ErrMailIsGet),
                    "ErrMailIsDel" => Ok(EErrorCode::ErrMailIsDel),
                    "ErrMailAcceptorEmpty" => Ok(EErrorCode::ErrMailAcceptorEmpty),
                    "ErrMailTokenInvalid" => Ok(EErrorCode::ErrMailTokenInvalid),
                    "ErrUnRegisterType" => Ok(EErrorCode::ErrUnRegisterType),
                    "ErrIndexNotFound" => Ok(EErrorCode::ErrIndexNotFound),
                    "ErrCantOpenTreasureBox" => Ok(EErrorCode::ErrCantOpenTreasureBox),
                    "ErrPersonalStateEnd" => Ok(EErrorCode::ErrPersonalStateEnd),
                    "ErrPersonalObjectStatus" => Ok(EErrorCode::ErrPersonalObjectStatus),
                    "ErrExp" => Ok(EErrorCode::ErrExp),
                    "ErrLevel" => Ok(EErrorCode::ErrLevel),
                    "ErrAward" => Ok(EErrorCode::ErrAward),
                    "ErrReceivedLevelAward" => Ok(EErrorCode::ErrReceivedLevelAward),
                    "ErrLevelNotEnough" => Ok(EErrorCode::ErrLevelNotEnough),
                    "ErrRoleLevelNoRewards" => Ok(EErrorCode::ErrRoleLevelNoRewards),
                    "ErrUnionNotHaveLimit" => Ok(EErrorCode::ErrUnionNotHaveLimit),
                    "ErrUnionIsNotMember" => Ok(EErrorCode::ErrUnionIsNotMember),
                    "ErrUnionOfficialNotExits" => Ok(EErrorCode::ErrUnionOfficialNotExits),
                    "ErrUnionOfficialTooMany" => Ok(EErrorCode::ErrUnionOfficialTooMany),
                    "ErrUnionHas" => Ok(EErrorCode::ErrUnionHas),
                    "ErrUnionReqCd" => Ok(EErrorCode::ErrUnionReqCd),
                    "ErrUnionReqHas" => Ok(EErrorCode::ErrUnionReqHas),
                    "ErrUnionFull" => Ok(EErrorCode::ErrUnionFull),
                    "ErrUnionFailed" => Ok(EErrorCode::ErrUnionFailed),
                    "ErrUnionNameWrongful" => Ok(EErrorCode::ErrUnionNameWrongful),
                    "ErrUnionNameUsed" => Ok(EErrorCode::ErrUnionNameUsed),
                    "ErrUnionNameOccupied" => Ok(EErrorCode::ErrUnionNameOccupied),
                    "ErrApplyMax" => Ok(EErrorCode::ErrApplyMax),
                    "ErrUnionChangeNameCD" => Ok(EErrorCode::ErrUnionChangeNameCd),
                    "ErrUnionNameSizeError" => Ok(EErrorCode::ErrUnionNameSizeError),
                    "ErrDeclarationSize" => Ok(EErrorCode::ErrDeclarationSize),
                    "ErrDeclarationError" => Ok(EErrorCode::ErrDeclarationError),
                    "ErrOfficialNameRepeat" => Ok(EErrorCode::ErrOfficialNameRepeat),
                    "ErrDeclarationCd" => Ok(EErrorCode::ErrDeclarationCd),
                    "ErrUnionInfoCd" => Ok(EErrorCode::ErrUnionInfoCd),
                    "ErrUnionNotExist" => Ok(EErrorCode::ErrUnionNotExist),
                    "ErrUnionIllegalConditionType" => Ok(EErrorCode::ErrUnionIllegalConditionType),
                    "ErrUnionRecruitSloganTooLong" => Ok(EErrorCode::ErrUnionRecruitSloganTooLong),
                    "ErrUnionRecruitDescriptionTooLong" => Ok(EErrorCode::ErrUnionRecruitDescriptionTooLong),
                    "ErrUnionCreateTooOften" => Ok(EErrorCode::ErrUnionCreateTooOften),
                    "ErrUnionTagNoExist" => Ok(EErrorCode::ErrUnionTagNoExist),
                    "ErrUnionIconTooMuch" => Ok(EErrorCode::ErrUnionIconTooMuch),
                    "ErrUnionGetListCd" => Ok(EErrorCode::ErrUnionGetListCd),
                    "ErrUnionBatchSearchUnionIdsTooMuch" => Ok(EErrorCode::ErrUnionBatchSearchUnionIdsTooMuch),
                    "ErrUnionBatchSearchCd" => Ok(EErrorCode::ErrUnionBatchSearchCd),
                    "ErrUnionGetCollectedIdsCd" => Ok(EErrorCode::ErrUnionGetCollectedIdsCd),
                    "ErrUnionBeyondMaxCollectedNum" => Ok(EErrorCode::ErrUnionBeyondMaxCollectedNum),
                    "ErrUnionIdHasCollected" => Ok(EErrorCode::ErrUnionIdHasCollected),
                    "ErrUnionIdNoCollected" => Ok(EErrorCode::ErrUnionIdNoCollected),
                    "ErrUnionActiveValueNotEnough" => Ok(EErrorCode::ErrUnionActiveValueNotEnough),
                    "ErrUnionIllegalActiveId" => Ok(EErrorCode::ErrUnionIllegalActiveId),
                    "ErrUnionTooShortForAwards" => Ok(EErrorCode::ErrUnionTooShortForAwards),
                    "ErrUnionHasActiveAwards" => Ok(EErrorCode::ErrUnionHasActiveAwards),
                    "ErrUnionNoJoin" => Ok(EErrorCode::ErrUnionNoJoin),
                    "ErrUnionOnlyEnterSelf" => Ok(EErrorCode::ErrUnionOnlyEnterSelf),
                    "ErrUnionNoUnlockScene" => Ok(EErrorCode::ErrUnionNoUnlockScene),
                    "ErrUnionBuildingMaxLevel" => Ok(EErrorCode::ErrUnionBuildingMaxLevel),
                    "ErrUnionBuildingUpgrading" => Ok(EErrorCode::ErrUnionBuildingUpgrading),
                    "ErrUnionBuildingUpgradeNoFinish" => Ok(EErrorCode::ErrUnionBuildingUpgradeNoFinish),
                    "ErrUnionPrefixBuildNoMeet" => Ok(EErrorCode::ErrUnionPrefixBuildNoMeet),
                    "ErrUnionExperienceNoEnough" => Ok(EErrorCode::ErrUnionExperienceNoEnough),
                    "ErrUnionMoneyNoEnough" => Ok(EErrorCode::ErrUnionMoneyNoEnough),
                    "ErrUnionBuildingNoUpgrading" => Ok(EErrorCode::ErrUnionBuildingNoUpgrading),
                    "ErrUnionSpeedUpItemNoEnough" => Ok(EErrorCode::ErrUnionSpeedUpItemNoEnough),
                    "ErrUnionSpeedUpTimesOut" => Ok(EErrorCode::ErrUnionSpeedUpTimesOut),
                    "ErrUnionTryLater" => Ok(EErrorCode::ErrUnionTryLater),
                    "ErrUnionSpeedUpLevelError" => Ok(EErrorCode::ErrUnionSpeedUpLevelError),
                    "ErrUnionUpgradeHasCompleted" => Ok(EErrorCode::ErrUnionUpgradeHasCompleted),
                    "ErrUnionIllegalBuildIdLv" => Ok(EErrorCode::ErrUnionIllegalBuildIdLv),
                    "ErrUnionBeyMaxCount" => Ok(EErrorCode::ErrUnionBeyMaxCount),
                    "ErrUnionUserNoApply" => Ok(EErrorCode::ErrUnionUserNoApply),
                    "ErrUnionNoOneKeyNoMuch" => Ok(EErrorCode::ErrUnionNoOneKeyNoMuch),
                    "ErrUnionActivityNotStart" => Ok(EErrorCode::ErrUnionActivityNotStart),
                    "ErrUnionActivityNotProgress" => Ok(EErrorCode::ErrUnionActivityNotProgress),
                    "ErrUnionActivityAwardGet" => Ok(EErrorCode::ErrUnionActivityAwardGet),
                    "ErrUnionActivityNotEnjoy" => Ok(EErrorCode::ErrUnionActivityNotEnjoy),
                    "ErrUnionCreateTimeTooShort" => Ok(EErrorCode::ErrUnionCreateTimeTooShort),
                    "ErrUnionFunctionLock" => Ok(EErrorCode::ErrUnionFunctionLock),
                    "ErrUnionEScreenLock" => Ok(EErrorCode::ErrUnionEScreenLock),
                    "ErrUnionEScreenPositionLock" => Ok(EErrorCode::ErrUnionEScreenPositionLock),
                    "ErrUnionEScreenNoSet" => Ok(EErrorCode::ErrUnionEScreenNoSet),
                    "ErrUnionEScreenPositionNoSet" => Ok(EErrorCode::ErrUnionEScreenPositionNoSet),
                    "ErrUnionEffectGridLock" => Ok(EErrorCode::ErrUnionEffectGridLock),
                    "ErrUnionEffectIdLock" => Ok(EErrorCode::ErrUnionEffectIdLock),
                    "ErrUnionEffectPosNoSet" => Ok(EErrorCode::ErrUnionEffectPosNoSet),
                    "ErrUnionEffectPosHasEnd" => Ok(EErrorCode::ErrUnionEffectPosHasEnd),
                    "ErrUnionCrowFuncHasEnd" => Ok(EErrorCode::ErrUnionCrowFuncHasEnd),
                    "ErrUnionCrowFuncPosHasUsed" => Ok(EErrorCode::ErrUnionCrowFuncPosHasUsed),
                    "ErrUnionCrowFuncHasJoined" => Ok(EErrorCode::ErrUnionCrowFuncHasJoined),
                    "ErrUnionCrowFuncNoBegin" => Ok(EErrorCode::ErrUnionCrowFuncNoBegin),
                    "ErrUnionNoFinishBaseBuilding" => Ok(EErrorCode::ErrUnionNoFinishBaseBuilding),
                    "ErrUnionCrowFuncIllegalFuncPos" => Ok(EErrorCode::ErrUnionCrowFuncIllegalFuncPos),
                    "ErrUnionEScreenBeyondMaxTimes" => Ok(EErrorCode::ErrUnionEScreenBeyondMaxTimes),
                    "ErrUnionTargetFunctionLock" => Ok(EErrorCode::ErrUnionTargetFunctionLock),
                    "ErrUnionNoMeet" => Ok(EErrorCode::ErrUnionNoMeet),
                    "ErrUnionActivityAwardCd" => Ok(EErrorCode::ErrUnionActivityAwardCd),
                    "ErrUnionManagerNoKicked" => Ok(EErrorCode::ErrUnionManagerNoKicked),
                    "ErrUnionDanceNoBegin" => Ok(EErrorCode::ErrUnionDanceNoBegin),
                    "ErrUnionDanceEnd" => Ok(EErrorCode::ErrUnionDanceEnd),
                    "ErrUnionDanceDrawnBox" => Ok(EErrorCode::ErrUnionDanceDrawnBox),
                    "ErrUnionDanceBoxDrawn" => Ok(EErrorCode::ErrUnionDanceBoxDrawn),
                    "ErrUnionDanceNoDanceId" => Ok(EErrorCode::ErrUnionDanceNoDanceId),
                    "ErrUnionNoJoinDance" => Ok(EErrorCode::ErrUnionNoJoinDance),
                    "ErrUnionDanceNoDancing" => Ok(EErrorCode::ErrUnionDanceNoDancing),
                    "ErrUnionRejectInvite" => Ok(EErrorCode::ErrUnionRejectInvite),
                    "ErrUnionActivityHuntEnd" => Ok(EErrorCode::ErrUnionActivityHuntEnd),
                    "ErrUnionApplyListFull" => Ok(EErrorCode::ErrUnionApplyListFull),
                    "ErrUionApplyListExist" => Ok(EErrorCode::ErrUionApplyListExist),
                    "ErrUnionGroupIvalid" => Ok(EErrorCode::ErrUnionGroupIvalid),
                    "ErrRepeatedRequest" => Ok(EErrorCode::ErrRepeatedRequest),
                    "ErrHasBeenBlackened" => Ok(EErrorCode::ErrHasBeenBlackened),
                    "ErrNotFoundCharInfo" => Ok(EErrorCode::ErrNotFoundCharInfo),
                    "ErrInner" => Ok(EErrorCode::ErrInner),
                    "ErrParam" => Ok(EErrorCode::ErrParam),
                    "ErrSetShowPicture" => Ok(EErrorCode::ErrSetShowPicture),
                    "ErrSetSignature" => Ok(EErrorCode::ErrSetSignature),
                    "ErrSetHobbyMark" => Ok(EErrorCode::ErrSetHobbyMark),
                    "ErrSetTimeMark" => Ok(EErrorCode::ErrSetTimeMark),
                    "ErrSetRemind" => Ok(EErrorCode::ErrSetRemind),
                    "ErrSetTop" => Ok(EErrorCode::ErrSetTop),
                    "ErrAddFriend" => Ok(EErrorCode::ErrAddFriend),
                    "ErrSetProcessed" => Ok(EErrorCode::ErrSetProcessed),
                    "ErrSetRemark" => Ok(EErrorCode::ErrSetRemark),
                    "ErrDeleteFriend" => Ok(EErrorCode::ErrDeleteFriend),
                    "ErrNotFoundGroup" => Ok(EErrorCode::ErrNotFoundGroup),
                    "ErrNotExistInGroup" => Ok(EErrorCode::ErrNotExistInGroup),
                    "ErrChangeGroup" => Ok(EErrorCode::ErrChangeGroup),
                    "ErrPersonalState" => Ok(EErrorCode::ErrPersonalState),
                    "ErrOtherFriendMax" => Ok(EErrorCode::ErrOtherFriendMax),
                    "ErrCurFriendMax" => Ok(EErrorCode::ErrCurFriendMax),
                    "ErrConfig" => Ok(EErrorCode::ErrConfig),
                    "ErrAlreadyFriend" => Ok(EErrorCode::ErrAlreadyFriend),
                    "ErrSearchSelf" => Ok(EErrorCode::ErrSearchSelf),
                    "ErrSuggestionCd" => Ok(EErrorCode::ErrSuggestionCd),
                    "ErrGroupMax" => Ok(EErrorCode::ErrGroupMax),
                    "ErrGroupNotExist" => Ok(EErrorCode::ErrGroupNotExist),
                    "ErrGroupNameEmpty" => Ok(EErrorCode::ErrGroupNameEmpty),
                    "ErrIllegalCharacter" => Ok(EErrorCode::ErrIllegalCharacter),
                    "ErrStringMax" => Ok(EErrorCode::ErrStringMax),
                    "ErrOtherApplicationMax" => Ok(EErrorCode::ErrOtherApplicationMax),
                    "ErrFriendlinessAwardHasRecord" => Ok(EErrorCode::ErrFriendlinessAwardHasRecord),
                    "ErrFriendlinessLevelLowAwardLevel" => Ok(EErrorCode::ErrFriendlinessLevelLowAwardLevel),
                    "ErrFriendBeyondAllFriendNum" => Ok(EErrorCode::ErrFriendBeyondAllFriendNum),
                    "ErrFriendIsNoUserFriend" => Ok(EErrorCode::ErrFriendIsNoUserFriend),
                    "ErrFriendlinessIllegalAwardLevel" => Ok(EErrorCode::ErrFriendlinessIllegalAwardLevel),
                    "ErrFriendlinessLevelAwardIsEmpty" => Ok(EErrorCode::ErrFriendlinessLevelAwardIsEmpty),
                    "ErrFriendBeBlackenedByTarget" => Ok(EErrorCode::ErrFriendBeBlackenedByTarget),
                    "ErrFriendApplyEachOther" => Ok(EErrorCode::ErrFriendApplyEachOther),
                    "ErrFriendCallBySmallerCharId" => Ok(EErrorCode::ErrFriendCallBySmallerCharId),
                    "ErrFriendCallByBiggerCharId" => Ok(EErrorCode::ErrFriendCallByBiggerCharId),
                    "ErrFriendBeBlackenedBySmaller" => Ok(EErrorCode::ErrFriendBeBlackenedBySmaller),
                    "ErrFriendBeBlackenedByBigger" => Ok(EErrorCode::ErrFriendBeBlackenedByBigger),
                    "ErrFriendNoApply" => Ok(EErrorCode::ErrFriendNoApply),
                    "ErrFriendApplySelf" => Ok(EErrorCode::ErrFriendApplySelf),
                    "ErrUserNameFormat" => Ok(EErrorCode::ErrUserNameFormat),
                    "ErrFriendGetBaseTooOften" => Ok(EErrorCode::ErrFriendGetBaseTooOften),
                    "ErrFriendOnlyGetSelfBaseInfo" => Ok(EErrorCode::ErrFriendOnlyGetSelfBaseInfo),
                    "ErrActorGetFailed" => Ok(EErrorCode::ErrActorGetFailed),
                    "ErrPivotIsActive" => Ok(EErrorCode::ErrPivotIsActive),
                    "ErrPivotIsNotActive" => Ok(EErrorCode::ErrPivotIsNotActive),
                    "ErrBreakPointIsGet" => Ok(EErrorCode::ErrBreakPointIsGet),
                    "ErrActorIsNotPivot" => Ok(EErrorCode::ErrActorIsNotPivot),
                    "ErrActorIsNotBreakPoint" => Ok(EErrorCode::ErrActorIsNotBreakPoint),
                    "ErrActorIsBreakPointNotFull" => Ok(EErrorCode::ErrActorIsBreakPointNotFull),
                    "ErrPivotRewardIsGiven" => Ok(EErrorCode::ErrPivotRewardIsGiven),
                    "ErrNotInsight" => Ok(EErrorCode::ErrNotInsight),
                    "ErrLearnSkillFail" => Ok(EErrorCode::ErrLearnSkillFail),
                    "ErrRemoveSkillFail" => Ok(EErrorCode::ErrRemoveSkillFail),
                    "ErrUpdateSkillFail" => Ok(EErrorCode::ErrUpdateSkillFail),
                    "ErrSkillOperatorType" => Ok(EErrorCode::ErrSkillOperatorType),
                    "ErrContainerOperator" => Ok(EErrorCode::ErrContainerOperator),
                    "ErrExchangeFail" => Ok(EErrorCode::ErrExchangeFail),
                    "ErrExchangeFailInCombat" => Ok(EErrorCode::ErrExchangeFailInCombat),
                    "ErrAvatarBeyondMaxPictureSize" => Ok(EErrorCode::ErrAvatarBeyondMaxPictureSize),
                    "ErrGetTokenFailed" => Ok(EErrorCode::ErrGetTokenFailed),
                    "ErrPictureVerifyFailed" => Ok(EErrorCode::ErrPictureVerifyFailed),
                    "ErrPictureIllegalType" => Ok(EErrorCode::ErrPictureIllegalType),
                    "ErrPictureErrorInfo" => Ok(EErrorCode::ErrPictureErrorInfo),
                    "ErrPictureSizeInconsistent" => Ok(EErrorCode::ErrPictureSizeInconsistent),
                    "ErrPictureFuncTypeIllegal" => Ok(EErrorCode::ErrPictureFuncTypeIllegal),
                    "ErrPictureCallBackJudgeIllegal" => Ok(EErrorCode::ErrPictureCallBackJudgeIllegal),
                    "ErrPictureVerifyNoPass" => Ok(EErrorCode::ErrPictureVerifyNoPass),
                    "ErrPictureVerifyBackParamIllegal" => Ok(EErrorCode::ErrPictureVerifyBackParamIllegal),
                    "ErrPictureCallBackParamIllegal" => Ok(EErrorCode::ErrPictureCallBackParamIllegal),
                    "ErrPictureIllegalId" => Ok(EErrorCode::ErrPictureIllegalId),
                    "ErrPictureCosErrors" => Ok(EErrorCode::ErrPictureCosErrors),
                    "ErrPictureInnerSysErr" => Ok(EErrorCode::ErrPictureInnerSysErr),
                    "ErrPictureNoSetEnvCosSecretId" => Ok(EErrorCode::ErrPictureNoSetEnvCosSecretId),
                    "ErrPictureNoSetEnvCosSecretKey" => Ok(EErrorCode::ErrPictureNoSetEnvCosSecretKey),
                    "ErrPictureCheckInMachineLocked" => Ok(EErrorCode::ErrPictureCheckInMachineLocked),
                    "ErrPictureNoTryOutItem" => Ok(EErrorCode::ErrPictureNoTryOutItem),
                    "ErrPictureNoUploadItem" => Ok(EErrorCode::ErrPictureNoUploadItem),
                    "ErrPictureNoUnion" => Ok(EErrorCode::ErrPictureNoUnion),
                    "ErrNameSizeError" => Ok(EErrorCode::ErrNameSizeError),
                    "ErrSensitiveContent" => Ok(EErrorCode::ErrSensitiveContent),
                    "ErrChangeNameFail" => Ok(EErrorCode::ErrChangeNameFail),
                    "ErrChangeNameCardNotEnough" => Ok(EErrorCode::ErrChangeNameCardNotEnough),
                    "ErrChangeSameName" => Ok(EErrorCode::ErrChangeSameName),
                    "ErrCheckMuteWordsFailed" => Ok(EErrorCode::ErrCheckMuteWordsFailed),
                    "ErrCheckMuteWordsEmpty" => Ok(EErrorCode::ErrCheckMuteWordsEmpty),
                    "ErrChangeShowIdFail" => Ok(EErrorCode::ErrChangeShowIdFail),
                    "ErrChangeShowIdDuplicated" => Ok(EErrorCode::ErrChangeShowIdDuplicated),
                    "ErrChangeShowIdCardNotEnough" => Ok(EErrorCode::ErrChangeShowIdCardNotEnough),
                    "ErrFaceItemLock" => Ok(EErrorCode::ErrFaceItemLock),
                    "ErrFaceItemGender" => Ok(EErrorCode::ErrFaceItemGender),
                    "ErrFaceNoUploading" => Ok(EErrorCode::ErrFaceNoUploading),
                    "ErrFaceNoSupportFileSuffix" => Ok(EErrorCode::ErrFaceNoSupportFileSuffix),
                    "ErrFaceFileSuffixEmpty" => Ok(EErrorCode::ErrFaceFileSuffixEmpty),
                    "ErrFaceIllegalCosKey" => Ok(EErrorCode::ErrFaceIllegalCosKey),
                    "ErrFaceParseSuffixFailed" => Ok(EErrorCode::ErrFaceParseSuffixFailed),
                    "ErrFaceParseShortGuidFailed" => Ok(EErrorCode::ErrFaceParseShortGuidFailed),
                    "ErrProficiencyNeedUnlock" => Ok(EErrorCode::ErrProficiencyNeedUnlock),
                    "ErrProficiencyUnlock" => Ok(EErrorCode::ErrProficiencyUnlock),
                    "ErrUnlockItemNotEnough" => Ok(EErrorCode::ErrUnlockItemNotEnough),
                    "ErrTaskNotFinish" => Ok(EErrorCode::ErrTaskNotFinish),
                    "ErrStickerAwardIsGet" => Ok(EErrorCode::ErrStickerAwardIsGet),
                    "ErrBookAwardIsGet" => Ok(EErrorCode::ErrBookAwardIsGet),
                    "ErrInCd" => Ok(EErrorCode::ErrInCd),
                    "ErrMoneyNotEnough" => Ok(EErrorCode::ErrMoneyNotEnough),
                    "ErrShopItemCantBuy" => Ok(EErrorCode::ErrShopItemCantBuy),
                    "ErrShopBuyBusy" => Ok(EErrorCode::ErrShopBuyBusy),
                    "ErrPaymentConfigNotFound" => Ok(EErrorCode::ErrPaymentConfigNotFound),
                    "ErrRefreshShopCountExceed" => Ok(EErrorCode::ErrRefreshShopCountExceed),
                    "ErrShopCouponNotEnough" => Ok(EErrorCode::ErrShopCouponNotEnough),
                    "ErrShopCouponLimitNum" => Ok(EErrorCode::ErrShopCouponLimitNum),
                    "ErrShopCantBuyNoPrice" => Ok(EErrorCode::ErrShopCantBuyNoPrice),
                    "ErrNotFoundMonster" => Ok(EErrorCode::ErrNotFoundMonster),
                    "ErrNotMonster" => Ok(EErrorCode::ErrNotMonster),
                    "ErrMonsterUnlockExist" => Ok(EErrorCode::ErrMonsterUnlockExist),
                    "ErrMonsterAwardIsGet" => Ok(EErrorCode::ErrMonsterAwardIsGet),
                    "ErrMonsterTargetNotFinish" => Ok(EErrorCode::ErrMonsterTargetNotFinish),
                    "ErrDropTypeNotSupport" => Ok(EErrorCode::ErrDropTypeNotSupport),
                    "ErrCounterNotEnough" => Ok(EErrorCode::ErrCounterNotEnough),
                    "ErrDropItemAlreadyPicked" => Ok(EErrorCode::ErrDropItemAlreadyPicked),
                    "ErrInteractionDoing" => Ok(EErrorCode::ErrInteractionDoing),
                    "ErrInteractionCondition" => Ok(EErrorCode::ErrInteractionCondition),
                    "ErrInteractionNotMore" => Ok(EErrorCode::ErrInteractionNotMore),
                    "ErrInteractionExistPos" => Ok(EErrorCode::ErrInteractionExistPos),
                    "ErrInteractionNotExist" => Ok(EErrorCode::ErrInteractionNotExist),
                    "ErrInteractionEntityNotExist" => Ok(EErrorCode::ErrInteractionEntityNotExist),
                    "ErrInteractionHandleNotExist" => Ok(EErrorCode::ErrInteractionHandleNotExist),
                    "ErrInteractionType" => Ok(EErrorCode::ErrInteractionType),
                    "ErrInteractionBan" => Ok(EErrorCode::ErrInteractionBan),
                    "ErrInteractionConfig" => Ok(EErrorCode::ErrInteractionConfig),
                    "ErrInteractionNotOneself" => Ok(EErrorCode::ErrInteractionNotOneself),
                    "ErrInteractionDistance" => Ok(EErrorCode::ErrInteractionDistance),
                    "ErrShowPieceIllegalPieceType" => Ok(EErrorCode::ErrShowPieceIllegalPieceType),
                    "ErrShowPieceIllegalPieceId" => Ok(EErrorCode::ErrShowPieceIllegalPieceId),
                    "ErrShowPieceNoInOftenUseList" => Ok(EErrorCode::ErrShowPieceNoInOftenUseList),
                    "ErrShowPieceNoUnlockList" => Ok(EErrorCode::ErrShowPieceNoUnlockList),
                    "ErrShowPieceRoulettePositionNoSet" => Ok(EErrorCode::ErrShowPieceRoulettePositionNoSet),
                    "ErrShowPieceBeyondOftenUseMaxLen" => Ok(EErrorCode::ErrShowPieceBeyondOftenUseMaxLen),
                    "ErrShowPieceBeyondOftenRoulettePositionNum" => Ok(EErrorCode::ErrShowPieceBeyondOftenRoulettePositionNum),
                    "ErrShowPieceNoCommonPiece" => Ok(EErrorCode::ErrShowPieceNoCommonPiece),
                    "ErrShowPieceNoTakeOn" => Ok(EErrorCode::ErrShowPieceNoTakeOn),
                    "ErrProfessionActivated" => Ok(EErrorCode::ErrProfessionActivated),
                    "ErrProfessionNotHas" => Ok(EErrorCode::ErrProfessionNotHas),
                    "ErrProfessionSlotErr" => Ok(EErrorCode::ErrProfessionSlotErr),
                    "ErrProfessionRemoveErr" => Ok(EErrorCode::ErrProfessionRemoveErr),
                    "ErrProfessionChangePlanFail" => Ok(EErrorCode::ErrProfessionChangePlanFail),
                    "ErrProfessionStarConfigNotExist" => Ok(EErrorCode::ErrProfessionStarConfigNotExist),
                    "ErrProfessionStarNodeUnlock" => Ok(EErrorCode::ErrProfessionStarNodeUnlock),
                    "ErrProfessionStarNodeNotUnlock" => Ok(EErrorCode::ErrProfessionStarNodeNotUnlock),
                    "ErrProfessionReplaceSkillNotExist" => Ok(EErrorCode::ErrProfessionReplaceSkillNotExist),
                    "ErrProfessionUpgradeNotGreaterCurLevel" => Ok(EErrorCode::ErrProfessionUpgradeNotGreaterCurLevel),
                    "ErrProfessionProfessionBeForged" => Ok(EErrorCode::ErrProfessionProfessionBeForged),
                    "ErrProfessionSlotTwoNotUnlock" => Ok(EErrorCode::ErrProfessionSlotTwoNotUnlock),
                    "ErrProfessionSkillAlreadyActive" => Ok(EErrorCode::ErrProfessionSkillAlreadyActive),
                    "ErrProfessionSkillRemodelLevelWrong" => Ok(EErrorCode::ErrProfessionSkillRemodelLevelWrong),
                    "ErrAoyiSkillAlreadyActive" => Ok(EErrorCode::ErrAoyiSkillAlreadyActive),
                    "ErrAoyiSkillRemodelConfigNotExist" => Ok(EErrorCode::ErrAoyiSkillRemodelConfigNotExist),
                    "ErrAoyiSkillRemodelLevelWrong" => Ok(EErrorCode::ErrAoyiSkillRemodelLevelWrong),
                    "ErrProfessionEquipInCombat" => Ok(EErrorCode::ErrProfessionEquipInCombat),
                    "ErrProfessionSwitchInCombat" => Ok(EErrorCode::ErrProfessionSwitchInCombat),
                    "ErrProfessionDungeonNotAllowSwitch" => Ok(EErrorCode::ErrProfessionDungeonNotAllowSwitch),
                    "ErrTalentIllegalTalentPoolId" => Ok(EErrorCode::ErrTalentIllegalTalentPoolId),
                    "ErrTalentBeyondCurTalentMaxPlanNum" => Ok(EErrorCode::ErrTalentBeyondCurTalentMaxPlanNum),
                    "ErrTalentPoolNoActive" => Ok(EErrorCode::ErrTalentPoolNoActive),
                    "ErrTalentPlanNoActive" => Ok(EErrorCode::ErrTalentPlanNoActive),
                    "ErrTalentIllegalTalentId" => Ok(EErrorCode::ErrTalentIllegalTalentId),
                    "ErrTalentTalentHasUnlocked" => Ok(EErrorCode::ErrTalentTalentHasUnlocked),
                    "ErrTalentTalentNoUnlocked" => Ok(EErrorCode::ErrTalentTalentNoUnlocked),
                    "ErrTalentChangeLvPassiveTalentMoreThanInPool" => Ok(EErrorCode::ErrTalentChangeLvPassiveTalentMoreThanInPool),
                    "ErrTalentRepeatedTalentId" => Ok(EErrorCode::ErrTalentRepeatedTalentId),
                    "ErrTalentNoPoolPassiveTalent" => Ok(EErrorCode::ErrTalentNoPoolPassiveTalent),
                    "ErrTalentTalentPointsNoEnough" => Ok(EErrorCode::ErrTalentTalentPointsNoEnough),
                    "ErrTalentPassiveTalentListNoEmpty" => Ok(EErrorCode::ErrTalentPassiveTalentListNoEmpty),
                    "ErrTalentIllegalTalentLevel" => Ok(EErrorCode::ErrTalentIllegalTalentLevel),
                    "ErrTalentNoMeetUpgradeCondition" => Ok(EErrorCode::ErrTalentNoMeetUpgradeCondition),
                    "ErrTalentNoSupportDownLevelNow" => Ok(EErrorCode::ErrTalentNoSupportDownLevelNow),
                    "ErrTalentNoMeetPrevTalentLv" => Ok(EErrorCode::ErrTalentNoMeetPrevTalentLv),
                    "ErrTalentNoMeetPrevTalentPoint" => Ok(EErrorCode::ErrTalentNoMeetPrevTalentPoint),
                    "ErrTalentTreeNodeBDExclusive" => Ok(EErrorCode::ErrTalentTreeNodeBdExclusive),
                    "ErrTalentTotalTalentPointNotEnough" => Ok(EErrorCode::ErrTalentTotalTalentPointNotEnough),
                    "ErrTalentPreTalentNodeNotActivated" => Ok(EErrorCode::ErrTalentPreTalentNodeNotActivated),
                    "ErrTalentResetTalentInCombat" => Ok(EErrorCode::ErrTalentResetTalentInCombat),
                    "ErrCookBookNotExist" => Ok(EErrorCode::ErrCookBookNotExist),
                    "ErrCookFoodNotEnough" => Ok(EErrorCode::ErrCookFoodNotEnough),
                    "ErrCookTypeMore" => Ok(EErrorCode::ErrCookTypeMore),
                    "ErrCookCountMore" => Ok(EErrorCode::ErrCookCountMore),
                    "ErrCookHasBook" => Ok(EErrorCode::ErrCookHasBook),
                    "ErrCookMaterialNotMatch" => Ok(EErrorCode::ErrCookMaterialNotMatch),
                    "ErrChatIllegalPrivateChatTarget" => Ok(EErrorCode::ErrChatIllegalPrivateChatTarget),
                    "ErrChatInTargetBlockList" => Ok(EErrorCode::ErrChatInTargetBlockList),
                    "ErrChatSendMsgBeyondMaxWords" => Ok(EErrorCode::ErrChatSendMsgBeyondMaxWords),
                    "ErrChatWorldChannelIdIsZero" => Ok(EErrorCode::ErrChatWorldChannelIdIsZero),
                    "ErrChatWorldChannelIdBeyondMaxId" => Ok(EErrorCode::ErrChatWorldChannelIdBeyondMaxId),
                    "ErrChatIllegalChannelType" => Ok(EErrorCode::ErrChatIllegalChannelType),
                    "ErrChatIllegalMsgType" => Ok(EErrorCode::ErrChatIllegalMsgType),
                    "ErrChatNoInGoalChannel" => Ok(EErrorCode::ErrChatNoInGoalChannel),
                    "ErrChatNeedConfigIdNotZero" => Ok(EErrorCode::ErrChatNeedConfigIdNotZero),
                    "ErrChatNeedMsgTextNotEmpty" => Ok(EErrorCode::ErrChatNeedMsgTextNotEmpty),
                    "ErrChatSendCdNoEnd" => Ok(EErrorCode::ErrChatSendCdNoEnd),
                    "ErrChatRecordListIsEmpty" => Ok(EErrorCode::ErrChatRecordListIsEmpty),
                    "ErrChatTargetNotInPrivateList" => Ok(EErrorCode::ErrChatTargetNotInPrivateList),
                    "ErrChatMsgIdMoreThanMaxReadMsgId" => Ok(EErrorCode::ErrChatMsgIdMoreThanMaxReadMsgId),
                    "ErrChatBeyondBlockListLimit" => Ok(EErrorCode::ErrChatBeyondBlockListLimit),
                    "ErrChatWorldChannelIdBeyondMaxNum" => Ok(EErrorCode::ErrChatWorldChannelIdBeyondMaxNum),
                    "ErrChatBeyondMaxRecordId" => Ok(EErrorCode::ErrChatBeyondMaxRecordId),
                    "ErrChatNoCreatePrivateSession" => Ok(EErrorCode::ErrChatNoCreatePrivateSession),
                    "ErrChatPrivateSessionHasExit" => Ok(EErrorCode::ErrChatPrivateSessionHasExit),
                    "ErrChatBeBan" => Ok(EErrorCode::ErrChatBeBan),
                    "ErrChatFileIdTooLong" => Ok(EErrorCode::ErrChatFileIdTooLong),
                    "ErrChatFileIdEmpty" => Ok(EErrorCode::ErrChatFileIdEmpty),
                    "ErrChatMsgInfoEmpty" => Ok(EErrorCode::ErrChatMsgInfoEmpty),
                    "ErrChatNoShareChannel" => Ok(EErrorCode::ErrChatNoShareChannel),
                    "ErrChatIllegalShareType" => Ok(EErrorCode::ErrChatIllegalShareType),
                    "ErrChatIllegalHolderType" => Ok(EErrorCode::ErrChatIllegalHolderType),
                    "ErrChatNoSupportShareType" => Ok(EErrorCode::ErrChatNoSupportShareType),
                    "ErrChatShareTpeNoChatId" => Ok(EErrorCode::ErrChatShareTpeNoChatId),
                    "ErrChatShareNoFishRank" => Ok(EErrorCode::ErrChatShareNoFishRank),
                    "ErrChatLevelLimit" => Ok(EErrorCode::ErrChatLevelLimit),
                    "ErrChatNoFoundBlockListLimit" => Ok(EErrorCode::ErrChatNoFoundBlockListLimit),
                    "ErrTalentModTalentTagNotExist" => Ok(EErrorCode::ErrTalentModTalentTagNotExist),
                    "ErrTextCheckForbidden" => Ok(EErrorCode::ErrTextCheckForbidden),
                    "ErrTextCheckNoSceneType" => Ok(EErrorCode::ErrTextCheckNoSceneType),
                    "ErrTextCheckIllegal" => Ok(EErrorCode::ErrTextCheckIllegal),
                    "ErrTextCheckHttpError" => Ok(EErrorCode::ErrTextCheckHttpError),
                    "ErrTextCheckTooManyItems" => Ok(EErrorCode::ErrTextCheckTooManyItems),
                    "ErrConditionTimerOpen" => Ok(EErrorCode::ErrConditionTimerOpen),
                    "ErrConditionOpenServer" => Ok(EErrorCode::ErrConditionOpenServer),
                    "ErrSkillDisable" => Ok(EErrorCode::ErrSkillDisable),
                    "ErrSkillIsCD" => Ok(EErrorCode::ErrSkillIsCd),
                    "ErrSkillMaxPassiveCount" => Ok(EErrorCode::ErrSkillMaxPassiveCount),
                    "ErrSkillInit" => Ok(EErrorCode::ErrSkillInit),
                    "ErrSkillInfo" => Ok(EErrorCode::ErrSkillInfo),
                    "ErrUseSkillFightResInsufficient" => Ok(EErrorCode::ErrUseSkillFightResInsufficient),
                    "ErrUseSkillBuffNotEnough" => Ok(EErrorCode::ErrUseSkillBuffNotEnough),
                    "ErrUseSkillItemInsufficient" => Ok(EErrorCode::ErrUseSkillItemInsufficient),
                    "ErrUseSkillAttrInsufficient" => Ok(EErrorCode::ErrUseSkillAttrInsufficient),
                    "ErrUseSkillEnduranceInsufficient" => Ok(EErrorCode::ErrUseSkillEnduranceInsufficient),
                    "ErrUseSkillStateChange" => Ok(EErrorCode::ErrUseSkillStateChange),
                    "ErrUseSkillClientSkillUuid" => Ok(EErrorCode::ErrUseSkillClientSkillUuid),
                    "ErrFightLogicConditionBlockInvalid" => Ok(EErrorCode::ErrFightLogicConditionBlockInvalid),
                    "ErrFightLogicActionGroupInvalid" => Ok(EErrorCode::ErrFightLogicActionGroupInvalid),
                    "ErrFightLogicConditionNotMatch" => Ok(EErrorCode::ErrFightLogicConditionNotMatch),
                    "ErrFightLogicRunDataInvalid" => Ok(EErrorCode::ErrFightLogicRunDataInvalid),
                    "ErrSkillStageNotFind" => Ok(EErrorCode::ErrSkillStageNotFind),
                    "ErrConditionCfgSize" => Ok(EErrorCode::ErrConditionCfgSize),
                    "ErrConditionDissatisfy" => Ok(EErrorCode::ErrConditionDissatisfy),
                    "ErrConditionObjectIsNull" => Ok(EErrorCode::ErrConditionObjectIsNull),
                    "ErrConditionTypeNotFound" => Ok(EErrorCode::ErrConditionTypeNotFound),
                    "ErrConditionEntityDeath" => Ok(EErrorCode::ErrConditionEntityDeath),
                    "ErrConditionUnionLevel" => Ok(EErrorCode::ErrConditionUnionLevel),
                    "ErrConditionUnionMoney" => Ok(EErrorCode::ErrConditionUnionMoney),
                    "ErrConditionNotMeet" => Ok(EErrorCode::ErrConditionNotMeet),
                    "ErrConditionNotInShapeShift" => Ok(EErrorCode::ErrConditionNotInShapeShift),
                    "ErrSeasonAchievementNoExist" => Ok(EErrorCode::ErrSeasonAchievementNoExist),
                    "ErrSeasonAchievementNoFinish" => Ok(EErrorCode::ErrSeasonAchievementNoFinish),
                    "ErrSeasonAchievementHasReceived" => Ok(EErrorCode::ErrSeasonAchievementHasReceived),
                    "ErrSeasonAchievementPrevIdNoReceived" => Ok(EErrorCode::ErrSeasonAchievementPrevIdNoReceived),
                    "ErrSeasonAchievementPrevIdNoExist" => Ok(EErrorCode::ErrSeasonAchievementPrevIdNoExist),
                    "ErrSeasonAchievementTargetConfigError" => Ok(EErrorCode::ErrSeasonAchievementTargetConfigError),
                    "ErrSeasonRankHasMax" => Ok(EErrorCode::ErrSeasonRankHasMax),
                    "ErrSeasonRankHasReceived" => Ok(EErrorCode::ErrSeasonRankHasReceived),
                    "ErrSeasonRankNoAchieve" => Ok(EErrorCode::ErrSeasonRankNoAchieve),
                    "ErrSeasonRankCurSeasonIdZero" => Ok(EErrorCode::ErrSeasonRankCurSeasonIdZero),
                    "ErrSeasonRankNoMeetCondition" => Ok(EErrorCode::ErrSeasonRankNoMeetCondition),
                    "ErrSeasonRankSeasonNoSame" => Ok(EErrorCode::ErrSeasonRankSeasonNoSame),
                    "ErrBattlePassBuyLevel" => Ok(EErrorCode::ErrBattlePassBuyLevel),
                    "ErrBattlePassBuyMaterial" => Ok(EErrorCode::ErrBattlePassBuyMaterial),
                    "ErrBattlePassAwardGet" => Ok(EErrorCode::ErrBattlePassAwardGet),
                    "ErrBattlePassAwardNotUnlock" => Ok(EErrorCode::ErrBattlePassAwardNotUnlock),
                    "ErrBattlePassBuyWeekExpLimit" => Ok(EErrorCode::ErrBattlePassBuyWeekExpLimit),
                    "ErrBattlePassLevelError" => Ok(EErrorCode::ErrBattlePassLevelError),
                    "ErrNoRefreshTimes" => Ok(EErrorCode::ErrNoRefreshTimes),
                    "ErrTargetNotCompleted" => Ok(EErrorCode::ErrTargetNotCompleted),
                    "ErrOnlinePeriodTooMore" => Ok(EErrorCode::ErrOnlinePeriodTooMore),
                    "ErrPersonalTagTooMore" => Ok(EErrorCode::ErrPersonalTagTooMore),
                    "ErrPersonalTagNotFound" => Ok(EErrorCode::ErrPersonalTagNotFound),
                    "ErrPersonalAvatarUnearned" => Ok(EErrorCode::ErrPersonalAvatarUnearned),
                    "ErrPersonalAvatarFrameUnearned" => Ok(EErrorCode::ErrPersonalAvatarFrameUnearned),
                    "ErrPersonalCardStyleUnearned" => Ok(EErrorCode::ErrPersonalCardStyleUnearned),
                    "ErrPersonalPhotoTooMore" => Ok(EErrorCode::ErrPersonalPhotoTooMore),
                    "ErrPersonalMedalUnearned" => Ok(EErrorCode::ErrPersonalMedalUnearned),
                    "ErrPersonalTargetUnlock" => Ok(EErrorCode::ErrPersonalTargetUnlock),
                    "ErrPersonalTargetAlreadyGet" => Ok(EErrorCode::ErrPersonalTargetAlreadyGet),
                    "ErrPersonalMedalInvalidSlot" => Ok(EErrorCode::ErrPersonalMedalInvalidSlot),
                    "ErrPersonalMedalDuplicateValue" => Ok(EErrorCode::ErrPersonalMedalDuplicateValue),
                    "ErrOnlinePeriodDuplicate" => Ok(EErrorCode::ErrOnlinePeriodDuplicate),
                    "ErrPersonalTagDuplicate" => Ok(EErrorCode::ErrPersonalTagDuplicate),
                    "ErrPersonalPhotoInvalidSlot" => Ok(EErrorCode::ErrPersonalPhotoInvalidSlot),
                    "ErrPersonalPhotoDuplicateValue" => Ok(EErrorCode::ErrPersonalPhotoDuplicateValue),
                    "ErrSeasonMedalNoMeetActiveCondition" => Ok(EErrorCode::ErrSeasonMedalNoMeetActiveCondition),
                    "ErrSeasonMedalNoMeetUpgradeCondition" => Ok(EErrorCode::ErrSeasonMedalNoMeetUpgradeCondition),
                    "ErrSeasonMedalActiveMeetNoEnough" => Ok(EErrorCode::ErrSeasonMedalActiveMeetNoEnough),
                    "ErrSeasonMedalUpgradeMeetNoEnough" => Ok(EErrorCode::ErrSeasonMedalUpgradeMeetNoEnough),
                    "ErrSeasonMedalIllegalNodeId" => Ok(EErrorCode::ErrSeasonMedalIllegalNodeId),
                    "ErrSeasonMedalChooseNodeIdBeyondMax" => Ok(EErrorCode::ErrSeasonMedalChooseNodeIdBeyondMax),
                    "ErrSeasonMedalHoleNoExist" => Ok(EErrorCode::ErrSeasonMedalHoleNoExist),
                    "ErrSeasonMedalHoleLock" => Ok(EErrorCode::ErrSeasonMedalHoleLock),
                    "ErrSeasonMedalNodeNoExist" => Ok(EErrorCode::ErrSeasonMedalNodeNoExist),
                    "ErrSeasonMedalHoleNoGet" => Ok(EErrorCode::ErrSeasonMedalHoleNoGet),
                    "ErrSeasonMedalMaxHoleLevel" => Ok(EErrorCode::ErrSeasonMedalMaxHoleLevel),
                    "ErrSeasonMedalCoreHoleLock" => Ok(EErrorCode::ErrSeasonMedalCoreHoleLock),
                    "ErrSeasonMedalUpgradeMoneyNoEnough" => Ok(EErrorCode::ErrSeasonMedalUpgradeMoneyNoEnough),
                    "ErrSeasonNoCoreHole" => Ok(EErrorCode::ErrSeasonNoCoreHole),
                    "ErrSeasonNoNormalHole" => Ok(EErrorCode::ErrSeasonNoNormalHole),
                    "ErrSeasonMedalNoUpgradeNormalHoleItem" => Ok(EErrorCode::ErrSeasonMedalNoUpgradeNormalHoleItem),
                    "ErrSceneLineNotExists" => Ok(EErrorCode::ErrSceneLineNotExists),
                    "ErrSceneLineRefreshCd" => Ok(EErrorCode::ErrSceneLineRefreshCd),
                    "ErrSceneLineNotSameScene" => Ok(EErrorCode::ErrSceneLineNotSameScene),
                    "ErrSceneLineSameLine" => Ok(EErrorCode::ErrSceneLineSameLine),
                    "ErrSceneLineInteracting" => Ok(EErrorCode::ErrSceneLineInteracting),
                    "ErrSceneLineUserDead" => Ok(EErrorCode::ErrSceneLineUserDead),
                    "ErrSceneLineFull" => Ok(EErrorCode::ErrSceneLineFull),
                    "ErrSceneLineChangeCd" => Ok(EErrorCode::ErrSceneLineChangeCd),
                    "ErrSceneVersionRecycle" => Ok(EErrorCode::ErrSceneVersionRecycle),
                    "ErrSceneLineKick" => Ok(EErrorCode::ErrSceneLineKick),
                    "ErrInstallSlotFailed" => Ok(EErrorCode::ErrInstallSlotFailed),
                    "ErrUseSlotFailed" => Ok(EErrorCode::ErrUseSlotFailed),
                    "ErrUseSlotInCd" => Ok(EErrorCode::ErrUseSlotInCd),
                    "ErrInstatallSlotFailedInCombat" => Ok(EErrorCode::ErrInstatallSlotFailedInCombat),
                    "ErrSlotSkillUnLoad" => Ok(EErrorCode::ErrSlotSkillUnLoad),
                    "ErrUseCfgSkillFailed" => Ok(EErrorCode::ErrUseCfgSkillFailed),
                    "ErrResonanceNotExists" => Ok(EErrorCode::ErrResonanceNotExists),
                    "ErrResonanceUnLoad" => Ok(EErrorCode::ErrResonanceUnLoad),
                    "ErrUseDodgeFailed" => Ok(EErrorCode::ErrUseDodgeFailed),
                    "ErrUseFixedSkillFailed" => Ok(EErrorCode::ErrUseFixedSkillFailed),
                    "ErrUseBlockedSkill" => Ok(EErrorCode::ErrUseBlockedSkill),
                    "ErrInstallBlockedSkill" => Ok(EErrorCode::ErrInstallBlockedSkill),
                    "ErrExchangeNotFound" => Ok(EErrorCode::ErrExchangeNotFound),
                    "ErrExchangeNotEnough" => Ok(EErrorCode::ErrExchangeNotEnough),
                    "ErrExchangeItemLimit" => Ok(EErrorCode::ErrExchangeItemLimit),
                    "ErrExchangeStepRange" => Ok(EErrorCode::ErrExchangeStepRange),
                    "ErrExchangeItemFull" => Ok(EErrorCode::ErrExchangeItemFull),
                    "ErrExchangePackageFull" => Ok(EErrorCode::ErrExchangePackageFull),
                    "ErrExchangePriceItemNotFind" => Ok(EErrorCode::ErrExchangePriceItemNotFind),
                    "ErrExchangeBuyNumNotEnough" => Ok(EErrorCode::ErrExchangeBuyNumNotEnough),
                    "ErrExchangeBuyItemNotFound" => Ok(EErrorCode::ErrExchangeBuyItemNotFound),
                    "ErrExchangeTakeFailDelayTime" => Ok(EErrorCode::ErrExchangeTakeFailDelayTime),
                    "ErrExchangeTakeFailSellNum" => Ok(EErrorCode::ErrExchangeTakeFailSellNum),
                    "ErrExchangeTakeItemNotFound" => Ok(EErrorCode::ErrExchangeTakeItemNotFound),
                    "ErrExchangeWithdrawNoMoney" => Ok(EErrorCode::ErrExchangeWithdrawNoMoney),
                    "ErrExchangeDepositNotEnough" => Ok(EErrorCode::ErrExchangeDepositNotEnough),
                    "ErrExchangeItemNotBindOrCooldownNotExpire" => Ok(EErrorCode::ErrExchangeItemNotBindOrCooldownNotExpire),
                    "ErrExchangeInCd" => Ok(EErrorCode::ErrExchangeInCd),
                    "ErrExchangeBuyCurrencyNoEnough" => Ok(EErrorCode::ErrExchangeBuyCurrencyNoEnough),
                    "ErrExchangeItemDelayTimeOver" => Ok(EErrorCode::ErrExchangeItemDelayTimeOver),
                    "ErrExchangeItemIsNotWithdraw" => Ok(EErrorCode::ErrExchangeItemIsNotWithdraw),
                    "ErrExchangeBuyItemLimit" => Ok(EErrorCode::ErrExchangeBuyItemLimit),
                    "ErrExchangeItemIsNotNoticeShopItem" => Ok(EErrorCode::ErrExchangeItemIsNotNoticeShopItem),
                    "ErrExchangeItemIsPreBuyAlready" => Ok(EErrorCode::ErrExchangeItemIsPreBuyAlready),
                    "ErrExchangeItemNotPublic" => Ok(EErrorCode::ErrExchangeItemNotPublic),
                    "ErrExchangeSaleRankExist" => Ok(EErrorCode::ErrExchangeSaleRankExist),
                    "ErrExchangeSaleItemFull" => Ok(EErrorCode::ErrExchangeSaleItemFull),
                    "ErrExchangeSaleDiamondNotEnough" => Ok(EErrorCode::ErrExchangeSaleDiamondNotEnough),
                    "ErrExchangeSaleItemNotExists" => Ok(EErrorCode::ErrExchangeSaleItemNotExists),
                    "ErrExchangeBuySaleCurrencyNoEnough" => Ok(EErrorCode::ErrExchangeBuySaleCurrencyNoEnough),
                    "ErrExchangeDiamondNotEnough" => Ok(EErrorCode::ErrExchangeDiamondNotEnough),
                    "ErrExchangeSaleTakeOffCd" => Ok(EErrorCode::ErrExchangeSaleTakeOffCd),
                    "ErrExchangeSaleRateInvalid" => Ok(EErrorCode::ErrExchangeSaleRateInvalid),
                    "ErrExchangePreItemFull" => Ok(EErrorCode::ErrExchangePreItemFull),
                    "ErrExchangeSaleNumInvalid" => Ok(EErrorCode::ErrExchangeSaleNumInvalid),
                    "ErrExchangeCareItemAlready" => Ok(EErrorCode::ErrExchangeCareItemAlready),
                    "ErrExchangePriceRange" => Ok(EErrorCode::ErrExchangePriceRange),
                    "ErrExchangeRequestLimit" => Ok(EErrorCode::ErrExchangeRequestLimit),
                    "ErrExchangeItemBanned" => Ok(EErrorCode::ErrExchangeItemBanned),
                    "ErrExchangePriceNotLow" => Ok(EErrorCode::ErrExchangePriceNotLow),
                    "ErrExchangeItemNotFind" => Ok(EErrorCode::ErrExchangeItemNotFind),
                    "ErrExchangeItemExistMinPrice" => Ok(EErrorCode::ErrExchangeItemExistMinPrice),
                    "ErrExchangeNoticeItemMin" => Ok(EErrorCode::ErrExchangeNoticeItemMin),
                    "ErrExchangePreBuyUserFull" => Ok(EErrorCode::ErrExchangePreBuyUserFull),
                    "ErrModHoleNotUnlock" => Ok(EErrorCode::ErrModHoleNotUnlock),
                    "ErrModNotExist" => Ok(EErrorCode::ErrModNotExist),
                    "ErrModSimilarRepeated" => Ok(EErrorCode::ErrModSimilarRepeated),
                    "ErrModTypeLimitExceeded" => Ok(EErrorCode::ErrModTypeLimitExceeded),
                    "ErrModPartNotExist" => Ok(EErrorCode::ErrModPartNotExist),
                    "ErrModPartEnhanceLimit" => Ok(EErrorCode::ErrModPartEnhanceLimit),
                    "ErrModInUse" => Ok(EErrorCode::ErrModInUse),
                    "ErrModAlreadyInstalled" => Ok(EErrorCode::ErrModAlreadyInstalled),
                    "ErrModInitConfigNotExist" => Ok(EErrorCode::ErrModInitConfigNotExist),
                    "ErrModPartOverflow" => Ok(EErrorCode::ErrModPartOverflow),
                    "ErrModCanNotLink" => Ok(EErrorCode::ErrModCanNotLink),
                    "ErrFishingNotUseBait" => Ok(EErrorCode::ErrFishingNotUseBait),
                    "ErrFishingRandomFailed" => Ok(EErrorCode::ErrFishingRandomFailed),
                    "ErrFishingAlreadyGetFishItem" => Ok(EErrorCode::ErrFishingAlreadyGetFishItem),
                    "ErrFishingGetFishIdWrong" => Ok(EErrorCode::ErrFishingGetFishIdWrong),
                    "ErrFishingNotGet" => Ok(EErrorCode::ErrFishingNotGet),
                    "ErrFishingNotResearchYet" => Ok(EErrorCode::ErrFishingNotResearchYet),
                    "ErrFishingNotUseRod" => Ok(EErrorCode::ErrFishingNotUseRod),
                    "ErrFishingNoSeat" => Ok(EErrorCode::ErrFishingNoSeat),
                    "ErrFishingCantResearch" => Ok(EErrorCode::ErrFishingCantResearch),
                    "ErrFishDrawnLevelAward" => Ok(EErrorCode::ErrFishDrawnLevelAward),
                    "ErrFishCannotDrawLevelAward" => Ok(EErrorCode::ErrFishCannotDrawLevelAward),
                    "ErrFishDrawnNoLevelAward" => Ok(EErrorCode::ErrFishDrawnNoLevelAward),
                    "ErrFreightNoRefreshGoods" => Ok(EErrorCode::ErrFreightNoRefreshGoods),
                    "ErrFreightBeyondMaxValue" => Ok(EErrorCode::ErrFreightBeyondMaxValue),
                    "ErrFreightDownMinValue" => Ok(EErrorCode::ErrFreightDownMinValue),
                    "ErrFreightHasSetOff" => Ok(EErrorCode::ErrFreightHasSetOff),
                    "ErrFreightNoSetOff" => Ok(EErrorCode::ErrFreightNoSetOff),
                    "ErrFreightHasReward" => Ok(EErrorCode::ErrFreightHasReward),
                    "ErrFreightIllegalGoodsId" => Ok(EErrorCode::ErrFreightIllegalGoodsId),
                    "ErrFreightItemNoEnough" => Ok(EErrorCode::ErrFreightItemNoEnough),
                    "ErrFreightNoUpSetOffTime" => Ok(EErrorCode::ErrFreightNoUpSetOffTime),
                    "ErrFreightNoUpRewardTime" => Ok(EErrorCode::ErrFreightNoUpRewardTime),
                    "ErrFreightAutoSetOff" => Ok(EErrorCode::ErrFreightAutoSetOff),
                    "ErrTrialRoadAwardNotFinished" => Ok(EErrorCode::ErrTrialRoadAwardNotFinished),
                    "ErrTrialRoadAwardRoomGet" => Ok(EErrorCode::ErrTrialRoadAwardRoomGet),
                    "ErrNotCanRide" => Ok(EErrorCode::ErrNotCanRide),
                    "ErrCombatStateNotRide" => Ok(EErrorCode::ErrCombatStateNotRide),
                    "ErrAlreadyRide" => Ok(EErrorCode::ErrAlreadyRide),
                    "ErrRideNotEnough" => Ok(EErrorCode::ErrRideNotEnough),
                    "ErrCreateVehicleActorFailed" => Ok(EErrorCode::ErrCreateVehicleActorFailed),
                    "ErrNotVehicleOwner" => Ok(EErrorCode::ErrNotVehicleOwner),
                    "ErrVehicleHasController" => Ok(EErrorCode::ErrVehicleHasController),
                    "ErrVehicleNoSeat" => Ok(EErrorCode::ErrVehicleNoSeat),
                    "ErrVehicleHasSeat" => Ok(EErrorCode::ErrVehicleHasSeat),
                    "ErrNotRideVehicle" => Ok(EErrorCode::ErrNotRideVehicle),
                    "ErrVehicleNotExits" => Ok(EErrorCode::ErrVehicleNotExits),
                    "ErrInvalidRidePropertyType" => Ok(EErrorCode::ErrInvalidRidePropertyType),
                    "ErrRideApplyTargetUserNotExist" => Ok(EErrorCode::ErrRideApplyTargetUserNotExist),
                    "ErrRideConfigNotFind" => Ok(EErrorCode::ErrRideConfigNotFind),
                    "ErrRideNotUnlock" => Ok(EErrorCode::ErrRideNotUnlock),
                    "ErrRideNotFind" => Ok(EErrorCode::ErrRideNotFind),
                    "ErrInvalidRideType" => Ok(EErrorCode::ErrInvalidRideType),
                    "ErrRideApplyAlreadyExist" => Ok(EErrorCode::ErrRideApplyAlreadyExist),
                    "ErrRideApplyNotRideVehicle" => Ok(EErrorCode::ErrRideApplyNotRideVehicle),
                    "ErrRideApplyVehicleNotSeat" => Ok(EErrorCode::ErrRideApplyVehicleNotSeat),
                    "ErrRideAlReadyRide" => Ok(EErrorCode::ErrRideAlReadyRide),
                    "ErrRideApplyTargetTooFar" => Ok(EErrorCode::ErrRideApplyTargetTooFar),
                    "ErrRideNotTake" => Ok(EErrorCode::ErrRideNotTake),
                    "ErrRideInteracting" => Ok(EErrorCode::ErrRideInteracting),
                    "ErrShapeshiftNotRide" => Ok(EErrorCode::ErrShapeshiftNotRide),
                    "ErrFishingNotRide" => Ok(EErrorCode::ErrFishingNotRide),
                    "ErrRideStateReject" => Ok(EErrorCode::ErrRideStateReject),
                    "ErrRideTypeNotSupport" => Ok(EErrorCode::ErrRideTypeNotSupport),
                    "ErrRideNotControl" => Ok(EErrorCode::ErrRideNotControl),
                    "ErrRideNotFunction" => Ok(EErrorCode::ErrRideNotFunction),
                    "ErrRideSkinNotSupport" => Ok(EErrorCode::ErrRideSkinNotSupport),
                    "ErrRideSkinNotUnlock" => Ok(EErrorCode::ErrRideSkinNotUnlock),
                    "ErrRideSkinDataAddFailed" => Ok(EErrorCode::ErrRideSkinDataAddFailed),
                    "ErrRideSkinNotSkin" => Ok(EErrorCode::ErrRideSkinNotSkin),
                    "ErrRideSkinAlreadyActivate" => Ok(EErrorCode::ErrRideSkinAlreadyActivate),
                    "ErrWarehouseHas" => Ok(EErrorCode::ErrWarehouseHas),
                    "ErrWarehouseNoHas" => Ok(EErrorCode::ErrWarehouseNoHas),
                    "ErrWarehouseNoMem" => Ok(EErrorCode::ErrWarehouseNoMem),
                    "ErrWarehouseNoPresident" => Ok(EErrorCode::ErrWarehouseNoPresident),
                    "ErrWarehouseNoHasItem" => Ok(EErrorCode::ErrWarehouseNoHasItem),
                    "ErrWarehouseItemNoDeposit" => Ok(EErrorCode::ErrWarehouseItemNoDeposit),
                    "ErrWarehouseGridPosNoExist" => Ok(EErrorCode::ErrWarehouseGridPosNoExist),
                    "ErrWarehouseGridPosItemNoEnough" => Ok(EErrorCode::ErrWarehouseGridPosItemNoEnough),
                    "ErrWarehouseNoInviteSelf" => Ok(EErrorCode::ErrWarehouseNoInviteSelf),
                    "ErrWarehouseInviteesHas" => Ok(EErrorCode::ErrWarehouseInviteesHas),
                    "ErrWarehouseMemBeyondMax" => Ok(EErrorCode::ErrWarehouseMemBeyondMax),
                    "ErrWarehouseGridBeyondMax" => Ok(EErrorCode::ErrWarehouseGridBeyondMax),
                    "ErrWarehouseNoSelf" => Ok(EErrorCode::ErrWarehouseNoSelf),
                    "ErrWarehouseIsMem" => Ok(EErrorCode::ErrWarehouseIsMem),
                    "ErrWarehouseNoExist" => Ok(EErrorCode::ErrWarehouseNoExist),
                    "ErrWarehouseDepositBeyondMax" => Ok(EErrorCode::ErrWarehouseDepositBeyondMax),
                    "ErrWarehouseTakeOutBeyondMax" => Ok(EErrorCode::ErrWarehouseTakeOutBeyondMax),
                    "ErrWarehouseItemIdNotSame" => Ok(EErrorCode::ErrWarehouseItemIdNotSame),
                    "ErrWarehouseParams" => Ok(EErrorCode::ErrWarehouseParams),
                    "ErrWarehouseNoKickSelf" => Ok(EErrorCode::ErrWarehouseNoKickSelf),
                    "ErrWarehousePresidentNoExit" => Ok(EErrorCode::ErrWarehousePresidentNoExit),
                    "ErrGashaDrawCount" => Ok(EErrorCode::ErrGashaDrawCount),
                    "ErrGashaDrawLimit" => Ok(EErrorCode::ErrGashaDrawLimit),
                    "ErrGashaInvalidWishId" => Ok(EErrorCode::ErrGashaInvalidWishId),
                    "EErGashaWishRepeated" => Ok(EErrorCode::EErGashaWishRepeated),
                    "EErGashaWishCountNoEnough" => Ok(EErrorCode::EErGashaWishCountNoEnough),
                    "ErrWarehouseAuthority" => Ok(EErrorCode::ErrWarehouseAuthority),
                    "ErrEquipCantDecompose" => Ok(EErrorCode::ErrEquipCantDecompose),
                    "ErrEquipNotRecastRecord" => Ok(EErrorCode::ErrEquipNotRecastRecord),
                    "ErrEquipOnCantUsedRecastConsume" => Ok(EErrorCode::ErrEquipOnCantUsedRecastConsume),
                    "ErrEquipWeaponNotEqualProfession" => Ok(EErrorCode::ErrEquipWeaponNotEqualProfession),
                    "ErrEquipSlotRefineBlessNotFit" => Ok(EErrorCode::ErrEquipSlotRefineBlessNotFit),
                    "ErrEquipNotRecast" => Ok(EErrorCode::ErrEquipNotRecast),
                    "ErrEquipEnchantItemMismatch" => Ok(EErrorCode::ErrEquipEnchantItemMismatch),
                    "ErrEquipEnchantAlreadyEnchanted" => Ok(EErrorCode::ErrEquipEnchantAlreadyEnchanted),
                    "ErrEquipAnyItemMismatch" => Ok(EErrorCode::ErrEquipAnyItemMismatch),
                    "ErrEquipSlotRefineBlessNumTooMuch" => Ok(EErrorCode::ErrEquipSlotRefineBlessNumTooMuch),
                    "ErrEquipNameGroupNoMatch" => Ok(EErrorCode::ErrEquipNameGroupNoMatch),
                    "ErrEquipPerfectionNoMatch" => Ok(EErrorCode::ErrEquipPerfectionNoMatch),
                    "ErrEquipNotBreak" => Ok(EErrorCode::ErrEquipNotBreak),
                    "ErrEquipPutOnIng" => Ok(EErrorCode::ErrEquipPutOnIng),
                    "ErrUserIsMatching" => Ok(EErrorCode::ErrUserIsMatching),
                    "ErrUserNotInMatching" => Ok(EErrorCode::ErrUserNotInMatching),
                    "ErrUseNotWaitReady" => Ok(EErrorCode::ErrUseNotWaitReady),
                    "ErrDungeonCantMatch" => Ok(EErrorCode::ErrDungeonCantMatch),
                    "ErrMatchQueueFull" => Ok(EErrorCode::ErrMatchQueueFull),
                    "ErrCommonAwardCantReceive" => Ok(EErrorCode::ErrCommonAwardCantReceive),
                    "ErrCommonAwardHasReceived" => Ok(EErrorCode::ErrCommonAwardHasReceived),
                    "ErrCraftEnergyNotEnough" => Ok(EErrorCode::ErrCraftEnergyNotEnough),
                    "ErrCraftEnergyFull" => Ok(EErrorCode::ErrCraftEnergyFull),
                    "ErrRecommendPlayNotOpen" => Ok(EErrorCode::ErrRecommendPlayNotOpen),
                    "ErrWeeklyTowerNoStart" => Ok(EErrorCode::ErrWeeklyTowerNoStart),
                    "ErrWeeklyTowerHasEnd" => Ok(EErrorCode::ErrWeeklyTowerHasEnd),
                    "ErrWeeklyNoMeetProcessAward" => Ok(EErrorCode::ErrWeeklyNoMeetProcessAward),
                    "ErrWeeklyHasRewardProcessAward" => Ok(EErrorCode::ErrWeeklyHasRewardProcessAward),
                    "ErrWeeklyNoLayerStageAward" => Ok(EErrorCode::ErrWeeklyNoLayerStageAward),
                    "ErrWeekOnlyCurSeasonAward" => Ok(EErrorCode::ErrWeekOnlyCurSeasonAward),
                    "ErrWeeklyTowerCannotEnterLayer" => Ok(EErrorCode::ErrWeeklyTowerCannotEnterLayer),
                    "ErrWeeklyTowerBoxHasOpen" => Ok(EErrorCode::ErrWeeklyTowerBoxHasOpen),
                    "ErrWeeklyTowerNoBox" => Ok(EErrorCode::ErrWeeklyTowerNoBox),
                    "ErrWeeklyTowerNoStageAward" => Ok(EErrorCode::ErrWeeklyTowerNoStageAward),
                    "ErrWeeklyTowerNoTowerDungeon" => Ok(EErrorCode::ErrWeeklyTowerNoTowerDungeon),
                    "ErrFunctionNoAward" => Ok(EErrorCode::ErrFunctionNoAward),
                    "ErrFunctionHasDrawn" => Ok(EErrorCode::ErrFunctionHasDrawn),
                    "ErrTLogIllegalExportArea" => Ok(EErrorCode::ErrTLogIllegalExportArea),
                    "ErrPayOrderFail" => Ok(EErrorCode::ErrPayOrderFail),
                    "ErrPayCostNotEnough" => Ok(EErrorCode::ErrPayCostNotEnough),
                    "ErrPayCantBuy" => Ok(EErrorCode::ErrPayCantBuy),
                    "ErrPayCantExplore" => Ok(EErrorCode::ErrPayCantExplore),
                    "ErrActivityNotFind" => Ok(EErrorCode::ErrActivityNotFind),
                    "ErrActivityOffline" => Ok(EErrorCode::ErrActivityOffline),
                    "ErrActivityNotOpen" => Ok(EErrorCode::ErrActivityNotOpen),
                    "ErrActivityRewardNotFound" => Ok(EErrorCode::ErrActivityRewardNotFound),
                    "ErrActivityConditionNotFinish" => Ok(EErrorCode::ErrActivityConditionNotFinish),
                    "ErrActivityAlreadyObtain" => Ok(EErrorCode::ErrActivityAlreadyObtain),
                    "ErrActivityNotUnlock" => Ok(EErrorCode::ErrActivityNotUnlock),
                    "ErrEmojiConfigError" => Ok(EErrorCode::ErrEmojiConfigError),
                    "ErrEmojiAlreadyUnlock" => Ok(EErrorCode::ErrEmojiAlreadyUnlock),
                    "ErrEmojiUnlockItemError" => Ok(EErrorCode::ErrEmojiUnlockItemError),
                    "ErrEmojiUnlockItemErrorItemNotEnough" => Ok(EErrorCode::ErrEmojiUnlockItemErrorItemNotEnough),
                    "ErrEmojiUnlock" => Ok(EErrorCode::ErrEmojiUnlock),
                    "ErrGlobalConditionNotFound" => Ok(EErrorCode::ErrGlobalConditionNotFound),
                    "ErrGlobalConditionNotLuckyValue" => Ok(EErrorCode::ErrGlobalConditionNotLuckyValue),
                    "ErrPathFindingCant" => Ok(EErrorCode::ErrPathFindingCant),
                    "ErrPathFindingDataError" => Ok(EErrorCode::ErrPathFindingDataError),
                    "ErrPathFindingEndPosError" => Ok(EErrorCode::ErrPathFindingEndPosError),
                    "ErrPathFindingStartPosError" => Ok(EErrorCode::ErrPathFindingStartPosError),
                    "ErrPathFindingNoPath" => Ok(EErrorCode::ErrPathFindingNoPath),
                    "ErrSignNotOpen" => Ok(EErrorCode::ErrSignNotOpen),
                    "ErrSignNotSigned" => Ok(EErrorCode::ErrSignNotSigned),
                    "ErrSignAlreadySigned" => Ok(EErrorCode::ErrSignAlreadySigned),
                    "ErrSignTimeError" => Ok(EErrorCode::ErrSignTimeError),
                    "ErrTokenBucketLimit" => Ok(EErrorCode::ErrTokenBucketLimit),
                    "ErrUnknown" => Ok(EErrorCode::ErrUnknown),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EFarmlandState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Empty => "EFarmlandStateEmpty",
            Self::Grow => "EFarmlandStateGrow",
            Self::Pollen => "EFarmlandStatePollen",
            Self::Harvest => "EFarmlandStateHarvest",
            Self::Over => "EFarmlandStateOver",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EFarmlandState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EFarmlandStateEmpty",
            "EFarmlandStateGrow",
            "EFarmlandStatePollen",
            "EFarmlandStateHarvest",
            "EFarmlandStateOver",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EFarmlandState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EFarmlandStateEmpty" => Ok(EFarmlandState::Empty),
                    "EFarmlandStateGrow" => Ok(EFarmlandState::Grow),
                    "EFarmlandStatePollen" => Ok(EFarmlandState::Pollen),
                    "EFarmlandStateHarvest" => Ok(EFarmlandState::Harvest),
                    "EFarmlandStateOver" => Ok(EFarmlandState::Over),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EGender {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::GenderNull => "GenderNull",
            Self::GenderMale => "GenderMale",
            Self::GenderFemale => "GenderFemale",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EGender {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GenderNull",
            "GenderMale",
            "GenderFemale",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EGender;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "GenderNull" => Ok(EGender::GenderNull),
                    "GenderMale" => Ok(EGender::GenderMale),
                    "GenderFemale" => Ok(EGender::GenderFemale),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EGmParsingType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::GmParsingJson => "GmParsingJson",
            Self::GmParsingString => "GmParsingString",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EGmParsingType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GmParsingJson",
            "GmParsingString",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EGmParsingType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "GmParsingJson" => Ok(EGmParsingType::GmParsingJson),
                    "GmParsingString" => Ok(EGmParsingType::GmParsingString),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EHeroKeyRollType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::HeroKeyRollTypeNull => "HeroKeyRollTypeNull",
            Self::HeroKeyRollTypeGiveup => "HeroKeyRollTypeGiveup",
            Self::HeroKeyRollTypeRoll => "HeroKeyRollTypeRoll",
            Self::HeroKeyRollTypeGet => "HeroKeyRollTypeGet",
            Self::HeroKeyRollTypeRollGet => "HeroKeyRollTypeRollGet",
            Self::HeroKeyRollTypeCountFull => "HeroKeyRollTypeCountFull",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EHeroKeyRollType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HeroKeyRollTypeNull",
            "HeroKeyRollTypeGiveup",
            "HeroKeyRollTypeRoll",
            "HeroKeyRollTypeGet",
            "HeroKeyRollTypeRollGet",
            "HeroKeyRollTypeCountFull",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EHeroKeyRollType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "HeroKeyRollTypeNull" => Ok(EHeroKeyRollType::HeroKeyRollTypeNull),
                    "HeroKeyRollTypeGiveup" => Ok(EHeroKeyRollType::HeroKeyRollTypeGiveup),
                    "HeroKeyRollTypeRoll" => Ok(EHeroKeyRollType::HeroKeyRollTypeRoll),
                    "HeroKeyRollTypeGet" => Ok(EHeroKeyRollType::HeroKeyRollTypeGet),
                    "HeroKeyRollTypeRollGet" => Ok(EHeroKeyRollType::HeroKeyRollTypeRollGet),
                    "HeroKeyRollTypeCountFull" => Ok(EHeroKeyRollType::HeroKeyRollTypeCountFull),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EHomelandLamplightState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::HomelandLamplightStateDefault => "HomelandLamplightStateDefault",
            Self::HomelandLamplightStateOn => "HomelandLamplightStateOn",
            Self::HomelandLamplightStateOff => "HomelandLamplightStateOff",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EHomelandLamplightState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HomelandLamplightStateDefault",
            "HomelandLamplightStateOn",
            "HomelandLamplightStateOff",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EHomelandLamplightState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "HomelandLamplightStateDefault" => Ok(EHomelandLamplightState::HomelandLamplightStateDefault),
                    "HomelandLamplightStateOn" => Ok(EHomelandLamplightState::HomelandLamplightStateOn),
                    "HomelandLamplightStateOff" => Ok(EHomelandLamplightState::HomelandLamplightStateOff),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EInteractionAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::None => "EInteractionActionNone",
            Self::ToServer => "EInteractionActionToServer",
            Self::NpcTalk => "EInteractionActionNpcTalk",
            Self::DungeonEntry => "EInteractionActionDungeonEntry",
            Self::FunctionEntry => "EInteractionActionFunctionEntry",
            Self::ClientSceneEvent => "EInteractionActionClientSceneEvent",
            Self::OptionSelect => "EInteractionActionOptionSelect",
            Self::HeroNormalDungeon => "EInteractionActionHeroNormalDungeon",
            Self::HeroChallengeDungeon => "EInteractionActionHeroChallengeDungeon",
            Self::Revive => "EInteractionActionRevive",
            Self::VmFuction => "EInteractionActionVMFuction",
            Self::Tips => "EInteractionActionTips",
            Self::OpenUi => "EInteractionActionOpenUI",
            Self::WindZone => "EInteractionActionWindZone",
            Self::WindRing => "EInteractionActionWindRing",
            Self::WindTornado => "EInteractionActionWindTornado",
            Self::DanceTogether => "EInteractionActionDanceTogether",
            Self::StartFlow => "EInteractionActionStartFlow",
            Self::ShowCutScene => "EInteractionActionShowCutScene",
            Self::UnionHuntEntry => "EInteractionActionUnionHuntEntry",
            Self::UnionBuild => "EInteractionActionUnionBuild",
            Self::UnionBuildFunc => "EInteractionActionUnionBuildFunc",
            Self::ExploreMonsterDeplete => "EInteractionActionExploreMonsterDeplete",
            Self::UseSkill => "EInteractionActionUseSkill",
            Self::Fishing => "EInteractionActionFishing",
            Self::SendClientAiEvent => "EInteractionActionSendClientAiEvent",
            Self::DoNoThing => "EInteractionActionDoNoThing",
            Self::CookFunc => "EInteractionActionCookFunc",
            Self::MoveToDistance => "EInteractionActionMoveToDistance",
            Self::MoveToPosition => "EInteractionActionMoveToPosition",
            Self::MoveToInteractionSeat => "EInteractionActionMoveToInteractionSeat",
            Self::RotateToTarget => "EInteractionActionRotateToTarget",
            Self::RotateToTargetAndWait => "EInteractionActionRotateToTargetAndWait",
            Self::AddClientBuff => "EInteractionActionAddClientBuff",
            Self::AddClientBuffAndWait => "EInteractionActionAddClientBuffAndWait",
            Self::AddClientBuffToTarget => "EInteractionActionAddClientBuffToTarget",
            Self::AddClientBuffToTargetAndWait => "EInteractionActionAddClientBuffToTargetAndWait",
            Self::ProgressBar => "EInteractionActionProgressBar",
            Self::CameraInvoke => "EInteractionActionCameraInvoke",
            Self::WaitUiConfirm => "EInteractionActionWaitUiConfirm",
            Self::IgnoreInput => "EInteractionActionIgnoreInput",
            Self::HideHud => "EInteractionActionHideHud",
            Self::HideUi => "EInteractionActionHideUI",
            Self::MoveToStaticObj => "EInteractionActionMoveToStaticObj",
            Self::UnionWarDance => "EInteractionActionUnionWarDance",
            Self::WaitInputMove => "EInteractionActionWaitInputMove",
            Self::RemoveClientBuff => "EInteractionActionRemoveClientBuff",
            Self::RemoveTargetClientBuff => "EInteractionActionRemoveTargetClientBuff",
            Self::EnterAutoFlow => "EInteractionActionEnterAutoFlow",
            Self::NpcTalkFlow => "EInteractionActionNpcTalkFlow",
            Self::StartFlowAndWait => "EInteractionActionStartFlowAndWait",
            Self::ShowCutSceneAndWait => "EInteractionActionShowCutSceneAndWait",
            Self::SittingControl => "EInteractionActionSittingControl",
            Self::MagneticAttach => "EInteractionActionMagneticAttach",
            Self::SwitchCameraTemplate => "EInteractionActionSwitchCameraTemplate",
            Self::HomeFarm => "EInteractionActionHomeFarm",
            Self::Lua => "EInteractionActionLua",
            Self::Base => "EInteractionActionBase",
            Self::Pivot => "EInteractionActionPivot",
            Self::PivotBreak => "EInteractionActionPivotBreak",
            Self::TransferPoint => "EInteractionActionTransferPoint",
            Self::LogicResonance => "EInteractionActionLogicResonance",
            Self::LogicStatic => "EInteractionActionLogicStatic",
            Self::LogicDance => "EInteractionActionLogicDance",
            Self::AddBuff => "EInteractionActionAddBuff",
            Self::Teleport => "EInteractionActionTeleport",
            Self::EnterDungeon => "EInteractionActionEnterDungeon",
            Self::EnterVisualLayer => "EInteractionActionEnterVisualLayer",
            Self::ExitVisualLayer => "EInteractionActionExitVisualLayer",
            Self::TriggerSceneEvent => "EInteractionActionTriggerSceneEvent",
            Self::TriggerSceneCustomEvent => "EInteractionActionTriggerSceneCustomEvent",
            Self::UserDoAction => "EInteractionActionUserDoAction",
            Self::Pickup => "EInteractionActionPickup",
            Self::OpenEliteTreasureBox => "EInteractionActionOpenEliteTreasureBox",
            Self::OpenBossTreasureBox => "EInteractionActionOpenBossTreasureBox",
            Self::Quest => "EInteractionActionQuest",
            Self::QuestEvent => "EInteractionActionQuestEvent",
            Self::KillSelf => "EInteractionActionKillSelf",
            Self::SendAiEvent => "EInteractionActionSendAiEvent",
            Self::DanceAwardNpc => "EInteractionActionDanceAwardNPC",
            Self::RequestInteractionSeat => "EInteractionActionRequestInteractionSeat",
            Self::RemoveBuff => "EInteractionActionRemoveBuff",
            Self::AddBuffToTarget => "EInteractionActionAddBuffToTarget",
            Self::RemoveBuffToTarget => "EInteractionActionRemoveBuffToTarget",
            Self::PaintToySwitchPage => "EInteractionActionPaintToySwitchPage",
            Self::OpenTowerTreasureBox => "EInteractionActionOpenTowerTreasureBox",
            Self::RoughCollection => "EInteractionActionRoughCollection",
            Self::FineCollection => "EInteractionActionFineCollection",
            Self::BubbleActStart => "EInteractionActionBubbleActStart",
            Self::BubbleActEnd => "EInteractionActionBubbleActEnd",
            Self::RaidOpenBox => "EInteractionActionRaidOpenBox",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EInteractionAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EInteractionActionNone",
            "EInteractionActionToServer",
            "EInteractionActionNpcTalk",
            "EInteractionActionDungeonEntry",
            "EInteractionActionFunctionEntry",
            "EInteractionActionClientSceneEvent",
            "EInteractionActionOptionSelect",
            "EInteractionActionHeroNormalDungeon",
            "EInteractionActionHeroChallengeDungeon",
            "EInteractionActionRevive",
            "EInteractionActionVMFuction",
            "EInteractionActionTips",
            "EInteractionActionOpenUI",
            "EInteractionActionWindZone",
            "EInteractionActionWindRing",
            "EInteractionActionWindTornado",
            "EInteractionActionDanceTogether",
            "EInteractionActionStartFlow",
            "EInteractionActionShowCutScene",
            "EInteractionActionUnionHuntEntry",
            "EInteractionActionUnionBuild",
            "EInteractionActionUnionBuildFunc",
            "EInteractionActionExploreMonsterDeplete",
            "EInteractionActionUseSkill",
            "EInteractionActionFishing",
            "EInteractionActionSendClientAiEvent",
            "EInteractionActionDoNoThing",
            "EInteractionActionCookFunc",
            "EInteractionActionMoveToDistance",
            "EInteractionActionMoveToPosition",
            "EInteractionActionMoveToInteractionSeat",
            "EInteractionActionRotateToTarget",
            "EInteractionActionRotateToTargetAndWait",
            "EInteractionActionAddClientBuff",
            "EInteractionActionAddClientBuffAndWait",
            "EInteractionActionAddClientBuffToTarget",
            "EInteractionActionAddClientBuffToTargetAndWait",
            "EInteractionActionProgressBar",
            "EInteractionActionCameraInvoke",
            "EInteractionActionWaitUiConfirm",
            "EInteractionActionIgnoreInput",
            "EInteractionActionHideHud",
            "EInteractionActionHideUI",
            "EInteractionActionMoveToStaticObj",
            "EInteractionActionUnionWarDance",
            "EInteractionActionWaitInputMove",
            "EInteractionActionRemoveClientBuff",
            "EInteractionActionRemoveTargetClientBuff",
            "EInteractionActionEnterAutoFlow",
            "EInteractionActionNpcTalkFlow",
            "EInteractionActionStartFlowAndWait",
            "EInteractionActionShowCutSceneAndWait",
            "EInteractionActionSittingControl",
            "EInteractionActionMagneticAttach",
            "EInteractionActionSwitchCameraTemplate",
            "EInteractionActionHomeFarm",
            "EInteractionActionLua",
            "EInteractionActionBase",
            "EInteractionActionPivot",
            "EInteractionActionPivotBreak",
            "EInteractionActionTransferPoint",
            "EInteractionActionLogicResonance",
            "EInteractionActionLogicStatic",
            "EInteractionActionLogicDance",
            "EInteractionActionAddBuff",
            "EInteractionActionTeleport",
            "EInteractionActionEnterDungeon",
            "EInteractionActionEnterVisualLayer",
            "EInteractionActionExitVisualLayer",
            "EInteractionActionTriggerSceneEvent",
            "EInteractionActionTriggerSceneCustomEvent",
            "EInteractionActionUserDoAction",
            "EInteractionActionPickup",
            "EInteractionActionOpenEliteTreasureBox",
            "EInteractionActionOpenBossTreasureBox",
            "EInteractionActionQuest",
            "EInteractionActionQuestEvent",
            "EInteractionActionKillSelf",
            "EInteractionActionSendAiEvent",
            "EInteractionActionDanceAwardNPC",
            "EInteractionActionRequestInteractionSeat",
            "EInteractionActionRemoveBuff",
            "EInteractionActionAddBuffToTarget",
            "EInteractionActionRemoveBuffToTarget",
            "EInteractionActionPaintToySwitchPage",
            "EInteractionActionOpenTowerTreasureBox",
            "EInteractionActionRoughCollection",
            "EInteractionActionFineCollection",
            "EInteractionActionBubbleActStart",
            "EInteractionActionBubbleActEnd",
            "EInteractionActionRaidOpenBox",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EInteractionAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EInteractionActionNone" => Ok(EInteractionAction::None),
                    "EInteractionActionToServer" => Ok(EInteractionAction::ToServer),
                    "EInteractionActionNpcTalk" => Ok(EInteractionAction::NpcTalk),
                    "EInteractionActionDungeonEntry" => Ok(EInteractionAction::DungeonEntry),
                    "EInteractionActionFunctionEntry" => Ok(EInteractionAction::FunctionEntry),
                    "EInteractionActionClientSceneEvent" => Ok(EInteractionAction::ClientSceneEvent),
                    "EInteractionActionOptionSelect" => Ok(EInteractionAction::OptionSelect),
                    "EInteractionActionHeroNormalDungeon" => Ok(EInteractionAction::HeroNormalDungeon),
                    "EInteractionActionHeroChallengeDungeon" => Ok(EInteractionAction::HeroChallengeDungeon),
                    "EInteractionActionRevive" => Ok(EInteractionAction::Revive),
                    "EInteractionActionVMFuction" => Ok(EInteractionAction::VmFuction),
                    "EInteractionActionTips" => Ok(EInteractionAction::Tips),
                    "EInteractionActionOpenUI" => Ok(EInteractionAction::OpenUi),
                    "EInteractionActionWindZone" => Ok(EInteractionAction::WindZone),
                    "EInteractionActionWindRing" => Ok(EInteractionAction::WindRing),
                    "EInteractionActionWindTornado" => Ok(EInteractionAction::WindTornado),
                    "EInteractionActionDanceTogether" => Ok(EInteractionAction::DanceTogether),
                    "EInteractionActionStartFlow" => Ok(EInteractionAction::StartFlow),
                    "EInteractionActionShowCutScene" => Ok(EInteractionAction::ShowCutScene),
                    "EInteractionActionUnionHuntEntry" => Ok(EInteractionAction::UnionHuntEntry),
                    "EInteractionActionUnionBuild" => Ok(EInteractionAction::UnionBuild),
                    "EInteractionActionUnionBuildFunc" => Ok(EInteractionAction::UnionBuildFunc),
                    "EInteractionActionExploreMonsterDeplete" => Ok(EInteractionAction::ExploreMonsterDeplete),
                    "EInteractionActionUseSkill" => Ok(EInteractionAction::UseSkill),
                    "EInteractionActionFishing" => Ok(EInteractionAction::Fishing),
                    "EInteractionActionSendClientAiEvent" => Ok(EInteractionAction::SendClientAiEvent),
                    "EInteractionActionDoNoThing" => Ok(EInteractionAction::DoNoThing),
                    "EInteractionActionCookFunc" => Ok(EInteractionAction::CookFunc),
                    "EInteractionActionMoveToDistance" => Ok(EInteractionAction::MoveToDistance),
                    "EInteractionActionMoveToPosition" => Ok(EInteractionAction::MoveToPosition),
                    "EInteractionActionMoveToInteractionSeat" => Ok(EInteractionAction::MoveToInteractionSeat),
                    "EInteractionActionRotateToTarget" => Ok(EInteractionAction::RotateToTarget),
                    "EInteractionActionRotateToTargetAndWait" => Ok(EInteractionAction::RotateToTargetAndWait),
                    "EInteractionActionAddClientBuff" => Ok(EInteractionAction::AddClientBuff),
                    "EInteractionActionAddClientBuffAndWait" => Ok(EInteractionAction::AddClientBuffAndWait),
                    "EInteractionActionAddClientBuffToTarget" => Ok(EInteractionAction::AddClientBuffToTarget),
                    "EInteractionActionAddClientBuffToTargetAndWait" => Ok(EInteractionAction::AddClientBuffToTargetAndWait),
                    "EInteractionActionProgressBar" => Ok(EInteractionAction::ProgressBar),
                    "EInteractionActionCameraInvoke" => Ok(EInteractionAction::CameraInvoke),
                    "EInteractionActionWaitUiConfirm" => Ok(EInteractionAction::WaitUiConfirm),
                    "EInteractionActionIgnoreInput" => Ok(EInteractionAction::IgnoreInput),
                    "EInteractionActionHideHud" => Ok(EInteractionAction::HideHud),
                    "EInteractionActionHideUI" => Ok(EInteractionAction::HideUi),
                    "EInteractionActionMoveToStaticObj" => Ok(EInteractionAction::MoveToStaticObj),
                    "EInteractionActionUnionWarDance" => Ok(EInteractionAction::UnionWarDance),
                    "EInteractionActionWaitInputMove" => Ok(EInteractionAction::WaitInputMove),
                    "EInteractionActionRemoveClientBuff" => Ok(EInteractionAction::RemoveClientBuff),
                    "EInteractionActionRemoveTargetClientBuff" => Ok(EInteractionAction::RemoveTargetClientBuff),
                    "EInteractionActionEnterAutoFlow" => Ok(EInteractionAction::EnterAutoFlow),
                    "EInteractionActionNpcTalkFlow" => Ok(EInteractionAction::NpcTalkFlow),
                    "EInteractionActionStartFlowAndWait" => Ok(EInteractionAction::StartFlowAndWait),
                    "EInteractionActionShowCutSceneAndWait" => Ok(EInteractionAction::ShowCutSceneAndWait),
                    "EInteractionActionSittingControl" => Ok(EInteractionAction::SittingControl),
                    "EInteractionActionMagneticAttach" => Ok(EInteractionAction::MagneticAttach),
                    "EInteractionActionSwitchCameraTemplate" => Ok(EInteractionAction::SwitchCameraTemplate),
                    "EInteractionActionHomeFarm" => Ok(EInteractionAction::HomeFarm),
                    "EInteractionActionLua" => Ok(EInteractionAction::Lua),
                    "EInteractionActionBase" => Ok(EInteractionAction::Base),
                    "EInteractionActionPivot" => Ok(EInteractionAction::Pivot),
                    "EInteractionActionPivotBreak" => Ok(EInteractionAction::PivotBreak),
                    "EInteractionActionTransferPoint" => Ok(EInteractionAction::TransferPoint),
                    "EInteractionActionLogicResonance" => Ok(EInteractionAction::LogicResonance),
                    "EInteractionActionLogicStatic" => Ok(EInteractionAction::LogicStatic),
                    "EInteractionActionLogicDance" => Ok(EInteractionAction::LogicDance),
                    "EInteractionActionAddBuff" => Ok(EInteractionAction::AddBuff),
                    "EInteractionActionTeleport" => Ok(EInteractionAction::Teleport),
                    "EInteractionActionEnterDungeon" => Ok(EInteractionAction::EnterDungeon),
                    "EInteractionActionEnterVisualLayer" => Ok(EInteractionAction::EnterVisualLayer),
                    "EInteractionActionExitVisualLayer" => Ok(EInteractionAction::ExitVisualLayer),
                    "EInteractionActionTriggerSceneEvent" => Ok(EInteractionAction::TriggerSceneEvent),
                    "EInteractionActionTriggerSceneCustomEvent" => Ok(EInteractionAction::TriggerSceneCustomEvent),
                    "EInteractionActionUserDoAction" => Ok(EInteractionAction::UserDoAction),
                    "EInteractionActionPickup" => Ok(EInteractionAction::Pickup),
                    "EInteractionActionOpenEliteTreasureBox" => Ok(EInteractionAction::OpenEliteTreasureBox),
                    "EInteractionActionOpenBossTreasureBox" => Ok(EInteractionAction::OpenBossTreasureBox),
                    "EInteractionActionQuest" => Ok(EInteractionAction::Quest),
                    "EInteractionActionQuestEvent" => Ok(EInteractionAction::QuestEvent),
                    "EInteractionActionKillSelf" => Ok(EInteractionAction::KillSelf),
                    "EInteractionActionSendAiEvent" => Ok(EInteractionAction::SendAiEvent),
                    "EInteractionActionDanceAwardNPC" => Ok(EInteractionAction::DanceAwardNpc),
                    "EInteractionActionRequestInteractionSeat" => Ok(EInteractionAction::RequestInteractionSeat),
                    "EInteractionActionRemoveBuff" => Ok(EInteractionAction::RemoveBuff),
                    "EInteractionActionAddBuffToTarget" => Ok(EInteractionAction::AddBuffToTarget),
                    "EInteractionActionRemoveBuffToTarget" => Ok(EInteractionAction::RemoveBuffToTarget),
                    "EInteractionActionPaintToySwitchPage" => Ok(EInteractionAction::PaintToySwitchPage),
                    "EInteractionActionOpenTowerTreasureBox" => Ok(EInteractionAction::OpenTowerTreasureBox),
                    "EInteractionActionRoughCollection" => Ok(EInteractionAction::RoughCollection),
                    "EInteractionActionFineCollection" => Ok(EInteractionAction::FineCollection),
                    "EInteractionActionBubbleActStart" => Ok(EInteractionAction::BubbleActStart),
                    "EInteractionActionBubbleActEnd" => Ok(EInteractionAction::BubbleActEnd),
                    "EInteractionActionRaidOpenBox" => Ok(EInteractionAction::RaidOpenBox),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EInteractionTemplateAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::EInteractionTemplateDefault => "EInteractionTemplateDefault",
            Self::EInteractionTemplateBegin => "EInteractionTemplateBegin",
            Self::EInteractionTemplateUpdate => "EInteractionTemplateUpdate",
            Self::EInteractionTemplateEnd => "EInteractionTemplateEnd",
            Self::EInteractionTemplateAbort => "EInteractionTemplateAbort",
            Self::EInteractionTemplateStageEnd => "EInteractionTemplateStageEnd",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EInteractionTemplateAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EInteractionTemplateDefault",
            "EInteractionTemplateBegin",
            "EInteractionTemplateUpdate",
            "EInteractionTemplateEnd",
            "EInteractionTemplateAbort",
            "EInteractionTemplateStageEnd",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EInteractionTemplateAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EInteractionTemplateDefault" => Ok(EInteractionTemplateAction::EInteractionTemplateDefault),
                    "EInteractionTemplateBegin" => Ok(EInteractionTemplateAction::EInteractionTemplateBegin),
                    "EInteractionTemplateUpdate" => Ok(EInteractionTemplateAction::EInteractionTemplateUpdate),
                    "EInteractionTemplateEnd" => Ok(EInteractionTemplateAction::EInteractionTemplateEnd),
                    "EInteractionTemplateAbort" => Ok(EInteractionTemplateAction::EInteractionTemplateAbort),
                    "EInteractionTemplateStageEnd" => Ok(EInteractionTemplateAction::EInteractionTemplateStageEnd),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EItemBindFlag {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ItemBindNone => "ItemBindNone",
            Self::ItemNotBind => "ItemNotBind",
            Self::ItemBindAll => "ItemBindAll",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EItemBindFlag {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ItemBindNone",
            "ItemNotBind",
            "ItemBindAll",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EItemBindFlag;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ItemBindNone" => Ok(EItemBindFlag::ItemBindNone),
                    "ItemNotBind" => Ok(EItemBindFlag::ItemNotBind),
                    "ItemBindAll" => Ok(EItemBindFlag::ItemBindAll),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EMoveType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::MoveIdle => "MoveIdle",
            Self::MoveWalk => "MoveWalk",
            Self::MoveRun => "MoveRun",
            Self::MoveDash => "MoveDash",
            Self::MoveDashEnd => "MoveDashEnd",
            Self::MoveAlert => "MoveAlert",
            Self::MoveFly => "MoveFly",
            Self::MovePatrol => "MovePatrol",
            Self::MovePatrolRun => "MovePatrolRun",
            Self::MoveFlyDash => "MoveFlyDash",
            Self::MoveCustom => "MoveCustom",
            Self::MoveParkourRun => "MoveParkourRun",
            Self::MoveSelfPhoto => "MoveSelfPhoto",
            Self::MoveRotate => "MoveRotate",
            Self::MoveDashTurn => "MoveDashTurn",
            Self::MoveWalkEnd => "MoveWalkEnd",
            Self::MoveRunEnd => "MoveRunEnd",
            Self::MoveWalkEndToIdle => "MoveWalkEndToIdle",
            Self::MoveRunEndToIdle => "MoveRunEndToIdle",
            Self::MoveEightDir => "MoveEightDir",
            Self::MoveByForce => "MoveByForce",
            Self::MoveSitRotate => "MoveSitRotate",
            Self::MoveJumpEndToIdle => "MoveJumpEndToIdle",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EMoveType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MoveIdle",
            "MoveWalk",
            "MoveRun",
            "MoveDash",
            "MoveDashEnd",
            "MoveAlert",
            "MoveFly",
            "MovePatrol",
            "MovePatrolRun",
            "MoveFlyDash",
            "MoveCustom",
            "MoveParkourRun",
            "MoveSelfPhoto",
            "MoveRotate",
            "MoveDashTurn",
            "MoveWalkEnd",
            "MoveRunEnd",
            "MoveWalkEndToIdle",
            "MoveRunEndToIdle",
            "MoveEightDir",
            "MoveByForce",
            "MoveSitRotate",
            "MoveJumpEndToIdle",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EMoveType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "MoveIdle" => Ok(EMoveType::MoveIdle),
                    "MoveWalk" => Ok(EMoveType::MoveWalk),
                    "MoveRun" => Ok(EMoveType::MoveRun),
                    "MoveDash" => Ok(EMoveType::MoveDash),
                    "MoveDashEnd" => Ok(EMoveType::MoveDashEnd),
                    "MoveAlert" => Ok(EMoveType::MoveAlert),
                    "MoveFly" => Ok(EMoveType::MoveFly),
                    "MovePatrol" => Ok(EMoveType::MovePatrol),
                    "MovePatrolRun" => Ok(EMoveType::MovePatrolRun),
                    "MoveFlyDash" => Ok(EMoveType::MoveFlyDash),
                    "MoveCustom" => Ok(EMoveType::MoveCustom),
                    "MoveParkourRun" => Ok(EMoveType::MoveParkourRun),
                    "MoveSelfPhoto" => Ok(EMoveType::MoveSelfPhoto),
                    "MoveRotate" => Ok(EMoveType::MoveRotate),
                    "MoveDashTurn" => Ok(EMoveType::MoveDashTurn),
                    "MoveWalkEnd" => Ok(EMoveType::MoveWalkEnd),
                    "MoveRunEnd" => Ok(EMoveType::MoveRunEnd),
                    "MoveWalkEndToIdle" => Ok(EMoveType::MoveWalkEndToIdle),
                    "MoveRunEndToIdle" => Ok(EMoveType::MoveRunEndToIdle),
                    "MoveEightDir" => Ok(EMoveType::MoveEightDir),
                    "MoveByForce" => Ok(EMoveType::MoveByForce),
                    "MoveSitRotate" => Ok(EMoveType::MoveSitRotate),
                    "MoveJumpEndToIdle" => Ok(EMoveType::MoveJumpEndToIdle),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ENotifyTrigger {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ETypeInZone => "ETypeInZone",
            Self::ETypeOutZone => "ETypeOutZone",
            Self::ETypeRange => "ETypeRange",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ENotifyTrigger {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ETypeInZone",
            "ETypeOutZone",
            "ETypeRange",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ENotifyTrigger;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ETypeInZone" => Ok(ENotifyTrigger::ETypeInZone),
                    "ETypeOutZone" => Ok(ENotifyTrigger::ETypeOutZone),
                    "ETypeRange" => Ok(ENotifyTrigger::ETypeRange),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EPictureType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ENormalPicture => "ENormalPicture",
            Self::ECameraOriginal => "ECameraOriginal",
            Self::ECameraRender => "ECameraRender",
            Self::ECameraThumbnail => "ECameraThumbnail",
            Self::EProfileSnapShot => "EProfileSnapShot",
            Self::EProfileHalfBody => "EProfileHalfBody",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EPictureType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ENormalPicture",
            "ECameraOriginal",
            "ECameraRender",
            "ECameraThumbnail",
            "EProfileSnapShot",
            "EProfileHalfBody",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EPictureType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ENormalPicture" => Ok(EPictureType::ENormalPicture),
                    "ECameraOriginal" => Ok(EPictureType::ECameraOriginal),
                    "ECameraRender" => Ok(EPictureType::ECameraRender),
                    "ECameraThumbnail" => Ok(EPictureType::ECameraThumbnail),
                    "EProfileSnapShot" => Ok(EPictureType::EProfileSnapShot),
                    "EProfileHalfBody" => Ok(EPictureType::EProfileHalfBody),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EQuestStepStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::QuestStepGoing => "QuestStepGoing",
            Self::QuestStepFinish => "QuestStepFinish",
            Self::QuestStepFail => "QuestStepFail",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EQuestStepStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "QuestStepGoing",
            "QuestStepFinish",
            "QuestStepFail",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EQuestStepStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "QuestStepGoing" => Ok(EQuestStepStatus::QuestStepGoing),
                    "QuestStepFinish" => Ok(EQuestStepStatus::QuestStepFinish),
                    "QuestStepFail" => Ok(EQuestStepStatus::QuestStepFail),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EReceiveRewardStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::NotReceive => "EReceiveRewardStatusNotReceive",
            Self::CanReceive => "EReceiveRewardStatusCanReceive",
            Self::Received => "EReceiveRewardStatusReceived",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EReceiveRewardStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EReceiveRewardStatusNotReceive",
            "EReceiveRewardStatusCanReceive",
            "EReceiveRewardStatusReceived",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EReceiveRewardStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EReceiveRewardStatusNotReceive" => Ok(EReceiveRewardStatus::NotReceive),
                    "EReceiveRewardStatusCanReceive" => Ok(EReceiveRewardStatus::CanReceive),
                    "EReceiveRewardStatusReceived" => Ok(EReceiveRewardStatus::Received),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ERidePropertyType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::RidePropertyTypeNone => "RidePropertyTypeNone",
            Self::RidePropertyTypeLand => "RidePropertyTypeLand",
            Self::RidePropertyTypeWater => "RidePropertyTypeWater",
            Self::RidePropertyTypeMax => "RidePropertyTypeMax",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ERidePropertyType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RidePropertyTypeNone",
            "RidePropertyTypeLand",
            "RidePropertyTypeWater",
            "RidePropertyTypeMax",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ERidePropertyType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "RidePropertyTypeNone" => Ok(ERidePropertyType::RidePropertyTypeNone),
                    "RidePropertyTypeLand" => Ok(ERidePropertyType::RidePropertyTypeLand),
                    "RidePropertyTypeWater" => Ok(ERidePropertyType::RidePropertyTypeWater),
                    "RidePropertyTypeMax" => Ok(ERidePropertyType::RidePropertyTypeMax),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ESceneLineStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::SceneLineStatusNone => "SceneLineStatusNone",
            Self::SceneLineStatusLow => "SceneLineStatusLow",
            Self::SceneLineStatusMedium => "SceneLineStatusMedium",
            Self::SceneLineStatusHigh => "SceneLineStatusHigh",
            Self::SceneLineStatusFull => "SceneLineStatusFull",
            Self::SceneLineStatusRecycle => "SceneLineStatusRecycle",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ESceneLineStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SceneLineStatusNone",
            "SceneLineStatusLow",
            "SceneLineStatusMedium",
            "SceneLineStatusHigh",
            "SceneLineStatusFull",
            "SceneLineStatusRecycle",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ESceneLineStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SceneLineStatusNone" => Ok(ESceneLineStatus::SceneLineStatusNone),
                    "SceneLineStatusLow" => Ok(ESceneLineStatus::SceneLineStatusLow),
                    "SceneLineStatusMedium" => Ok(ESceneLineStatus::SceneLineStatusMedium),
                    "SceneLineStatusHigh" => Ok(ESceneLineStatus::SceneLineStatusHigh),
                    "SceneLineStatusFull" => Ok(ESceneLineStatus::SceneLineStatusFull),
                    "SceneLineStatusRecycle" => Ok(ESceneLineStatus::SceneLineStatusRecycle),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EShowPieceType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ShowPieceNull => "ShowPieceNull",
            Self::ShowPieceNormalAction => "ShowPieceNormalAction",
            Self::ShowPieceEmote => "ShowPieceEmote",
            Self::ShowPieceDoubleAction => "ShowPieceDoubleAction",
            Self::ShowPieceSticker => "ShowPieceSticker",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EShowPieceType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ShowPieceNull",
            "ShowPieceNormalAction",
            "ShowPieceEmote",
            "ShowPieceDoubleAction",
            "ShowPieceSticker",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EShowPieceType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ShowPieceNull" => Ok(EShowPieceType::ShowPieceNull),
                    "ShowPieceNormalAction" => Ok(EShowPieceType::ShowPieceNormalAction),
                    "ShowPieceEmote" => Ok(EShowPieceType::ShowPieceEmote),
                    "ShowPieceDoubleAction" => Ok(EShowPieceType::ShowPieceDoubleAction),
                    "ShowPieceSticker" => Ok(EShowPieceType::ShowPieceSticker),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ESkillCdType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::ESkillCdNormal => "ESkillCDNormal",
            Self::ESkillCdCharge => "ESkillCDCharge",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ESkillCdType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ESkillCDNormal",
            "ESkillCDCharge",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ESkillCdType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ESkillCDNormal" => Ok(ESkillCdType::ESkillCdNormal),
                    "ESkillCDCharge" => Ok(ESkillCdType::ESkillCdCharge),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ETimerExeType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::TimerExeTypeNull => "TimerExeTypeNull",
            Self::TimerExeTypeStart => "TimerExeType_Start",
            Self::TimerExeTypeEnd => "TimerExeType_End",
            Self::TimerExeTypeCycleStart => "TimerExeType_Cycle_Start",
            Self::TimerExeTypeCycleEnd => "TimerExeType_Cycle_End",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ETimerExeType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TimerExeTypeNull",
            "TimerExeType_Start",
            "TimerExeType_End",
            "TimerExeType_Cycle_Start",
            "TimerExeType_Cycle_End",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ETimerExeType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "TimerExeTypeNull" => Ok(ETimerExeType::TimerExeTypeNull),
                    "TimerExeType_Start" => Ok(ETimerExeType::TimerExeTypeStart),
                    "TimerExeType_End" => Ok(ETimerExeType::TimerExeTypeEnd),
                    "TimerExeType_Cycle_Start" => Ok(ETimerExeType::TimerExeTypeCycleStart),
                    "TimerExeType_Cycle_End" => Ok(ETimerExeType::TimerExeTypeCycleEnd),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ETimerType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::TimerTypeNull => "TimerTypeNull",
            Self::TimerTypePoint => "TimerType_Point",
            Self::TimerTypeDay => "TimerType_Day",
            Self::TimerTypeMonth => "TimerType_Month",
            Self::TimerTypeWeek => "TimerType_Week",
            Self::TimerTypeInterval => "TimerType_Interval",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ETimerType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TimerTypeNull",
            "TimerType_Point",
            "TimerType_Day",
            "TimerType_Month",
            "TimerType_Week",
            "TimerType_Interval",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ETimerType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "TimerTypeNull" => Ok(ETimerType::TimerTypeNull),
                    "TimerType_Point" => Ok(ETimerType::TimerTypePoint),
                    "TimerType_Day" => Ok(ETimerType::TimerTypeDay),
                    "TimerType_Month" => Ok(ETimerType::TimerTypeMonth),
                    "TimerType_Week" => Ok(ETimerType::TimerTypeWeek),
                    "TimerType_Interval" => Ok(ETimerType::TimerTypeInterval),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EUseSlotType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::UseSlotTypeOther => "UseSlotType_Other",
            Self::UseSlotTypeSkill => "UseSlotType_Skill",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EUseSlotType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UseSlotType_Other",
            "UseSlotType_Skill",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EUseSlotType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "UseSlotType_Other" => Ok(EUseSlotType::UseSlotTypeOther),
                    "UseSlotType_Skill" => Ok(EUseSlotType::UseSlotTypeSkill),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EUserTransferType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Default => "EUserTransferTypeDefault",
            Self::ScenePosition => "EUserTransferTypeScenePosition",
            Self::ScenePosId => "EUserTransferTypeScenePosId",
            Self::Pivot => "EUserTransferTypePivot",
            Self::CutScene => "EUserTransferTypeCutScene",
            Self::Near => "EUserTransferTypeNear",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for EUserTransferType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EUserTransferTypeDefault",
            "EUserTransferTypeScenePosition",
            "EUserTransferTypeScenePosId",
            "EUserTransferTypePivot",
            "EUserTransferTypeCutScene",
            "EUserTransferTypeNear",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EUserTransferType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EUserTransferTypeDefault" => Ok(EUserTransferType::Default),
                    "EUserTransferTypeScenePosition" => Ok(EUserTransferType::ScenePosition),
                    "EUserTransferTypeScenePosId" => Ok(EUserTransferType::ScenePosId),
                    "EUserTransferTypePivot" => Ok(EUserTransferType::Pivot),
                    "EUserTransferTypeCutScene" => Ok(EUserTransferType::CutScene),
                    "EUserTransferTypeNear" => Ok(EUserTransferType::Near),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EditorUiPosition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.x.is_some() {
            len += 1;
        }
        if self.y.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EditorUIPosition", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.x.as_ref() {
            struct_ser.serialize_field("X", v)?;
        }
        if let Some(v) = self.y.as_ref() {
            struct_ser.serialize_field("Y", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EditorUiPosition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "X",
            "Y",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            X,
            Y,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "X" => Ok(GeneratedField::X),
                            "Y" => Ok(GeneratedField::Y),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EditorUiPosition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EditorUIPosition")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EditorUiPosition, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut x__ = None;
                let mut y__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::X => {
                            if x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("X"));
                            }
                            x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Y => {
                            if y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Y"));
                            }
                            y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(EditorUiPosition {
                    id: id__,
                    x: x__,
                    y: y__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EditorUIPosition", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EnergyInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.energy_value.is_some() {
            len += 1;
        }
        if self.unlock_num.is_some() {
            len += 1;
        }
        if !self.energy_item_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EnergyInfo", len)?;
        if let Some(v) = self.energy_value.as_ref() {
            struct_ser.serialize_field("EnergyValue", v)?;
        }
        if let Some(v) = self.unlock_num.as_ref() {
            struct_ser.serialize_field("UnlockNum", v)?;
        }
        if !self.energy_item_info.is_empty() {
            struct_ser.serialize_field("EnergyItemInfo", &self.energy_item_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EnergyInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EnergyValue",
            "UnlockNum",
            "EnergyItemInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EnergyValue,
            UnlockNum,
            EnergyItemInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EnergyValue" => Ok(GeneratedField::EnergyValue),
                            "UnlockNum" => Ok(GeneratedField::UnlockNum),
                            "EnergyItemInfo" => Ok(GeneratedField::EnergyItemInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EnergyInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EnergyInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EnergyInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut energy_value__ = None;
                let mut unlock_num__ = None;
                let mut energy_item_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EnergyValue => {
                            if energy_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnergyValue"));
                            }
                            energy_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::UnlockNum => {
                            if unlock_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockNum"));
                            }
                            unlock_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EnergyItemInfo => {
                            if energy_item_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnergyItemInfo"));
                            }
                            energy_item_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(EnergyInfo {
                    energy_value: energy_value__,
                    unlock_num: unlock_num__,
                    energy_item_info: energy_item_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EnergyInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EnergyItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.energy_limit.is_some() {
            len += 1;
        }
        if self.extra_energy_limit.is_some() {
            len += 1;
        }
        if !self.energy_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EnergyItem", len)?;
        if let Some(v) = self.energy_limit.as_ref() {
            struct_ser.serialize_field("EnergyLimit", v)?;
        }
        if let Some(v) = self.extra_energy_limit.as_ref() {
            struct_ser.serialize_field("ExtraEnergyLimit", v)?;
        }
        if !self.energy_info.is_empty() {
            struct_ser.serialize_field("EnergyInfo", &self.energy_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EnergyItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EnergyLimit",
            "ExtraEnergyLimit",
            "EnergyInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EnergyLimit,
            ExtraEnergyLimit,
            EnergyInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EnergyLimit" => Ok(GeneratedField::EnergyLimit),
                            "ExtraEnergyLimit" => Ok(GeneratedField::ExtraEnergyLimit),
                            "EnergyInfo" => Ok(GeneratedField::EnergyInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EnergyItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EnergyItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EnergyItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut energy_limit__ = None;
                let mut extra_energy_limit__ = None;
                let mut energy_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EnergyLimit => {
                            if energy_limit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnergyLimit"));
                            }
                            energy_limit__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExtraEnergyLimit => {
                            if extra_energy_limit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExtraEnergyLimit"));
                            }
                            extra_energy_limit__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EnergyInfo => {
                            if energy_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnergyInfo"));
                            }
                            energy_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(EnergyItem {
                    energy_limit: energy_limit__,
                    extra_energy_limit: extra_energy_limit__,
                    energy_info: energy_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EnergyItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EnergyItemInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.queue_id.is_some() {
            len += 1;
        }
        if self.column_id.is_some() {
            len += 1;
        }
        if self.refine_state.is_some() {
            len += 1;
        }
        if self.gain_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EnergyItemInfo", len)?;
        if let Some(v) = self.queue_id.as_ref() {
            struct_ser.serialize_field("QueueId", v)?;
        }
        if let Some(v) = self.column_id.as_ref() {
            struct_ser.serialize_field("ColumnId", v)?;
        }
        if let Some(v) = self.refine_state.as_ref() {
            struct_ser.serialize_field("RefineState", v)?;
        }
        if let Some(v) = self.gain_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("GainTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EnergyItemInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "QueueId",
            "ColumnId",
            "RefineState",
            "GainTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            QueueId,
            ColumnId,
            RefineState,
            GainTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "QueueId" => Ok(GeneratedField::QueueId),
                            "ColumnId" => Ok(GeneratedField::ColumnId),
                            "RefineState" => Ok(GeneratedField::RefineState),
                            "GainTime" => Ok(GeneratedField::GainTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EnergyItemInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EnergyItemInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EnergyItemInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut queue_id__ = None;
                let mut column_id__ = None;
                let mut refine_state__ = None;
                let mut gain_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::QueueId => {
                            if queue_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("QueueId"));
                            }
                            queue_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ColumnId => {
                            if column_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ColumnId"));
                            }
                            column_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RefineState => {
                            if refine_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefineState"));
                            }
                            refine_state__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GainTime => {
                            if gain_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GainTime"));
                            }
                            gain_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(EnergyItemInfo {
                    queue_id: queue_id__,
                    column_id: column_id__,
                    refine_state: refine_state__,
                    gain_time: gain_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EnergyItemInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EnterScene {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.enter_scene_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EnterScene", len)?;
        if let Some(v) = self.enter_scene_info.as_ref() {
            struct_ser.serialize_field("EnterSceneInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EnterScene {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EnterSceneInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EnterSceneInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EnterSceneInfo" => Ok(GeneratedField::EnterSceneInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EnterScene;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EnterScene")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EnterScene, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut enter_scene_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EnterSceneInfo => {
                            if enter_scene_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnterSceneInfo"));
                            }
                            enter_scene_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EnterScene {
                    enter_scene_info: enter_scene_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EnterScene", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EnterSceneInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scene_attrs.is_some() {
            len += 1;
        }
        if self.player_ent.is_some() {
            len += 1;
        }
        if self.scene_guid.is_some() {
            len += 1;
        }
        if self.connect_guid.is_some() {
            len += 1;
        }
        if self.subscene_attrs.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EnterSceneInfo", len)?;
        if let Some(v) = self.scene_attrs.as_ref() {
            struct_ser.serialize_field("SceneAttrs", v)?;
        }
        if let Some(v) = self.player_ent.as_ref() {
            struct_ser.serialize_field("PlayerEnt", v)?;
        }
        if let Some(v) = self.scene_guid.as_ref() {
            struct_ser.serialize_field("SceneGuid", v)?;
        }
        if let Some(v) = self.connect_guid.as_ref() {
            struct_ser.serialize_field("ConnectGuid", v)?;
        }
        if let Some(v) = self.subscene_attrs.as_ref() {
            struct_ser.serialize_field("SubsceneAttrs", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EnterSceneInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SceneAttrs",
            "PlayerEnt",
            "SceneGuid",
            "ConnectGuid",
            "SubsceneAttrs",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SceneAttrs,
            PlayerEnt,
            SceneGuid,
            ConnectGuid,
            SubsceneAttrs,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SceneAttrs" => Ok(GeneratedField::SceneAttrs),
                            "PlayerEnt" => Ok(GeneratedField::PlayerEnt),
                            "SceneGuid" => Ok(GeneratedField::SceneGuid),
                            "ConnectGuid" => Ok(GeneratedField::ConnectGuid),
                            "SubsceneAttrs" => Ok(GeneratedField::SubsceneAttrs),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EnterSceneInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EnterSceneInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EnterSceneInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_attrs__ = None;
                let mut player_ent__ = None;
                let mut scene_guid__ = None;
                let mut connect_guid__ = None;
                let mut subscene_attrs__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SceneAttrs => {
                            if scene_attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneAttrs"));
                            }
                            scene_attrs__ = map_.next_value()?;
                        }
                        GeneratedField::PlayerEnt => {
                            if player_ent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayerEnt"));
                            }
                            player_ent__ = map_.next_value()?;
                        }
                        GeneratedField::SceneGuid => {
                            if scene_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneGuid"));
                            }
                            scene_guid__ = map_.next_value()?;
                        }
                        GeneratedField::ConnectGuid => {
                            if connect_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConnectGuid"));
                            }
                            connect_guid__ = map_.next_value()?;
                        }
                        GeneratedField::SubsceneAttrs => {
                            if subscene_attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SubsceneAttrs"));
                            }
                            subscene_attrs__ = map_.next_value()?;
                        }
                    }
                }
                Ok(EnterSceneInfo {
                    scene_attrs: scene_attrs__,
                    player_ent: player_ent__,
                    scene_guid: scene_guid__,
                    connect_guid: connect_guid__,
                    subscene_attrs: subscene_attrs__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EnterSceneInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Entity {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if self.ent_type.is_some() {
            len += 1;
        }
        if self.attrs.is_some() {
            len += 1;
        }
        if self.temp_attrs.is_some() {
            len += 1;
        }
        if self.body_part_infos.is_some() {
            len += 1;
        }
        if self.passive_skill_infos.is_some() {
            len += 1;
        }
        if self.buff_infos.is_some() {
            len += 1;
        }
        if self.buff_effect.is_some() {
            len += 1;
        }
        if self.appear_type.is_some() {
            len += 1;
        }
        if !self.magnetic_ride_queue_change_info_dict.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Entity", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.ent_type.as_ref() {
            let v = EEntityType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("EntType", &v)?;
        }
        if let Some(v) = self.attrs.as_ref() {
            struct_ser.serialize_field("Attrs", v)?;
        }
        if let Some(v) = self.temp_attrs.as_ref() {
            struct_ser.serialize_field("TempAttrs", v)?;
        }
        if let Some(v) = self.body_part_infos.as_ref() {
            struct_ser.serialize_field("BodyPartInfos", v)?;
        }
        if let Some(v) = self.passive_skill_infos.as_ref() {
            struct_ser.serialize_field("PassiveSkillInfos", v)?;
        }
        if let Some(v) = self.buff_infos.as_ref() {
            struct_ser.serialize_field("BuffInfos", v)?;
        }
        if let Some(v) = self.buff_effect.as_ref() {
            struct_ser.serialize_field("BuffEffect", v)?;
        }
        if let Some(v) = self.appear_type.as_ref() {
            let v = EAppearType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("AppearType", &v)?;
        }
        if !self.magnetic_ride_queue_change_info_dict.is_empty() {
            struct_ser.serialize_field("MagneticRideQueueChangeInfoDict", &self.magnetic_ride_queue_change_info_dict)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Entity {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "EntType",
            "Attrs",
            "TempAttrs",
            "BodyPartInfos",
            "PassiveSkillInfos",
            "BuffInfos",
            "BuffEffect",
            "AppearType",
            "MagneticRideQueueChangeInfoDict",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            EntType,
            Attrs,
            TempAttrs,
            BodyPartInfos,
            PassiveSkillInfos,
            BuffInfos,
            BuffEffect,
            AppearType,
            MagneticRideQueueChangeInfoDict,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "EntType" => Ok(GeneratedField::EntType),
                            "Attrs" => Ok(GeneratedField::Attrs),
                            "TempAttrs" => Ok(GeneratedField::TempAttrs),
                            "BodyPartInfos" => Ok(GeneratedField::BodyPartInfos),
                            "PassiveSkillInfos" => Ok(GeneratedField::PassiveSkillInfos),
                            "BuffInfos" => Ok(GeneratedField::BuffInfos),
                            "BuffEffect" => Ok(GeneratedField::BuffEffect),
                            "AppearType" => Ok(GeneratedField::AppearType),
                            "MagneticRideQueueChangeInfoDict" => Ok(GeneratedField::MagneticRideQueueChangeInfoDict),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Entity;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Entity")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Entity, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut ent_type__ = None;
                let mut attrs__ = None;
                let mut temp_attrs__ = None;
                let mut body_part_infos__ = None;
                let mut passive_skill_infos__ = None;
                let mut buff_infos__ = None;
                let mut buff_effect__ = None;
                let mut appear_type__ = None;
                let mut magnetic_ride_queue_change_info_dict__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EntType => {
                            if ent_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EntType"));
                            }
                            ent_type__ = map_.next_value::<::std::option::Option<EEntityType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Attrs => {
                            if attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Attrs"));
                            }
                            attrs__ = map_.next_value()?;
                        }
                        GeneratedField::TempAttrs => {
                            if temp_attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TempAttrs"));
                            }
                            temp_attrs__ = map_.next_value()?;
                        }
                        GeneratedField::BodyPartInfos => {
                            if body_part_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BodyPartInfos"));
                            }
                            body_part_infos__ = map_.next_value()?;
                        }
                        GeneratedField::PassiveSkillInfos => {
                            if passive_skill_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PassiveSkillInfos"));
                            }
                            passive_skill_infos__ = map_.next_value()?;
                        }
                        GeneratedField::BuffInfos => {
                            if buff_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffInfos"));
                            }
                            buff_infos__ = map_.next_value()?;
                        }
                        GeneratedField::BuffEffect => {
                            if buff_effect__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffEffect"));
                            }
                            buff_effect__ = map_.next_value()?;
                        }
                        GeneratedField::AppearType => {
                            if appear_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AppearType"));
                            }
                            appear_type__ = map_.next_value::<::std::option::Option<EAppearType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::MagneticRideQueueChangeInfoDict => {
                            if magnetic_ride_queue_change_info_dict__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MagneticRideQueueChangeInfoDict"));
                            }
                            magnetic_ride_queue_change_info_dict__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(Entity {
                    uuid: uuid__,
                    ent_type: ent_type__,
                    attrs: attrs__,
                    temp_attrs: temp_attrs__,
                    body_part_infos: body_part_infos__,
                    passive_skill_infos: passive_skill_infos__,
                    buff_infos: buff_infos__,
                    buff_effect: buff_effect__,
                    appear_type: appear_type__,
                    magnetic_ride_queue_change_info_dict: magnetic_ride_queue_change_info_dict__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Entity", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EquipAttr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.base_attrs.is_empty() {
            len += 1;
        }
        if self.perfection_value.is_some() {
            len += 1;
        }
        if self.recast_count.is_some() {
            len += 1;
        }
        if self.total_recast_count.is_some() {
            len += 1;
        }
        if !self.basic_attr.is_empty() {
            len += 1;
        }
        if !self.advance_attr.is_empty() {
            len += 1;
        }
        if !self.recast_attr.is_empty() {
            len += 1;
        }
        if self.perfection_level.is_some() {
            len += 1;
        }
        if !self.rare_quality_attr.is_empty() {
            len += 1;
        }
        if self.max_perfection_value.is_some() {
            len += 1;
        }
        if self.equip_attr_set.is_some() {
            len += 1;
        }
        if self.break_through_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EquipAttr", len)?;
        if !self.base_attrs.is_empty() {
            struct_ser.serialize_field("BaseAttrs", &self.base_attrs)?;
        }
        if let Some(v) = self.perfection_value.as_ref() {
            struct_ser.serialize_field("PerfectionValue", v)?;
        }
        if let Some(v) = self.recast_count.as_ref() {
            struct_ser.serialize_field("RecastCount", v)?;
        }
        if let Some(v) = self.total_recast_count.as_ref() {
            struct_ser.serialize_field("TotalRecastCount", v)?;
        }
        if !self.basic_attr.is_empty() {
            struct_ser.serialize_field("BasicAttr", &self.basic_attr)?;
        }
        if !self.advance_attr.is_empty() {
            struct_ser.serialize_field("AdvanceAttr", &self.advance_attr)?;
        }
        if !self.recast_attr.is_empty() {
            struct_ser.serialize_field("RecastAttr", &self.recast_attr)?;
        }
        if let Some(v) = self.perfection_level.as_ref() {
            struct_ser.serialize_field("PerfectionLevel", v)?;
        }
        if !self.rare_quality_attr.is_empty() {
            struct_ser.serialize_field("RareQualityAttr", &self.rare_quality_attr)?;
        }
        if let Some(v) = self.max_perfection_value.as_ref() {
            struct_ser.serialize_field("MaxPerfectionValue", v)?;
        }
        if let Some(v) = self.equip_attr_set.as_ref() {
            struct_ser.serialize_field("EquipAttrSet", v)?;
        }
        if let Some(v) = self.break_through_time.as_ref() {
            struct_ser.serialize_field("BreakThroughTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EquipAttr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BaseAttrs",
            "PerfectionValue",
            "RecastCount",
            "TotalRecastCount",
            "BasicAttr",
            "AdvanceAttr",
            "RecastAttr",
            "PerfectionLevel",
            "RareQualityAttr",
            "MaxPerfectionValue",
            "EquipAttrSet",
            "BreakThroughTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BaseAttrs,
            PerfectionValue,
            RecastCount,
            TotalRecastCount,
            BasicAttr,
            AdvanceAttr,
            RecastAttr,
            PerfectionLevel,
            RareQualityAttr,
            MaxPerfectionValue,
            EquipAttrSet,
            BreakThroughTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BaseAttrs" => Ok(GeneratedField::BaseAttrs),
                            "PerfectionValue" => Ok(GeneratedField::PerfectionValue),
                            "RecastCount" => Ok(GeneratedField::RecastCount),
                            "TotalRecastCount" => Ok(GeneratedField::TotalRecastCount),
                            "BasicAttr" => Ok(GeneratedField::BasicAttr),
                            "AdvanceAttr" => Ok(GeneratedField::AdvanceAttr),
                            "RecastAttr" => Ok(GeneratedField::RecastAttr),
                            "PerfectionLevel" => Ok(GeneratedField::PerfectionLevel),
                            "RareQualityAttr" => Ok(GeneratedField::RareQualityAttr),
                            "MaxPerfectionValue" => Ok(GeneratedField::MaxPerfectionValue),
                            "EquipAttrSet" => Ok(GeneratedField::EquipAttrSet),
                            "BreakThroughTime" => Ok(GeneratedField::BreakThroughTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EquipAttr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EquipAttr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EquipAttr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut base_attrs__ = None;
                let mut perfection_value__ = None;
                let mut recast_count__ = None;
                let mut total_recast_count__ = None;
                let mut basic_attr__ = None;
                let mut advance_attr__ = None;
                let mut recast_attr__ = None;
                let mut perfection_level__ = None;
                let mut rare_quality_attr__ = None;
                let mut max_perfection_value__ = None;
                let mut equip_attr_set__ = None;
                let mut break_through_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BaseAttrs => {
                            if base_attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BaseAttrs"));
                            }
                            base_attrs__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<u32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::PerfectionValue => {
                            if perfection_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PerfectionValue"));
                            }
                            perfection_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RecastCount => {
                            if recast_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RecastCount"));
                            }
                            recast_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TotalRecastCount => {
                            if total_recast_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TotalRecastCount"));
                            }
                            total_recast_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BasicAttr => {
                            if basic_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BasicAttr"));
                            }
                            basic_attr__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::AdvanceAttr => {
                            if advance_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AdvanceAttr"));
                            }
                            advance_attr__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::RecastAttr => {
                            if recast_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RecastAttr"));
                            }
                            recast_attr__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::PerfectionLevel => {
                            if perfection_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PerfectionLevel"));
                            }
                            perfection_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RareQualityAttr => {
                            if rare_quality_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RareQualityAttr"));
                            }
                            rare_quality_attr__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::MaxPerfectionValue => {
                            if max_perfection_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaxPerfectionValue"));
                            }
                            max_perfection_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EquipAttrSet => {
                            if equip_attr_set__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipAttrSet"));
                            }
                            equip_attr_set__ = map_.next_value()?;
                        }
                        GeneratedField::BreakThroughTime => {
                            if break_through_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BreakThroughTime"));
                            }
                            break_through_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(EquipAttr {
                    base_attrs: base_attrs__.unwrap_or_default(),
                    perfection_value: perfection_value__,
                    recast_count: recast_count__,
                    total_recast_count: total_recast_count__,
                    basic_attr: basic_attr__.unwrap_or_default(),
                    advance_attr: advance_attr__.unwrap_or_default(),
                    recast_attr: recast_attr__.unwrap_or_default(),
                    perfection_level: perfection_level__,
                    rare_quality_attr: rare_quality_attr__.unwrap_or_default(),
                    max_perfection_value: max_perfection_value__,
                    equip_attr_set: equip_attr_set__,
                    break_through_time: break_through_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EquipAttr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EquipAttrSet {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.basic_attr.is_empty() {
            len += 1;
        }
        if !self.advance_attr.is_empty() {
            len += 1;
        }
        if !self.recast_attr.is_empty() {
            len += 1;
        }
        if !self.rare_quality_attr.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EquipAttrSet", len)?;
        if !self.basic_attr.is_empty() {
            struct_ser.serialize_field("BasicAttr", &self.basic_attr)?;
        }
        if !self.advance_attr.is_empty() {
            struct_ser.serialize_field("AdvanceAttr", &self.advance_attr)?;
        }
        if !self.recast_attr.is_empty() {
            struct_ser.serialize_field("RecastAttr", &self.recast_attr)?;
        }
        if !self.rare_quality_attr.is_empty() {
            struct_ser.serialize_field("RareQualityAttr", &self.rare_quality_attr)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EquipAttrSet {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BasicAttr",
            "AdvanceAttr",
            "RecastAttr",
            "RareQualityAttr",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BasicAttr,
            AdvanceAttr,
            RecastAttr,
            RareQualityAttr,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BasicAttr" => Ok(GeneratedField::BasicAttr),
                            "AdvanceAttr" => Ok(GeneratedField::AdvanceAttr),
                            "RecastAttr" => Ok(GeneratedField::RecastAttr),
                            "RareQualityAttr" => Ok(GeneratedField::RareQualityAttr),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EquipAttrSet;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EquipAttrSet")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EquipAttrSet, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut basic_attr__ = None;
                let mut advance_attr__ = None;
                let mut recast_attr__ = None;
                let mut rare_quality_attr__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BasicAttr => {
                            if basic_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BasicAttr"));
                            }
                            basic_attr__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::AdvanceAttr => {
                            if advance_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AdvanceAttr"));
                            }
                            advance_attr__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::RecastAttr => {
                            if recast_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RecastAttr"));
                            }
                            recast_attr__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::RareQualityAttr => {
                            if rare_quality_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RareQualityAttr"));
                            }
                            rare_quality_attr__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(EquipAttrSet {
                    basic_attr: basic_attr__.unwrap_or_default(),
                    advance_attr: advance_attr__.unwrap_or_default(),
                    recast_attr: recast_attr__.unwrap_or_default(),
                    rare_quality_attr: rare_quality_attr__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EquipAttrSet", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EquipData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.equip_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EquipData", len)?;
        if !self.equip_infos.is_empty() {
            struct_ser.serialize_field("EquipInfos", &self.equip_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EquipData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EquipInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EquipInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EquipInfos" => Ok(GeneratedField::EquipInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EquipData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EquipData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EquipData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut equip_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EquipInfos => {
                            if equip_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipInfos"));
                            }
                            equip_infos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EquipData {
                    equip_infos: equip_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EquipData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EquipEnchantInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.enchant_item_type_id.is_some() {
            len += 1;
        }
        if self.enchant_level.is_some() {
            len += 1;
        }
        if self.enchant_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EquipEnchantInfo", len)?;
        if let Some(v) = self.enchant_item_type_id.as_ref() {
            struct_ser.serialize_field("EnchantItemTypeId", v)?;
        }
        if let Some(v) = self.enchant_level.as_ref() {
            struct_ser.serialize_field("EnchantLevel", v)?;
        }
        if let Some(v) = self.enchant_type.as_ref() {
            let v = EEquipEnchantType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("EnchantType", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EquipEnchantInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EnchantItemTypeId",
            "EnchantLevel",
            "EnchantType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EnchantItemTypeId,
            EnchantLevel,
            EnchantType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EnchantItemTypeId" => Ok(GeneratedField::EnchantItemTypeId),
                            "EnchantLevel" => Ok(GeneratedField::EnchantLevel),
                            "EnchantType" => Ok(GeneratedField::EnchantType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EquipEnchantInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EquipEnchantInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EquipEnchantInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut enchant_item_type_id__ = None;
                let mut enchant_level__ = None;
                let mut enchant_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EnchantItemTypeId => {
                            if enchant_item_type_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnchantItemTypeId"));
                            }
                            enchant_item_type_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EnchantLevel => {
                            if enchant_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnchantLevel"));
                            }
                            enchant_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EnchantType => {
                            if enchant_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnchantType"));
                            }
                            enchant_type__ = map_.next_value::<::std::option::Option<EEquipEnchantType>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(EquipEnchantInfo {
                    enchant_item_type_id: enchant_item_type_id__,
                    enchant_level: enchant_level__,
                    enchant_type: enchant_type__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EquipEnchantInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EquipInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.equip_slot.is_some() {
            len += 1;
        }
        if self.item_uuid.is_some() {
            len += 1;
        }
        if self.equip_slot_refine_level.is_some() {
            len += 1;
        }
        if self.equip_slot_refine_failed_count.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EquipInfo", len)?;
        if let Some(v) = self.equip_slot.as_ref() {
            struct_ser.serialize_field("EquipSlot", v)?;
        }
        if let Some(v) = self.item_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ItemUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.equip_slot_refine_level.as_ref() {
            struct_ser.serialize_field("EquipSlotRefineLevel", v)?;
        }
        if let Some(v) = self.equip_slot_refine_failed_count.as_ref() {
            struct_ser.serialize_field("EquipSlotRefineFailedCount", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EquipInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EquipSlot",
            "ItemUuid",
            "EquipSlotRefineLevel",
            "EquipSlotRefineFailedCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EquipSlot,
            ItemUuid,
            EquipSlotRefineLevel,
            EquipSlotRefineFailedCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EquipSlot" => Ok(GeneratedField::EquipSlot),
                            "ItemUuid" => Ok(GeneratedField::ItemUuid),
                            "EquipSlotRefineLevel" => Ok(GeneratedField::EquipSlotRefineLevel),
                            "EquipSlotRefineFailedCount" => Ok(GeneratedField::EquipSlotRefineFailedCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EquipInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EquipInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EquipInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut equip_slot__ = None;
                let mut item_uuid__ = None;
                let mut equip_slot_refine_level__ = None;
                let mut equip_slot_refine_failed_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EquipSlot => {
                            if equip_slot__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipSlot"));
                            }
                            equip_slot__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ItemUuid => {
                            if item_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ItemUuid"));
                            }
                            item_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EquipSlotRefineLevel => {
                            if equip_slot_refine_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipSlotRefineLevel"));
                            }
                            equip_slot_refine_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EquipSlotRefineFailedCount => {
                            if equip_slot_refine_failed_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipSlotRefineFailedCount"));
                            }
                            equip_slot_refine_failed_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(EquipInfo {
                    equip_slot: equip_slot__,
                    item_uuid: item_uuid__,
                    equip_slot_refine_level: equip_slot_refine_level__,
                    equip_slot_refine_failed_count: equip_slot_refine_failed_count__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EquipInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EquipList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.equip_list.is_empty() {
            len += 1;
        }
        if self.equip_attr.is_some() {
            len += 1;
        }
        if !self.equip_recast_info.is_empty() {
            len += 1;
        }
        if !self.equip_enchant.is_empty() {
            len += 1;
        }
        if !self.suit_info_dict.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EquipList", len)?;
        if !self.equip_list.is_empty() {
            struct_ser.serialize_field("EquipList", &self.equip_list)?;
        }
        if let Some(v) = self.equip_attr.as_ref() {
            struct_ser.serialize_field("EquipAttr", v)?;
        }
        if !self.equip_recast_info.is_empty() {
            struct_ser.serialize_field("EquipRecastInfo", &self.equip_recast_info)?;
        }
        if !self.equip_enchant.is_empty() {
            struct_ser.serialize_field("EquipEnchant", &self.equip_enchant)?;
        }
        if !self.suit_info_dict.is_empty() {
            struct_ser.serialize_field("SuitInfoDict", &self.suit_info_dict)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EquipList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EquipList_",
            "EquipList",
            "EquipAttr",
            "EquipRecastInfo",
            "EquipEnchant",
            "SuitInfoDict",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EquipList,
            EquipAttr,
            EquipRecastInfo,
            EquipEnchant,
            SuitInfoDict,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EquipList" | "EquipList_" => Ok(GeneratedField::EquipList),
                            "EquipAttr" => Ok(GeneratedField::EquipAttr),
                            "EquipRecastInfo" => Ok(GeneratedField::EquipRecastInfo),
                            "EquipEnchant" => Ok(GeneratedField::EquipEnchant),
                            "SuitInfoDict" => Ok(GeneratedField::SuitInfoDict),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EquipList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EquipList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EquipList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut equip_list__ = None;
                let mut equip_attr__ = None;
                let mut equip_recast_info__ = None;
                let mut equip_enchant__ = None;
                let mut suit_info_dict__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EquipList => {
                            if equip_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipList"));
                            }
                            equip_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::EquipAttr => {
                            if equip_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipAttr"));
                            }
                            equip_attr__ = map_.next_value()?;
                        }
                        GeneratedField::EquipRecastInfo => {
                            if equip_recast_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipRecastInfo"));
                            }
                            equip_recast_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::EquipEnchant => {
                            if equip_enchant__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipEnchant"));
                            }
                            equip_enchant__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::SuitInfoDict => {
                            if suit_info_dict__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SuitInfoDict"));
                            }
                            suit_info_dict__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(EquipList {
                    equip_list: equip_list__.unwrap_or_default(),
                    equip_attr: equip_attr__,
                    equip_recast_info: equip_recast_info__.unwrap_or_default(),
                    equip_enchant: equip_enchant__.unwrap_or_default(),
                    suit_info_dict: suit_info_dict__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EquipList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EquipNine {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.slot.is_some() {
            len += 1;
        }
        if self.equip_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EquipNine", len)?;
        if let Some(v) = self.slot.as_ref() {
            struct_ser.serialize_field("Slot", v)?;
        }
        if let Some(v) = self.equip_id.as_ref() {
            struct_ser.serialize_field("EquipID", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EquipNine {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Slot",
            "EquipID",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Slot,
            EquipId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Slot" => Ok(GeneratedField::Slot),
                            "EquipID" => Ok(GeneratedField::EquipId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EquipNine;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EquipNine")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EquipNine, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut slot__ = None;
                let mut equip_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Slot => {
                            if slot__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Slot"));
                            }
                            slot__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EquipId => {
                            if equip_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipID"));
                            }
                            equip_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(EquipNine {
                    slot: slot__,
                    equip_id: equip_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EquipNine", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EquipSuitInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.suit_attr.is_empty() {
            len += 1;
        }
        if self.attr_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EquipSuitInfo", len)?;
        if !self.suit_attr.is_empty() {
            struct_ser.serialize_field("SuitAttr", &self.suit_attr)?;
        }
        if let Some(v) = self.attr_type.as_ref() {
            struct_ser.serialize_field("AttrType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EquipSuitInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SuitAttr",
            "AttrType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SuitAttr,
            AttrType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SuitAttr" => Ok(GeneratedField::SuitAttr),
                            "AttrType" => Ok(GeneratedField::AttrType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EquipSuitInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EquipSuitInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EquipSuitInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut suit_attr__ = None;
                let mut attr_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SuitAttr => {
                            if suit_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SuitAttr"));
                            }
                            suit_attr__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::AttrType => {
                            if attr_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AttrType"));
                            }
                            attr_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(EquipSuitInfo {
                    suit_attr: suit_attr__.unwrap_or_default(),
                    attr_type: attr_type__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EquipSuitInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EventData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.event_type.is_some() {
            len += 1;
        }
        if !self.int_params.is_empty() {
            len += 1;
        }
        if !self.long_params.is_empty() {
            len += 1;
        }
        if !self.float_params.is_empty() {
            len += 1;
        }
        if !self.str_params.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EventData", len)?;
        if let Some(v) = self.event_type.as_ref() {
            struct_ser.serialize_field("EventType", v)?;
        }
        if !self.int_params.is_empty() {
            struct_ser.serialize_field("IntParams", &self.int_params)?;
        }
        if !self.long_params.is_empty() {
            struct_ser.serialize_field("LongParams", &self.long_params.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if !self.float_params.is_empty() {
            struct_ser.serialize_field("FloatParams", &self.float_params)?;
        }
        if !self.str_params.is_empty() {
            struct_ser.serialize_field("StrParams", &self.str_params)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EventData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EventType",
            "IntParams",
            "LongParams",
            "FloatParams",
            "StrParams",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EventType,
            IntParams,
            LongParams,
            FloatParams,
            StrParams,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EventType" => Ok(GeneratedField::EventType),
                            "IntParams" => Ok(GeneratedField::IntParams),
                            "LongParams" => Ok(GeneratedField::LongParams),
                            "FloatParams" => Ok(GeneratedField::FloatParams),
                            "StrParams" => Ok(GeneratedField::StrParams),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EventData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EventData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut event_type__ = None;
                let mut int_params__ = None;
                let mut long_params__ = None;
                let mut float_params__ = None;
                let mut str_params__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EventType => {
                            if event_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EventType"));
                            }
                            event_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IntParams => {
                            if int_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IntParams"));
                            }
                            int_params__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::LongParams => {
                            if long_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LongParams"));
                            }
                            long_params__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::FloatParams => {
                            if float_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FloatParams"));
                            }
                            float_params__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::StrParams => {
                            if str_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StrParams"));
                            }
                            str_params__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventData {
                    event_type: event_type__,
                    int_params: int_params__.unwrap_or_default(),
                    long_params: long_params__.unwrap_or_default(),
                    float_params: float_params__.unwrap_or_default(),
                    str_params: str_params__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EventData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EventDataList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if !self.events.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.EventDataList", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if !self.events.is_empty() {
            struct_ser.serialize_field("Events", &self.events)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EventDataList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "Events",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            Events,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "Events" => Ok(GeneratedField::Events),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EventDataList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.EventDataList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EventDataList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut events__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Events => {
                            if events__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Events"));
                            }
                            events__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(EventDataList {
                    uuid: uuid__,
                    events: events__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.EventDataList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExchangeData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.item_config_id.is_some() {
            len += 1;
        }
        if self.unlock.is_some() {
            len += 1;
        }
        if self.cur_exchange_count.is_some() {
            len += 1;
        }
        if self.expire_time.is_some() {
            len += 1;
        }
        if self.last_refresh_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ExchangeData", len)?;
        if let Some(v) = self.item_config_id.as_ref() {
            struct_ser.serialize_field("ItemConfigId", v)?;
        }
        if let Some(v) = self.unlock.as_ref() {
            struct_ser.serialize_field("Unlock", v)?;
        }
        if let Some(v) = self.cur_exchange_count.as_ref() {
            struct_ser.serialize_field("CurExchangeCount", v)?;
        }
        if let Some(v) = self.expire_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ExpireTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.last_refresh_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastRefreshTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExchangeData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ItemConfigId",
            "Unlock",
            "CurExchangeCount",
            "ExpireTime",
            "LastRefreshTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ItemConfigId,
            Unlock,
            CurExchangeCount,
            ExpireTime,
            LastRefreshTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ItemConfigId" => Ok(GeneratedField::ItemConfigId),
                            "Unlock" => Ok(GeneratedField::Unlock),
                            "CurExchangeCount" => Ok(GeneratedField::CurExchangeCount),
                            "ExpireTime" => Ok(GeneratedField::ExpireTime),
                            "LastRefreshTime" => Ok(GeneratedField::LastRefreshTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExchangeData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ExchangeData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExchangeData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut item_config_id__ = None;
                let mut unlock__ = None;
                let mut cur_exchange_count__ = None;
                let mut expire_time__ = None;
                let mut last_refresh_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ItemConfigId => {
                            if item_config_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ItemConfigId"));
                            }
                            item_config_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Unlock => {
                            if unlock__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Unlock"));
                            }
                            unlock__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurExchangeCount => {
                            if cur_exchange_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurExchangeCount"));
                            }
                            cur_exchange_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExpireTime => {
                            if expire_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExpireTime"));
                            }
                            expire_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastRefreshTime => {
                            if last_refresh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastRefreshTime"));
                            }
                            last_refresh_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ExchangeData {
                    item_config_id: item_config_id__,
                    unlock: unlock__,
                    cur_exchange_count: cur_exchange_count__,
                    expire_time: expire_time__,
                    last_refresh_time: last_refresh_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ExchangeData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExchangeInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if !self.exchange_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ExchangeInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if !self.exchange_data.is_empty() {
            struct_ser.serialize_field("ExchangeData", &self.exchange_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExchangeInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "ExchangeData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            ExchangeData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "ExchangeData" => Ok(GeneratedField::ExchangeData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExchangeInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ExchangeInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExchangeInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut exchange_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExchangeData => {
                            if exchange_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExchangeData"));
                            }
                            exchange_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ExchangeInfo {
                    id: id__,
                    exchange_data: exchange_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ExchangeInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExchangeItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.exchange_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ExchangeItem", len)?;
        if !self.exchange_info.is_empty() {
            struct_ser.serialize_field("ExchangeInfo", &self.exchange_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExchangeItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ExchangeInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ExchangeInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ExchangeInfo" => Ok(GeneratedField::ExchangeInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExchangeItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ExchangeItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExchangeItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut exchange_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ExchangeInfo => {
                            if exchange_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExchangeInfo"));
                            }
                            exchange_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ExchangeItem {
                    exchange_info: exchange_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ExchangeItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FaceData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.face_info.is_empty() {
            len += 1;
        }
        if !self.color_info.is_empty() {
            len += 1;
        }
        if self.height.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FaceData", len)?;
        if !self.face_info.is_empty() {
            struct_ser.serialize_field("FaceInfo", &self.face_info)?;
        }
        if !self.color_info.is_empty() {
            struct_ser.serialize_field("ColorInfo", &self.color_info)?;
        }
        if let Some(v) = self.height.as_ref() {
            struct_ser.serialize_field("Height", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FaceData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FaceInfo",
            "ColorInfo",
            "Height",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FaceInfo,
            ColorInfo,
            Height,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FaceInfo" => Ok(GeneratedField::FaceInfo),
                            "ColorInfo" => Ok(GeneratedField::ColorInfo),
                            "Height" => Ok(GeneratedField::Height),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FaceData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FaceData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FaceData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut face_info__ = None;
                let mut color_info__ = None;
                let mut height__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FaceInfo => {
                            if face_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FaceInfo"));
                            }
                            face_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::ColorInfo => {
                            if color_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ColorInfo"));
                            }
                            color_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::Height => {
                            if height__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Height"));
                            }
                            height__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FaceData {
                    face_info: face_info__.unwrap_or_default(),
                    color_info: color_info__.unwrap_or_default(),
                    height: height__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FaceData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FaceDataDb {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.face_info.is_empty() {
            len += 1;
        }
        if !self.color_info.is_empty() {
            len += 1;
        }
        if self.height.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FaceDataDb", len)?;
        if !self.face_info.is_empty() {
            struct_ser.serialize_field("FaceInfo", &self.face_info)?;
        }
        if !self.color_info.is_empty() {
            struct_ser.serialize_field("ColorInfo", &self.color_info)?;
        }
        if let Some(v) = self.height.as_ref() {
            struct_ser.serialize_field("Height", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FaceDataDb {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FaceInfo",
            "ColorInfo",
            "Height",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FaceInfo,
            ColorInfo,
            Height,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FaceInfo" => Ok(GeneratedField::FaceInfo),
                            "ColorInfo" => Ok(GeneratedField::ColorInfo),
                            "Height" => Ok(GeneratedField::Height),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FaceDataDb;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FaceDataDb")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FaceDataDb, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut face_info__ = None;
                let mut color_info__ = None;
                let mut height__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FaceInfo => {
                            if face_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FaceInfo"));
                            }
                            face_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::ColorInfo => {
                            if color_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ColorInfo"));
                            }
                            color_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::Height => {
                            if height__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Height"));
                            }
                            height__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FaceDataDb {
                    face_info: face_info__.unwrap_or_default(),
                    color_info: color_info__.unwrap_or_default(),
                    height: height__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FaceDataDb", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FakeBulletInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if self.bullet_id.is_some() {
            len += 1;
        }
        if self.target_id.is_some() {
            len += 1;
        }
        if self.part_id.is_some() {
            len += 1;
        }
        if self.offset.is_some() {
            len += 1;
        }
        if self.rotate.is_some() {
            len += 1;
        }
        if self.skin_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FakeBulletInfo", len)?;
        if let Some(v) = self.uuid.as_ref() {
            struct_ser.serialize_field("Uuid", v)?;
        }
        if let Some(v) = self.bullet_id.as_ref() {
            struct_ser.serialize_field("BulletId", v)?;
        }
        if let Some(v) = self.target_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.part_id.as_ref() {
            struct_ser.serialize_field("PartId", v)?;
        }
        if let Some(v) = self.offset.as_ref() {
            struct_ser.serialize_field("Offset", v)?;
        }
        if let Some(v) = self.rotate.as_ref() {
            struct_ser.serialize_field("Rotate", v)?;
        }
        if let Some(v) = self.skin_id.as_ref() {
            struct_ser.serialize_field("SkinId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FakeBulletInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "BulletId",
            "TargetId",
            "PartId",
            "Offset",
            "Rotate",
            "SkinId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            BulletId,
            TargetId,
            PartId,
            Offset,
            Rotate,
            SkinId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "BulletId" => Ok(GeneratedField::BulletId),
                            "TargetId" => Ok(GeneratedField::TargetId),
                            "PartId" => Ok(GeneratedField::PartId),
                            "Offset" => Ok(GeneratedField::Offset),
                            "Rotate" => Ok(GeneratedField::Rotate),
                            "SkinId" => Ok(GeneratedField::SkinId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FakeBulletInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FakeBulletInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FakeBulletInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut bullet_id__ = None;
                let mut target_id__ = None;
                let mut part_id__ = None;
                let mut offset__ = None;
                let mut rotate__ = None;
                let mut skin_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BulletId => {
                            if bullet_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BulletId"));
                            }
                            bullet_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetId => {
                            if target_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetId"));
                            }
                            target_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PartId => {
                            if part_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartId"));
                            }
                            part_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Offset => {
                            if offset__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Offset"));
                            }
                            offset__ = map_.next_value()?;
                        }
                        GeneratedField::Rotate => {
                            if rotate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Rotate"));
                            }
                            rotate__ = map_.next_value()?;
                        }
                        GeneratedField::SkinId => {
                            if skin_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkinId"));
                            }
                            skin_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FakeBulletInfo {
                    uuid: uuid__,
                    bullet_id: bullet_id__,
                    target_id: target_id__,
                    part_id: part_id__,
                    offset: offset__,
                    rotate: rotate__,
                    skin_id: skin_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FakeBulletInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FashionAdvanceInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.fashion_id.is_some() {
            len += 1;
        }
        if self.using_advance_id.is_some() {
            len += 1;
        }
        if !self.advance_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FashionAdvanceInfo", len)?;
        if let Some(v) = self.fashion_id.as_ref() {
            struct_ser.serialize_field("FashionId", v)?;
        }
        if let Some(v) = self.using_advance_id.as_ref() {
            struct_ser.serialize_field("UsingAdvanceId", v)?;
        }
        if !self.advance_ids.is_empty() {
            struct_ser.serialize_field("AdvanceIds", &self.advance_ids)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FashionAdvanceInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FashionId",
            "UsingAdvanceId",
            "AdvanceIds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FashionId,
            UsingAdvanceId,
            AdvanceIds,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FashionId" => Ok(GeneratedField::FashionId),
                            "UsingAdvanceId" => Ok(GeneratedField::UsingAdvanceId),
                            "AdvanceIds" => Ok(GeneratedField::AdvanceIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FashionAdvanceInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FashionAdvanceInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FashionAdvanceInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fashion_id__ = None;
                let mut using_advance_id__ = None;
                let mut advance_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FashionId => {
                            if fashion_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionId"));
                            }
                            fashion_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::UsingAdvanceId => {
                            if using_advance_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UsingAdvanceId"));
                            }
                            using_advance_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AdvanceIds => {
                            if advance_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AdvanceIds"));
                            }
                            advance_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(FashionAdvanceInfo {
                    fashion_id: fashion_id__,
                    using_advance_id: using_advance_id__,
                    advance_ids: advance_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FashionAdvanceInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FashionBenefit {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.last_reward_id.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        if self.points_task.is_some() {
            len += 1;
        }
        if self.points_cycle.is_some() {
            len += 1;
        }
        if self.points_collection.is_some() {
            len += 1;
        }
        if !self.task_list.is_empty() {
            len += 1;
        }
        if !self.collection_history.is_empty() {
            len += 1;
        }
        if self.next_refresh_time.is_some() {
            len += 1;
        }
        if self.max_points.is_some() {
            len += 1;
        }
        if self.last_add_time.is_some() {
            len += 1;
        }
        if self.cur_day_max_points.is_some() {
            len += 1;
        }
        if self.expire_cycle.is_some() {
            len += 1;
        }
        if self.last_level.is_some() {
            len += 1;
        }
        if self.firt_expire_time.is_some() {
            len += 1;
        }
        if !self.last_reward_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FashionBenefit", len)?;
        if let Some(v) = self.last_reward_id.as_ref() {
            struct_ser.serialize_field("LastRewardId", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if let Some(v) = self.points_task.as_ref() {
            struct_ser.serialize_field("PointsTask", v)?;
        }
        if let Some(v) = self.points_cycle.as_ref() {
            struct_ser.serialize_field("PointsCycle", v)?;
        }
        if let Some(v) = self.points_collection.as_ref() {
            struct_ser.serialize_field("PointsCollection", v)?;
        }
        if !self.task_list.is_empty() {
            struct_ser.serialize_field("TaskList", &self.task_list)?;
        }
        if !self.collection_history.is_empty() {
            struct_ser.serialize_field("CollectionHistory", &self.collection_history)?;
        }
        if let Some(v) = self.next_refresh_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("NextRefreshTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.max_points.as_ref() {
            struct_ser.serialize_field("MaxPoints", v)?;
        }
        if let Some(v) = self.last_add_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastAddTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.cur_day_max_points.as_ref() {
            struct_ser.serialize_field("CurDayMaxPoints", v)?;
        }
        if let Some(v) = self.expire_cycle.as_ref() {
            struct_ser.serialize_field("ExpireCycle", v)?;
        }
        if let Some(v) = self.last_level.as_ref() {
            struct_ser.serialize_field("LastLevel", v)?;
        }
        if let Some(v) = self.firt_expire_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("FirtExpireTime", ToString::to_string(&v).as_str())?;
        }
        if !self.last_reward_ids.is_empty() {
            struct_ser.serialize_field("LastRewardIds", &self.last_reward_ids)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FashionBenefit {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LastRewardId",
            "Level",
            "PointsTask",
            "PointsCycle",
            "PointsCollection",
            "TaskList",
            "CollectionHistory",
            "NextRefreshTime",
            "MaxPoints",
            "LastAddTime",
            "CurDayMaxPoints",
            "ExpireCycle",
            "LastLevel",
            "FirtExpireTime",
            "LastRewardIds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LastRewardId,
            Level,
            PointsTask,
            PointsCycle,
            PointsCollection,
            TaskList,
            CollectionHistory,
            NextRefreshTime,
            MaxPoints,
            LastAddTime,
            CurDayMaxPoints,
            ExpireCycle,
            LastLevel,
            FirtExpireTime,
            LastRewardIds,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LastRewardId" => Ok(GeneratedField::LastRewardId),
                            "Level" => Ok(GeneratedField::Level),
                            "PointsTask" => Ok(GeneratedField::PointsTask),
                            "PointsCycle" => Ok(GeneratedField::PointsCycle),
                            "PointsCollection" => Ok(GeneratedField::PointsCollection),
                            "TaskList" => Ok(GeneratedField::TaskList),
                            "CollectionHistory" => Ok(GeneratedField::CollectionHistory),
                            "NextRefreshTime" => Ok(GeneratedField::NextRefreshTime),
                            "MaxPoints" => Ok(GeneratedField::MaxPoints),
                            "LastAddTime" => Ok(GeneratedField::LastAddTime),
                            "CurDayMaxPoints" => Ok(GeneratedField::CurDayMaxPoints),
                            "ExpireCycle" => Ok(GeneratedField::ExpireCycle),
                            "LastLevel" => Ok(GeneratedField::LastLevel),
                            "FirtExpireTime" => Ok(GeneratedField::FirtExpireTime),
                            "LastRewardIds" => Ok(GeneratedField::LastRewardIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FashionBenefit;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FashionBenefit")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FashionBenefit, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut last_reward_id__ = None;
                let mut level__ = None;
                let mut points_task__ = None;
                let mut points_cycle__ = None;
                let mut points_collection__ = None;
                let mut task_list__ = None;
                let mut collection_history__ = None;
                let mut next_refresh_time__ = None;
                let mut max_points__ = None;
                let mut last_add_time__ = None;
                let mut cur_day_max_points__ = None;
                let mut expire_cycle__ = None;
                let mut last_level__ = None;
                let mut firt_expire_time__ = None;
                let mut last_reward_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LastRewardId => {
                            if last_reward_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastRewardId"));
                            }
                            last_reward_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PointsTask => {
                            if points_task__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PointsTask"));
                            }
                            points_task__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PointsCycle => {
                            if points_cycle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PointsCycle"));
                            }
                            points_cycle__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PointsCollection => {
                            if points_collection__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PointsCollection"));
                            }
                            points_collection__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TaskList => {
                            if task_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TaskList"));
                            }
                            task_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::CollectionHistory => {
                            if collection_history__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CollectionHistory"));
                            }
                            collection_history__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NextRefreshTime => {
                            if next_refresh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NextRefreshTime"));
                            }
                            next_refresh_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxPoints => {
                            if max_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaxPoints"));
                            }
                            max_points__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastAddTime => {
                            if last_add_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastAddTime"));
                            }
                            last_add_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurDayMaxPoints => {
                            if cur_day_max_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurDayMaxPoints"));
                            }
                            cur_day_max_points__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExpireCycle => {
                            if expire_cycle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExpireCycle"));
                            }
                            expire_cycle__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastLevel => {
                            if last_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastLevel"));
                            }
                            last_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FirtExpireTime => {
                            if firt_expire_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FirtExpireTime"));
                            }
                            firt_expire_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastRewardIds => {
                            if last_reward_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastRewardIds"));
                            }
                            last_reward_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(FashionBenefit {
                    last_reward_id: last_reward_id__,
                    level: level__,
                    points_task: points_task__,
                    points_cycle: points_cycle__,
                    points_collection: points_collection__,
                    task_list: task_list__.unwrap_or_default(),
                    collection_history: collection_history__.unwrap_or_default(),
                    next_refresh_time: next_refresh_time__,
                    max_points: max_points__,
                    last_add_time: last_add_time__,
                    cur_day_max_points: cur_day_max_points__,
                    expire_cycle: expire_cycle__,
                    last_level: last_level__,
                    firt_expire_time: firt_expire_time__,
                    last_reward_ids: last_reward_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FashionBenefit", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FashionBenefitCollectionHistory {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.fashion_id.is_some() {
            len += 1;
        }
        if self.time.is_some() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        if self.parameter.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FashionBenefitCollectionHistory", len)?;
        if let Some(v) = self.fashion_id.as_ref() {
            struct_ser.serialize_field("FashionId", v)?;
        }
        if let Some(v) = self.time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Time", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("Type", v)?;
        }
        if let Some(v) = self.parameter.as_ref() {
            struct_ser.serialize_field("Parameter", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FashionBenefitCollectionHistory {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FashionId",
            "Time",
            "Type",
            "Parameter",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FashionId,
            Time,
            Type,
            Parameter,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FashionId" => Ok(GeneratedField::FashionId),
                            "Time" => Ok(GeneratedField::Time),
                            "Type" => Ok(GeneratedField::Type),
                            "Parameter" => Ok(GeneratedField::Parameter),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FashionBenefitCollectionHistory;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FashionBenefitCollectionHistory")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FashionBenefitCollectionHistory, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fashion_id__ = None;
                let mut time__ = None;
                let mut r#type__ = None;
                let mut parameter__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FashionId => {
                            if fashion_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionId"));
                            }
                            fashion_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Time"));
                            }
                            time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Parameter => {
                            if parameter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Parameter"));
                            }
                            parameter__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FashionBenefitCollectionHistory {
                    fashion_id: fashion_id__,
                    time: time__,
                    r#type: r#type__,
                    parameter: parameter__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FashionBenefitCollectionHistory", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FashionBenefitTaskInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.count.is_some() {
            len += 1;
        }
        if self.progress.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FashionBenefitTaskInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.count.as_ref() {
            struct_ser.serialize_field("Count", v)?;
        }
        if let Some(v) = self.progress.as_ref() {
            struct_ser.serialize_field("Progress", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FashionBenefitTaskInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Count",
            "Progress",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Count,
            Progress,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Count" => Ok(GeneratedField::Count),
                            "Progress" => Ok(GeneratedField::Progress),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FashionBenefitTaskInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FashionBenefitTaskInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FashionBenefitTaskInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut count__ = None;
                let mut progress__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Count"));
                            }
                            count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Progress => {
                            if progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Progress"));
                            }
                            progress__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FashionBenefitTaskInfo {
                    id: id__,
                    count: count__,
                    progress: progress__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FashionBenefitTaskInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FashionColorInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if !self.colors.is_empty() {
            len += 1;
        }
        if !self.attachment_color.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FashionColorInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if !self.colors.is_empty() {
            struct_ser.serialize_field("Colors", &self.colors)?;
        }
        if !self.attachment_color.is_empty() {
            struct_ser.serialize_field("AttachmentColor", &self.attachment_color)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FashionColorInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Colors",
            "AttachmentColor",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Colors,
            AttachmentColor,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Colors" => Ok(GeneratedField::Colors),
                            "AttachmentColor" => Ok(GeneratedField::AttachmentColor),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FashionColorInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FashionColorInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FashionColorInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut colors__ = None;
                let mut attachment_color__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Colors => {
                            if colors__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Colors"));
                            }
                            colors__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::AttachmentColor => {
                            if attachment_color__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AttachmentColor"));
                            }
                            attachment_color__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(FashionColorInfo {
                    id: id__,
                    colors: colors__.unwrap_or_default(),
                    attachment_color: attachment_color__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FashionColorInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FashionData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.fashion_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FashionData", len)?;
        if !self.fashion_infos.is_empty() {
            struct_ser.serialize_field("FashionInfos", &self.fashion_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FashionData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FashionInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FashionInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FashionInfos" => Ok(GeneratedField::FashionInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FashionData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FashionData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FashionData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fashion_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FashionInfos => {
                            if fashion_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionInfos"));
                            }
                            fashion_infos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(FashionData {
                    fashion_infos: fashion_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FashionData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FashionInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.slot.is_some() {
            len += 1;
        }
        if self.fashion_id.is_some() {
            len += 1;
        }
        if self.colors.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FashionInfo", len)?;
        if let Some(v) = self.slot.as_ref() {
            struct_ser.serialize_field("Slot", v)?;
        }
        if let Some(v) = self.fashion_id.as_ref() {
            struct_ser.serialize_field("FashionId", v)?;
        }
        if let Some(v) = self.colors.as_ref() {
            struct_ser.serialize_field("Colors", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FashionInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Slot",
            "FashionId",
            "Colors",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Slot,
            FashionId,
            Colors,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Slot" => Ok(GeneratedField::Slot),
                            "FashionId" => Ok(GeneratedField::FashionId),
                            "Colors" => Ok(GeneratedField::Colors),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FashionInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FashionInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FashionInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut slot__ = None;
                let mut fashion_id__ = None;
                let mut colors__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Slot => {
                            if slot__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Slot"));
                            }
                            slot__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FashionId => {
                            if fashion_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionId"));
                            }
                            fashion_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Colors => {
                            if colors__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Colors"));
                            }
                            colors__ = map_.next_value()?;
                        }
                    }
                }
                Ok(FashionInfo {
                    slot: slot__,
                    fashion_id: fashion_id__,
                    colors: colors__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FashionInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FashionMgr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.wear_info.is_empty() {
            len += 1;
        }
        if !self.fashion_datas.is_empty() {
            len += 1;
        }
        if !self.unlock_color.is_empty() {
            len += 1;
        }
        if !self.fashion_reward.is_empty() {
            len += 1;
        }
        if !self.all_fashion.is_empty() {
            len += 1;
        }
        if !self.all_ride.is_empty() {
            len += 1;
        }
        if !self.all_weapon_skin.is_empty() {
            len += 1;
        }
        if !self.fashion_advance.is_empty() {
            len += 1;
        }
        if self.fashion_collect_point.is_some() {
            len += 1;
        }
        if self.ride_collect_point.is_some() {
            len += 1;
        }
        if self.weapon_skin_collect_point.is_some() {
            len += 1;
        }
        if !self.all_fashion_num.is_empty() {
            len += 1;
        }
        if !self.all_ride_num.is_empty() {
            len += 1;
        }
        if !self.all_weapon_skin_num.is_empty() {
            len += 1;
        }
        if self.is_fashion_init.is_some() {
            len += 1;
        }
        if self.is_ride_init.is_some() {
            len += 1;
        }
        if self.is_weapon_skin_init.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FashionMgr", len)?;
        if !self.wear_info.is_empty() {
            struct_ser.serialize_field("WearInfo", &self.wear_info)?;
        }
        if !self.fashion_datas.is_empty() {
            struct_ser.serialize_field("FashionDatas", &self.fashion_datas)?;
        }
        if !self.unlock_color.is_empty() {
            struct_ser.serialize_field("UnlockColor", &self.unlock_color)?;
        }
        if !self.fashion_reward.is_empty() {
            struct_ser.serialize_field("FashionReward", &self.fashion_reward)?;
        }
        if !self.all_fashion.is_empty() {
            struct_ser.serialize_field("AllFashion", &self.all_fashion)?;
        }
        if !self.all_ride.is_empty() {
            struct_ser.serialize_field("AllRide", &self.all_ride)?;
        }
        if !self.all_weapon_skin.is_empty() {
            struct_ser.serialize_field("AllWeaponSkin", &self.all_weapon_skin)?;
        }
        if !self.fashion_advance.is_empty() {
            struct_ser.serialize_field("FashionAdvance", &self.fashion_advance)?;
        }
        if let Some(v) = self.fashion_collect_point.as_ref() {
            struct_ser.serialize_field("FashionCollectPoint", v)?;
        }
        if let Some(v) = self.ride_collect_point.as_ref() {
            struct_ser.serialize_field("RideCollectPoint", v)?;
        }
        if let Some(v) = self.weapon_skin_collect_point.as_ref() {
            struct_ser.serialize_field("WeaponSkinCollectPoint", v)?;
        }
        if !self.all_fashion_num.is_empty() {
            struct_ser.serialize_field("AllFashionNum", &self.all_fashion_num)?;
        }
        if !self.all_ride_num.is_empty() {
            struct_ser.serialize_field("AllRideNum", &self.all_ride_num)?;
        }
        if !self.all_weapon_skin_num.is_empty() {
            struct_ser.serialize_field("AllWeaponSkinNum", &self.all_weapon_skin_num)?;
        }
        if let Some(v) = self.is_fashion_init.as_ref() {
            struct_ser.serialize_field("IsFashionInit", v)?;
        }
        if let Some(v) = self.is_ride_init.as_ref() {
            struct_ser.serialize_field("IsRideInit", v)?;
        }
        if let Some(v) = self.is_weapon_skin_init.as_ref() {
            struct_ser.serialize_field("IsWeaponSkinInit", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FashionMgr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "WearInfo",
            "FashionDatas",
            "UnlockColor",
            "FashionReward",
            "AllFashion",
            "AllRide",
            "AllWeaponSkin",
            "FashionAdvance",
            "FashionCollectPoint",
            "RideCollectPoint",
            "WeaponSkinCollectPoint",
            "AllFashionNum",
            "AllRideNum",
            "AllWeaponSkinNum",
            "IsFashionInit",
            "IsRideInit",
            "IsWeaponSkinInit",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            WearInfo,
            FashionDatas,
            UnlockColor,
            FashionReward,
            AllFashion,
            AllRide,
            AllWeaponSkin,
            FashionAdvance,
            FashionCollectPoint,
            RideCollectPoint,
            WeaponSkinCollectPoint,
            AllFashionNum,
            AllRideNum,
            AllWeaponSkinNum,
            IsFashionInit,
            IsRideInit,
            IsWeaponSkinInit,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "WearInfo" => Ok(GeneratedField::WearInfo),
                            "FashionDatas" => Ok(GeneratedField::FashionDatas),
                            "UnlockColor" => Ok(GeneratedField::UnlockColor),
                            "FashionReward" => Ok(GeneratedField::FashionReward),
                            "AllFashion" => Ok(GeneratedField::AllFashion),
                            "AllRide" => Ok(GeneratedField::AllRide),
                            "AllWeaponSkin" => Ok(GeneratedField::AllWeaponSkin),
                            "FashionAdvance" => Ok(GeneratedField::FashionAdvance),
                            "FashionCollectPoint" => Ok(GeneratedField::FashionCollectPoint),
                            "RideCollectPoint" => Ok(GeneratedField::RideCollectPoint),
                            "WeaponSkinCollectPoint" => Ok(GeneratedField::WeaponSkinCollectPoint),
                            "AllFashionNum" => Ok(GeneratedField::AllFashionNum),
                            "AllRideNum" => Ok(GeneratedField::AllRideNum),
                            "AllWeaponSkinNum" => Ok(GeneratedField::AllWeaponSkinNum),
                            "IsFashionInit" => Ok(GeneratedField::IsFashionInit),
                            "IsRideInit" => Ok(GeneratedField::IsRideInit),
                            "IsWeaponSkinInit" => Ok(GeneratedField::IsWeaponSkinInit),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FashionMgr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FashionMgr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FashionMgr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut wear_info__ = None;
                let mut fashion_datas__ = None;
                let mut unlock_color__ = None;
                let mut fashion_reward__ = None;
                let mut all_fashion__ = None;
                let mut all_ride__ = None;
                let mut all_weapon_skin__ = None;
                let mut fashion_advance__ = None;
                let mut fashion_collect_point__ = None;
                let mut ride_collect_point__ = None;
                let mut weapon_skin_collect_point__ = None;
                let mut all_fashion_num__ = None;
                let mut all_ride_num__ = None;
                let mut all_weapon_skin_num__ = None;
                let mut is_fashion_init__ = None;
                let mut is_ride_init__ = None;
                let mut is_weapon_skin_init__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::WearInfo => {
                            if wear_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WearInfo"));
                            }
                            wear_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::FashionDatas => {
                            if fashion_datas__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionDatas"));
                            }
                            fashion_datas__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::UnlockColor => {
                            if unlock_color__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockColor"));
                            }
                            unlock_color__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::FashionReward => {
                            if fashion_reward__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionReward"));
                            }
                            fashion_reward__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::AllFashion => {
                            if all_fashion__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AllFashion"));
                            }
                            all_fashion__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::AllRide => {
                            if all_ride__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AllRide"));
                            }
                            all_ride__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::AllWeaponSkin => {
                            if all_weapon_skin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AllWeaponSkin"));
                            }
                            all_weapon_skin__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::FashionAdvance => {
                            if fashion_advance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionAdvance"));
                            }
                            fashion_advance__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::FashionCollectPoint => {
                            if fashion_collect_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionCollectPoint"));
                            }
                            fashion_collect_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RideCollectPoint => {
                            if ride_collect_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RideCollectPoint"));
                            }
                            ride_collect_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WeaponSkinCollectPoint => {
                            if weapon_skin_collect_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WeaponSkinCollectPoint"));
                            }
                            weapon_skin_collect_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AllFashionNum => {
                            if all_fashion_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AllFashionNum"));
                            }
                            all_fashion_num__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::AllRideNum => {
                            if all_ride_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AllRideNum"));
                            }
                            all_ride_num__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::AllWeaponSkinNum => {
                            if all_weapon_skin_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AllWeaponSkinNum"));
                            }
                            all_weapon_skin_num__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::IsFashionInit => {
                            if is_fashion_init__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsFashionInit"));
                            }
                            is_fashion_init__ = map_.next_value()?;
                        }
                        GeneratedField::IsRideInit => {
                            if is_ride_init__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsRideInit"));
                            }
                            is_ride_init__ = map_.next_value()?;
                        }
                        GeneratedField::IsWeaponSkinInit => {
                            if is_weapon_skin_init__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsWeaponSkinInit"));
                            }
                            is_weapon_skin_init__ = map_.next_value()?;
                        }
                    }
                }
                Ok(FashionMgr {
                    wear_info: wear_info__.unwrap_or_default(),
                    fashion_datas: fashion_datas__.unwrap_or_default(),
                    unlock_color: unlock_color__.unwrap_or_default(),
                    fashion_reward: fashion_reward__.unwrap_or_default(),
                    all_fashion: all_fashion__.unwrap_or_default(),
                    all_ride: all_ride__.unwrap_or_default(),
                    all_weapon_skin: all_weapon_skin__.unwrap_or_default(),
                    fashion_advance: fashion_advance__.unwrap_or_default(),
                    fashion_collect_point: fashion_collect_point__,
                    ride_collect_point: ride_collect_point__,
                    weapon_skin_collect_point: weapon_skin_collect_point__,
                    all_fashion_num: all_fashion_num__.unwrap_or_default(),
                    all_ride_num: all_ride_num__.unwrap_or_default(),
                    all_weapon_skin_num: all_weapon_skin_num__.unwrap_or_default(),
                    is_fashion_init: is_fashion_init__,
                    is_ride_init: is_ride_init__,
                    is_weapon_skin_init: is_weapon_skin_init__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FashionMgr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FashionQualityCollectInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.quality_count.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FashionQualityCollectInfo", len)?;
        if !self.quality_count.is_empty() {
            struct_ser.serialize_field("QualityCount", &self.quality_count)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FashionQualityCollectInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "QualityCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            QualityCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "QualityCount" => Ok(GeneratedField::QualityCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FashionQualityCollectInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FashionQualityCollectInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FashionQualityCollectInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut quality_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::QualityCount => {
                            if quality_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("QualityCount"));
                            }
                            quality_count__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(FashionQualityCollectInfo {
                    quality_count: quality_count__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FashionQualityCollectInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FightPoint {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.total_fight_point.is_some() {
            len += 1;
        }
        if !self.fight_point_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FightPoint", len)?;
        if let Some(v) = self.total_fight_point.as_ref() {
            struct_ser.serialize_field("TotalFightPoint", v)?;
        }
        if !self.fight_point_data.is_empty() {
            struct_ser.serialize_field("FightPointData", &self.fight_point_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FightPoint {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TotalFightPoint",
            "FightPointData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TotalFightPoint,
            FightPointData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TotalFightPoint" => Ok(GeneratedField::TotalFightPoint),
                            "FightPointData" => Ok(GeneratedField::FightPointData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FightPoint;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FightPoint")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FightPoint, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut total_fight_point__ = None;
                let mut fight_point_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TotalFightPoint => {
                            if total_fight_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TotalFightPoint"));
                            }
                            total_fight_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FightPointData => {
                            if fight_point_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FightPointData"));
                            }
                            fight_point_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(FightPoint {
                    total_fight_point: total_fight_point__,
                    fight_point_data: fight_point_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FightPoint", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FightPointData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.function_type.is_some() {
            len += 1;
        }
        if self.total_point.is_some() {
            len += 1;
        }
        if self.point.is_some() {
            len += 1;
        }
        if !self.sub_function_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FightPointData", len)?;
        if let Some(v) = self.function_type.as_ref() {
            struct_ser.serialize_field("FunctionType", v)?;
        }
        if let Some(v) = self.total_point.as_ref() {
            struct_ser.serialize_field("TotalPoint", v)?;
        }
        if let Some(v) = self.point.as_ref() {
            struct_ser.serialize_field("Point", v)?;
        }
        if !self.sub_function_data.is_empty() {
            struct_ser.serialize_field("SubFunctionData", &self.sub_function_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FightPointData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FunctionType",
            "TotalPoint",
            "Point",
            "SubFunctionData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FunctionType,
            TotalPoint,
            Point,
            SubFunctionData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FunctionType" => Ok(GeneratedField::FunctionType),
                            "TotalPoint" => Ok(GeneratedField::TotalPoint),
                            "Point" => Ok(GeneratedField::Point),
                            "SubFunctionData" => Ok(GeneratedField::SubFunctionData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FightPointData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FightPointData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FightPointData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut function_type__ = None;
                let mut total_point__ = None;
                let mut point__ = None;
                let mut sub_function_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FunctionType => {
                            if function_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FunctionType"));
                            }
                            function_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TotalPoint => {
                            if total_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TotalPoint"));
                            }
                            total_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Point => {
                            if point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Point"));
                            }
                            point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SubFunctionData => {
                            if sub_function_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SubFunctionData"));
                            }
                            sub_function_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(FightPointData {
                    function_type: function_type__,
                    total_point: total_point__,
                    point: point__,
                    sub_function_data: sub_function_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FightPointData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FightPointSubData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.function_type.is_some() {
            len += 1;
        }
        if self.root_function_type.is_some() {
            len += 1;
        }
        if self.point.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FightPointSubData", len)?;
        if let Some(v) = self.function_type.as_ref() {
            struct_ser.serialize_field("FunctionType", v)?;
        }
        if let Some(v) = self.root_function_type.as_ref() {
            struct_ser.serialize_field("RootFunctionType", v)?;
        }
        if let Some(v) = self.point.as_ref() {
            struct_ser.serialize_field("Point", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FightPointSubData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FunctionType",
            "RootFunctionType",
            "Point",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FunctionType,
            RootFunctionType,
            Point,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FunctionType" => Ok(GeneratedField::FunctionType),
                            "RootFunctionType" => Ok(GeneratedField::RootFunctionType),
                            "Point" => Ok(GeneratedField::Point),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FightPointSubData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FightPointSubData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FightPointSubData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut function_type__ = None;
                let mut root_function_type__ = None;
                let mut point__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FunctionType => {
                            if function_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FunctionType"));
                            }
                            function_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RootFunctionType => {
                            if root_function_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RootFunctionType"));
                            }
                            root_function_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Point => {
                            if point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Point"));
                            }
                            point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FightPointSubData {
                    function_type: function_type__,
                    root_function_type: root_function_type__,
                    point: point__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FightPointSubData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FightResCd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.res_id.is_some() {
            len += 1;
        }
        if self.begin_time.is_some() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        if self.valid_cd_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FightResCD", len)?;
        if let Some(v) = self.res_id.as_ref() {
            struct_ser.serialize_field("ResId", v)?;
        }
        if let Some(v) = self.begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("Duration", v)?;
        }
        if let Some(v) = self.valid_cd_time.as_ref() {
            struct_ser.serialize_field("ValidCDTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FightResCd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ResId",
            "BeginTime",
            "Duration",
            "ValidCDTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ResId,
            BeginTime,
            Duration,
            ValidCdTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ResId" => Ok(GeneratedField::ResId),
                            "BeginTime" => Ok(GeneratedField::BeginTime),
                            "Duration" => Ok(GeneratedField::Duration),
                            "ValidCDTime" => Ok(GeneratedField::ValidCdTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FightResCd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FightResCD")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FightResCd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut res_id__ = None;
                let mut begin_time__ = None;
                let mut duration__ = None;
                let mut valid_cd_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ResId => {
                            if res_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ResId"));
                            }
                            res_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BeginTime => {
                            if begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeginTime"));
                            }
                            begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ValidCdTime => {
                            if valid_cd_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ValidCDTime"));
                            }
                            valid_cd_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FightResCd {
                    res_id: res_id__,
                    begin_time: begin_time__,
                    duration: duration__,
                    valid_cd_time: valid_cd_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FightResCD", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FightSourceInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.fight_source_type.is_some() {
            len += 1;
        }
        if self.source_config_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FightSourceInfo", len)?;
        if let Some(v) = self.fight_source_type.as_ref() {
            struct_ser.serialize_field("FightSourceType", v)?;
        }
        if let Some(v) = self.source_config_id.as_ref() {
            struct_ser.serialize_field("SourceConfigId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FightSourceInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FightSourceType",
            "SourceConfigId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FightSourceType,
            SourceConfigId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FightSourceType" => Ok(GeneratedField::FightSourceType),
                            "SourceConfigId" => Ok(GeneratedField::SourceConfigId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FightSourceInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FightSourceInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FightSourceInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fight_source_type__ = None;
                let mut source_config_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FightSourceType => {
                            if fight_source_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FightSourceType"));
                            }
                            fight_source_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SourceConfigId => {
                            if source_config_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SourceConfigId"));
                            }
                            source_config_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FightSourceInfo {
                    fight_source_type: fight_source_type__,
                    source_config_id: source_config_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FightSourceInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FirstPayInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.first_pay_type.is_some() {
            len += 1;
        }
        if self.timestamp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FirstPayInfo", len)?;
        if let Some(v) = self.first_pay_type.as_ref() {
            struct_ser.serialize_field("FirstPayType", v)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Timestamp", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FirstPayInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FirstPayType",
            "Timestamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FirstPayType,
            Timestamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FirstPayType" => Ok(GeneratedField::FirstPayType),
                            "Timestamp" => Ok(GeneratedField::Timestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FirstPayInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FirstPayInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FirstPayInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut first_pay_type__ = None;
                let mut timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FirstPayType => {
                            if first_pay_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FirstPayType"));
                            }
                            first_pay_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Timestamp"));
                            }
                            timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FirstPayInfo {
                    first_pay_type: first_pay_type__,
                    timestamp: timestamp__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FirstPayInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FishRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.fish_id.is_some() {
            len += 1;
        }
        if self.first_flag.is_some() {
            len += 1;
        }
        if self.size.is_some() {
            len += 1;
        }
        if self.millisecond.is_some() {
            len += 1;
        }
        if self.research.is_some() {
            len += 1;
        }
        if self.count.is_some() {
            len += 1;
        }
        if self.min_size.is_some() {
            len += 1;
        }
        if self.min_sizemillisecond.is_some() {
            len += 1;
        }
        if !self.star_cnts.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FishRecord", len)?;
        if let Some(v) = self.fish_id.as_ref() {
            struct_ser.serialize_field("FishId", v)?;
        }
        if let Some(v) = self.first_flag.as_ref() {
            struct_ser.serialize_field("FirstFlag", v)?;
        }
        if let Some(v) = self.size.as_ref() {
            struct_ser.serialize_field("Size", v)?;
        }
        if let Some(v) = self.millisecond.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Millisecond", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.research.as_ref() {
            struct_ser.serialize_field("Research", v)?;
        }
        if let Some(v) = self.count.as_ref() {
            struct_ser.serialize_field("Count", v)?;
        }
        if let Some(v) = self.min_size.as_ref() {
            struct_ser.serialize_field("MinSize", v)?;
        }
        if let Some(v) = self.min_sizemillisecond.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("MinSizemillisecond", ToString::to_string(&v).as_str())?;
        }
        if !self.star_cnts.is_empty() {
            let v: std::collections::HashMap<_, _> = self.star_cnts.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("StarCnts", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FishRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FishId",
            "FirstFlag",
            "Size",
            "Millisecond",
            "Research",
            "Count",
            "MinSize",
            "MinSizemillisecond",
            "StarCnts",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FishId,
            FirstFlag,
            Size,
            Millisecond,
            Research,
            Count,
            MinSize,
            MinSizemillisecond,
            StarCnts,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FishId" => Ok(GeneratedField::FishId),
                            "FirstFlag" => Ok(GeneratedField::FirstFlag),
                            "Size" => Ok(GeneratedField::Size),
                            "Millisecond" => Ok(GeneratedField::Millisecond),
                            "Research" => Ok(GeneratedField::Research),
                            "Count" => Ok(GeneratedField::Count),
                            "MinSize" => Ok(GeneratedField::MinSize),
                            "MinSizemillisecond" => Ok(GeneratedField::MinSizemillisecond),
                            "StarCnts" => Ok(GeneratedField::StarCnts),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FishRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FishRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FishRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fish_id__ = None;
                let mut first_flag__ = None;
                let mut size__ = None;
                let mut millisecond__ = None;
                let mut research__ = None;
                let mut count__ = None;
                let mut min_size__ = None;
                let mut min_sizemillisecond__ = None;
                let mut star_cnts__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FishId => {
                            if fish_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FishId"));
                            }
                            fish_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FirstFlag => {
                            if first_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FirstFlag"));
                            }
                            first_flag__ = map_.next_value()?;
                        }
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Size"));
                            }
                            size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Millisecond => {
                            if millisecond__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Millisecond"));
                            }
                            millisecond__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Research => {
                            if research__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Research"));
                            }
                            research__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Count"));
                            }
                            count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MinSize => {
                            if min_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MinSize"));
                            }
                            min_size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MinSizemillisecond => {
                            if min_sizemillisecond__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MinSizemillisecond"));
                            }
                            min_sizemillisecond__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StarCnts => {
                            if star_cnts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StarCnts"));
                            }
                            star_cnts__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(FishRecord {
                    fish_id: fish_id__,
                    first_flag: first_flag__,
                    size: size__,
                    millisecond: millisecond__,
                    research: research__,
                    count: count__,
                    min_size: min_size__,
                    min_sizemillisecond: min_sizemillisecond__,
                    star_cnts: star_cnts__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FishRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FishSetting {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.bait_id.is_some() {
            len += 1;
        }
        if self.experiences.is_some() {
            len += 1;
        }
        if self.research_fish_id.is_some() {
            len += 1;
        }
        if !self.fish_records.is_empty() {
            len += 1;
        }
        if !self.fish_rod_durability.is_empty() {
            len += 1;
        }
        if self.rod_uuid.is_some() {
            len += 1;
        }
        if !self.level_reward.is_empty() {
            len += 1;
        }
        if !self.zero_fish_times.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FishSetting", len)?;
        if let Some(v) = self.bait_id.as_ref() {
            struct_ser.serialize_field("BaitId", v)?;
        }
        if let Some(v) = self.experiences.as_ref() {
            struct_ser.serialize_field("Experiences", v)?;
        }
        if let Some(v) = self.research_fish_id.as_ref() {
            struct_ser.serialize_field("ResearchFishId", v)?;
        }
        if !self.fish_records.is_empty() {
            struct_ser.serialize_field("FishRecords", &self.fish_records)?;
        }
        if !self.fish_rod_durability.is_empty() {
            struct_ser.serialize_field("FishRodDurability", &self.fish_rod_durability)?;
        }
        if let Some(v) = self.rod_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RodUuid", ToString::to_string(&v).as_str())?;
        }
        if !self.level_reward.is_empty() {
            struct_ser.serialize_field("LevelReward", &self.level_reward)?;
        }
        if !self.zero_fish_times.is_empty() {
            let v: std::collections::HashMap<_, _> = self.zero_fish_times.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("ZeroFishTimes", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FishSetting {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BaitId",
            "Experiences",
            "ResearchFishId",
            "FishRecords",
            "FishRodDurability",
            "RodUuid",
            "LevelReward",
            "ZeroFishTimes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BaitId,
            Experiences,
            ResearchFishId,
            FishRecords,
            FishRodDurability,
            RodUuid,
            LevelReward,
            ZeroFishTimes,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BaitId" => Ok(GeneratedField::BaitId),
                            "Experiences" => Ok(GeneratedField::Experiences),
                            "ResearchFishId" => Ok(GeneratedField::ResearchFishId),
                            "FishRecords" => Ok(GeneratedField::FishRecords),
                            "FishRodDurability" => Ok(GeneratedField::FishRodDurability),
                            "RodUuid" => Ok(GeneratedField::RodUuid),
                            "LevelReward" => Ok(GeneratedField::LevelReward),
                            "ZeroFishTimes" => Ok(GeneratedField::ZeroFishTimes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FishSetting;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FishSetting")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FishSetting, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bait_id__ = None;
                let mut experiences__ = None;
                let mut research_fish_id__ = None;
                let mut fish_records__ = None;
                let mut fish_rod_durability__ = None;
                let mut rod_uuid__ = None;
                let mut level_reward__ = None;
                let mut zero_fish_times__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BaitId => {
                            if bait_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BaitId"));
                            }
                            bait_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Experiences => {
                            if experiences__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Experiences"));
                            }
                            experiences__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ResearchFishId => {
                            if research_fish_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ResearchFishId"));
                            }
                            research_fish_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FishRecords => {
                            if fish_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FishRecords"));
                            }
                            fish_records__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::FishRodDurability => {
                            if fish_rod_durability__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FishRodDurability"));
                            }
                            fish_rod_durability__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u64>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::RodUuid => {
                            if rod_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RodUuid"));
                            }
                            rod_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LevelReward => {
                            if level_reward__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LevelReward"));
                            }
                            level_reward__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::ZeroFishTimes => {
                            if zero_fish_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ZeroFishTimes"));
                            }
                            zero_fish_times__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(FishSetting {
                    bait_id: bait_id__,
                    experiences: experiences__,
                    research_fish_id: research_fish_id__,
                    fish_records: fish_records__.unwrap_or_default(),
                    fish_rod_durability: fish_rod_durability__.unwrap_or_default(),
                    rod_uuid: rod_uuid__,
                    level_reward: level_reward__.unwrap_or_default(),
                    zero_fish_times: zero_fish_times__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FishSetting", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FishSocialData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.fish_records.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FishSocialData", len)?;
        if !self.fish_records.is_empty() {
            struct_ser.serialize_field("FishRecords", &self.fish_records)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FishSocialData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FishRecords",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FishRecords,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FishRecords" => Ok(GeneratedField::FishRecords),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FishSocialData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FishSocialData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FishSocialData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fish_records__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FishRecords => {
                            if fish_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FishRecords"));
                            }
                            fish_records__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(FishSocialData {
                    fish_records: fish_records__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FishSocialData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FishingData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.rod_id.is_some() {
            len += 1;
        }
        if self.area_id.is_some() {
            len += 1;
        }
        if self.fish_id.is_some() {
            len += 1;
        }
        if self.stage.is_some() {
            len += 1;
        }
        if self.is_get_fish.is_some() {
            len += 1;
        }
        if self.size.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FishingData", len)?;
        if let Some(v) = self.rod_id.as_ref() {
            struct_ser.serialize_field("RodId", v)?;
        }
        if let Some(v) = self.area_id.as_ref() {
            struct_ser.serialize_field("AreaId", v)?;
        }
        if let Some(v) = self.fish_id.as_ref() {
            struct_ser.serialize_field("FishId", v)?;
        }
        if let Some(v) = self.stage.as_ref() {
            struct_ser.serialize_field("Stage", v)?;
        }
        if let Some(v) = self.is_get_fish.as_ref() {
            struct_ser.serialize_field("IsGetFish", v)?;
        }
        if let Some(v) = self.size.as_ref() {
            struct_ser.serialize_field("Size", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FishingData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RodId",
            "AreaId",
            "FishId",
            "Stage",
            "IsGetFish",
            "Size",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RodId,
            AreaId,
            FishId,
            Stage,
            IsGetFish,
            Size,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RodId" => Ok(GeneratedField::RodId),
                            "AreaId" => Ok(GeneratedField::AreaId),
                            "FishId" => Ok(GeneratedField::FishId),
                            "Stage" => Ok(GeneratedField::Stage),
                            "IsGetFish" => Ok(GeneratedField::IsGetFish),
                            "Size" => Ok(GeneratedField::Size),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FishingData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FishingData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FishingData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut rod_id__ = None;
                let mut area_id__ = None;
                let mut fish_id__ = None;
                let mut stage__ = None;
                let mut is_get_fish__ = None;
                let mut size__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RodId => {
                            if rod_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RodId"));
                            }
                            rod_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AreaId => {
                            if area_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AreaId"));
                            }
                            area_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FishId => {
                            if fish_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FishId"));
                            }
                            fish_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Stage => {
                            if stage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Stage"));
                            }
                            stage__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsGetFish => {
                            if is_get_fish__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsGetFish"));
                            }
                            is_get_fish__ = map_.next_value()?;
                        }
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Size"));
                            }
                            size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FishingData {
                    rod_id: rod_id__,
                    area_id: area_id__,
                    fish_id: fish_id__,
                    stage: stage__,
                    is_get_fish: is_get_fish__,
                    size: size__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FishingData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FishingSetStage {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FishingSetStage", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FishingSetStage {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FishingSetStage;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FishingSetStage")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FishingSetStage, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(FishingSetStage {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FishingSetStage", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FishingSetStageRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.stage.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FishingSetStageRequest", len)?;
        if let Some(v) = self.stage.as_ref() {
            struct_ser.serialize_field("Stage", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FishingSetStageRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Stage",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Stage,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Stage" => Ok(GeneratedField::Stage),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FishingSetStageRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FishingSetStageRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FishingSetStageRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut stage__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Stage => {
                            if stage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Stage"));
                            }
                            stage__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FishingSetStageRequest {
                    stage: stage__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FishingSetStageRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FlowPlayEnd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_flow_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FlowPlayEnd", len)?;
        if let Some(v) = self.v_flow_id.as_ref() {
            struct_ser.serialize_field("VFlowId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FlowPlayEnd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VFlowId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VFlowId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VFlowId" => Ok(GeneratedField::VFlowId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FlowPlayEnd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FlowPlayEnd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FlowPlayEnd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_flow_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VFlowId => {
                            if v_flow_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VFlowId"));
                            }
                            v_flow_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FlowPlayEnd {
                    v_flow_id: v_flow_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FlowPlayEnd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ForcedPullBack {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cur_pos.is_some() {
            len += 1;
        }
        if self.force.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ForcedPullBack", len)?;
        if let Some(v) = self.cur_pos.as_ref() {
            struct_ser.serialize_field("CurPos", v)?;
        }
        if let Some(v) = self.force.as_ref() {
            struct_ser.serialize_field("Force", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ForcedPullBack {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CurPos",
            "Force",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CurPos,
            Force,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CurPos" => Ok(GeneratedField::CurPos),
                            "Force" => Ok(GeneratedField::Force),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ForcedPullBack;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ForcedPullBack")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ForcedPullBack, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cur_pos__ = None;
                let mut force__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CurPos => {
                            if cur_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurPos"));
                            }
                            cur_pos__ = map_.next_value()?;
                        }
                        GeneratedField::Force => {
                            if force__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Force"));
                            }
                            force__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ForcedPullBack {
                    cur_pos: cur_pos__,
                    force: force__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ForcedPullBack", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FreightData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.refresh_time.is_some() {
            len += 1;
        }
        if self.goods_value.is_some() {
            len += 1;
        }
        if self.set_off.is_some() {
            len += 1;
        }
        if self.can_receive.is_some() {
            len += 1;
        }
        if !self.up_goods_list.is_empty() {
            len += 1;
        }
        if !self.keep_goods_list.is_empty() {
            len += 1;
        }
        if !self.down_goods_list.is_empty() {
            len += 1;
        }
        if self.can_reward_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FreightData", len)?;
        if let Some(v) = self.refresh_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RefreshTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.goods_value.as_ref() {
            struct_ser.serialize_field("GoodsValue", v)?;
        }
        if let Some(v) = self.set_off.as_ref() {
            struct_ser.serialize_field("SetOff", v)?;
        }
        if let Some(v) = self.can_receive.as_ref() {
            struct_ser.serialize_field("CanReceive", v)?;
        }
        if !self.up_goods_list.is_empty() {
            struct_ser.serialize_field("UpGoodsList", &self.up_goods_list)?;
        }
        if !self.keep_goods_list.is_empty() {
            struct_ser.serialize_field("KeepGoodsList", &self.keep_goods_list)?;
        }
        if !self.down_goods_list.is_empty() {
            struct_ser.serialize_field("DownGoodsList", &self.down_goods_list)?;
        }
        if let Some(v) = self.can_reward_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CanRewardTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FreightData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RefreshTime",
            "GoodsValue",
            "SetOff",
            "CanReceive",
            "UpGoodsList",
            "KeepGoodsList",
            "DownGoodsList",
            "CanRewardTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RefreshTime,
            GoodsValue,
            SetOff,
            CanReceive,
            UpGoodsList,
            KeepGoodsList,
            DownGoodsList,
            CanRewardTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RefreshTime" => Ok(GeneratedField::RefreshTime),
                            "GoodsValue" => Ok(GeneratedField::GoodsValue),
                            "SetOff" => Ok(GeneratedField::SetOff),
                            "CanReceive" => Ok(GeneratedField::CanReceive),
                            "UpGoodsList" => Ok(GeneratedField::UpGoodsList),
                            "KeepGoodsList" => Ok(GeneratedField::KeepGoodsList),
                            "DownGoodsList" => Ok(GeneratedField::DownGoodsList),
                            "CanRewardTime" => Ok(GeneratedField::CanRewardTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FreightData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FreightData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FreightData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut refresh_time__ = None;
                let mut goods_value__ = None;
                let mut set_off__ = None;
                let mut can_receive__ = None;
                let mut up_goods_list__ = None;
                let mut keep_goods_list__ = None;
                let mut down_goods_list__ = None;
                let mut can_reward_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RefreshTime => {
                            if refresh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshTime"));
                            }
                            refresh_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GoodsValue => {
                            if goods_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GoodsValue"));
                            }
                            goods_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SetOff => {
                            if set_off__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SetOff"));
                            }
                            set_off__ = map_.next_value()?;
                        }
                        GeneratedField::CanReceive => {
                            if can_receive__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CanReceive"));
                            }
                            can_receive__ = map_.next_value()?;
                        }
                        GeneratedField::UpGoodsList => {
                            if up_goods_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UpGoodsList"));
                            }
                            up_goods_list__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::KeepGoodsList => {
                            if keep_goods_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("KeepGoodsList"));
                            }
                            keep_goods_list__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::DownGoodsList => {
                            if down_goods_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DownGoodsList"));
                            }
                            down_goods_list__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::CanRewardTime => {
                            if can_reward_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CanRewardTime"));
                            }
                            can_reward_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FreightData {
                    refresh_time: refresh_time__,
                    goods_value: goods_value__,
                    set_off: set_off__,
                    can_receive: can_receive__,
                    up_goods_list: up_goods_list__.unwrap_or_default(),
                    keep_goods_list: keep_goods_list__.unwrap_or_default(),
                    down_goods_list: down_goods_list__.unwrap_or_default(),
                    can_reward_time: can_reward_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FreightData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FunctionData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.unlocked_map.is_empty() {
            len += 1;
        }
        if !self.drawn_function_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FunctionData", len)?;
        if !self.unlocked_map.is_empty() {
            struct_ser.serialize_field("UnlockedMap", &self.unlocked_map)?;
        }
        if !self.drawn_function_ids.is_empty() {
            struct_ser.serialize_field("DrawnFunctionIds", &self.drawn_function_ids)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FunctionData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UnlockedMap",
            "DrawnFunctionIds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UnlockedMap,
            DrawnFunctionIds,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UnlockedMap" => Ok(GeneratedField::UnlockedMap),
                            "DrawnFunctionIds" => Ok(GeneratedField::DrawnFunctionIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FunctionData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FunctionData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FunctionData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut unlocked_map__ = None;
                let mut drawn_function_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UnlockedMap => {
                            if unlocked_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockedMap"));
                            }
                            unlocked_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::DrawnFunctionIds => {
                            if drawn_function_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DrawnFunctionIds"));
                            }
                            drawn_function_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(FunctionData {
                    unlocked_map: unlocked_map__.unwrap_or_default(),
                    drawn_function_ids: drawn_function_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FunctionData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FunctionTimeData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.times.is_some() {
            len += 1;
        }
        if self.timestamp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.FunctionTimeData", len)?;
        if let Some(v) = self.times.as_ref() {
            struct_ser.serialize_field("Times", v)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            struct_ser.serialize_field("Timestamp", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FunctionTimeData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Times",
            "Timestamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Times,
            Timestamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Times" => Ok(GeneratedField::Times),
                            "Timestamp" => Ok(GeneratedField::Timestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FunctionTimeData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.FunctionTimeData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FunctionTimeData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut times__ = None;
                let mut timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Times => {
                            if times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Times"));
                            }
                            times__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Timestamp"));
                            }
                            timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(FunctionTimeData {
                    times: times__,
                    timestamp: timestamp__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.FunctionTimeData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GmCommand {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cmd.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GMCommand", len)?;
        if let Some(v) = self.cmd.as_ref() {
            struct_ser.serialize_field("Cmd", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GmCommand {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Cmd",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Cmd,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Cmd" => Ok(GeneratedField::Cmd),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GmCommand;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GMCommand")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GmCommand, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cmd__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Cmd => {
                            if cmd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Cmd"));
                            }
                            cmd__ = map_.next_value()?;
                        }
                    }
                }
                Ok(GmCommand {
                    cmd: cmd__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GMCommand", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GameFunctionData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.state.is_some() {
            len += 1;
        }
        if self.product_id.is_some() {
            len += 1;
        }
        if !self.function_times.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GameFunctionData", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.state.as_ref() {
            struct_ser.serialize_field("State", v)?;
        }
        if let Some(v) = self.product_id.as_ref() {
            struct_ser.serialize_field("ProductId", v)?;
        }
        if !self.function_times.is_empty() {
            struct_ser.serialize_field("FunctionTimes", &self.function_times)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GameFunctionData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "State",
            "ProductId",
            "FunctionTimes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            State,
            ProductId,
            FunctionTimes,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "State" => Ok(GeneratedField::State),
                            "ProductId" => Ok(GeneratedField::ProductId),
                            "FunctionTimes" => Ok(GeneratedField::FunctionTimes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GameFunctionData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GameFunctionData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GameFunctionData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut state__ = None;
                let mut product_id__ = None;
                let mut function_times__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("State"));
                            }
                            state__ = map_.next_value()?;
                        }
                        GeneratedField::ProductId => {
                            if product_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProductId"));
                            }
                            product_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FunctionTimes => {
                            if function_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FunctionTimes"));
                            }
                            function_times__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(GameFunctionData {
                    id: id__,
                    state: state__,
                    product_id: product_id__,
                    function_times: function_times__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GameFunctionData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GashaData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.gasha_infos.is_empty() {
            len += 1;
        }
        if !self.gasha_guarantee_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GashaData", len)?;
        if !self.gasha_infos.is_empty() {
            struct_ser.serialize_field("GashaInfos", &self.gasha_infos)?;
        }
        if !self.gasha_guarantee_infos.is_empty() {
            struct_ser.serialize_field("GashaGuaranteeInfos", &self.gasha_guarantee_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GashaData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GashaInfos",
            "GashaGuaranteeInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            GashaInfos,
            GashaGuaranteeInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "GashaInfos" => Ok(GeneratedField::GashaInfos),
                            "GashaGuaranteeInfos" => Ok(GeneratedField::GashaGuaranteeInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GashaData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GashaData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GashaData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut gasha_infos__ = None;
                let mut gasha_guarantee_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::GashaInfos => {
                            if gasha_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GashaInfos"));
                            }
                            gasha_infos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::GashaGuaranteeInfos => {
                            if gasha_guarantee_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GashaGuaranteeInfos"));
                            }
                            gasha_guarantee_infos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(GashaData {
                    gasha_infos: gasha_infos__.unwrap_or_default(),
                    gasha_guarantee_infos: gasha_guarantee_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GashaData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GashaGuaranteeInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.guarantee_x.is_some() {
            len += 1;
        }
        if self.guarantee_y.is_some() {
            len += 1;
        }
        if self.residue_guarantee_time_x.is_some() {
            len += 1;
        }
        if self.residue_guarantee_time_y.is_some() {
            len += 1;
        }
        if self.residue_guarantee_time_z.is_some() {
            len += 1;
        }
        if self.guarantee_z.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GashaGuaranteeInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.guarantee_x.as_ref() {
            struct_ser.serialize_field("GuaranteeX", v)?;
        }
        if let Some(v) = self.guarantee_y.as_ref() {
            struct_ser.serialize_field("GuaranteeY", v)?;
        }
        if let Some(v) = self.residue_guarantee_time_x.as_ref() {
            struct_ser.serialize_field("ResidueGuaranteeTimeX", v)?;
        }
        if let Some(v) = self.residue_guarantee_time_y.as_ref() {
            struct_ser.serialize_field("ResidueGuaranteeTimeY", v)?;
        }
        if let Some(v) = self.residue_guarantee_time_z.as_ref() {
            struct_ser.serialize_field("ResidueGuaranteeTimeZ", v)?;
        }
        if let Some(v) = self.guarantee_z.as_ref() {
            struct_ser.serialize_field("GuaranteeZ", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GashaGuaranteeInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "GuaranteeX",
            "GuaranteeY",
            "ResidueGuaranteeTimeX",
            "ResidueGuaranteeTimeY",
            "ResidueGuaranteeTimeZ",
            "GuaranteeZ",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            GuaranteeX,
            GuaranteeY,
            ResidueGuaranteeTimeX,
            ResidueGuaranteeTimeY,
            ResidueGuaranteeTimeZ,
            GuaranteeZ,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "GuaranteeX" => Ok(GeneratedField::GuaranteeX),
                            "GuaranteeY" => Ok(GeneratedField::GuaranteeY),
                            "ResidueGuaranteeTimeX" => Ok(GeneratedField::ResidueGuaranteeTimeX),
                            "ResidueGuaranteeTimeY" => Ok(GeneratedField::ResidueGuaranteeTimeY),
                            "ResidueGuaranteeTimeZ" => Ok(GeneratedField::ResidueGuaranteeTimeZ),
                            "GuaranteeZ" => Ok(GeneratedField::GuaranteeZ),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GashaGuaranteeInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GashaGuaranteeInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GashaGuaranteeInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut guarantee_x__ = None;
                let mut guarantee_y__ = None;
                let mut residue_guarantee_time_x__ = None;
                let mut residue_guarantee_time_y__ = None;
                let mut residue_guarantee_time_z__ = None;
                let mut guarantee_z__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GuaranteeX => {
                            if guarantee_x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GuaranteeX"));
                            }
                            guarantee_x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GuaranteeY => {
                            if guarantee_y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GuaranteeY"));
                            }
                            guarantee_y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ResidueGuaranteeTimeX => {
                            if residue_guarantee_time_x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ResidueGuaranteeTimeX"));
                            }
                            residue_guarantee_time_x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ResidueGuaranteeTimeY => {
                            if residue_guarantee_time_y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ResidueGuaranteeTimeY"));
                            }
                            residue_guarantee_time_y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ResidueGuaranteeTimeZ => {
                            if residue_guarantee_time_z__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ResidueGuaranteeTimeZ"));
                            }
                            residue_guarantee_time_z__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GuaranteeZ => {
                            if guarantee_z__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GuaranteeZ"));
                            }
                            guarantee_z__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(GashaGuaranteeInfo {
                    id: id__,
                    guarantee_x: guarantee_x__,
                    guarantee_y: guarantee_y__,
                    residue_guarantee_time_x: residue_guarantee_time_x__,
                    residue_guarantee_time_y: residue_guarantee_time_y__,
                    residue_guarantee_time_z: residue_guarantee_time_z__,
                    guarantee_z: guarantee_z__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GashaGuaranteeInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GashaInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.draw_count.is_some() {
            len += 1;
        }
        if self.refresh_time.is_some() {
            len += 1;
        }
        if self.wish_id.is_some() {
            len += 1;
        }
        if self.wish_value.is_some() {
            len += 1;
        }
        if self.wish_finish_count.is_some() {
            len += 1;
        }
        if self.wish_reset_time.is_some() {
            len += 1;
        }
        if self.wish_limit.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GashaInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.draw_count.as_ref() {
            struct_ser.serialize_field("DrawCount", v)?;
        }
        if let Some(v) = self.refresh_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RefreshTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.wish_id.as_ref() {
            struct_ser.serialize_field("WishId", v)?;
        }
        if let Some(v) = self.wish_value.as_ref() {
            struct_ser.serialize_field("WishValue", v)?;
        }
        if let Some(v) = self.wish_finish_count.as_ref() {
            struct_ser.serialize_field("WishFinishCount", v)?;
        }
        if let Some(v) = self.wish_reset_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("WishResetTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.wish_limit.as_ref() {
            struct_ser.serialize_field("WishLimit", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GashaInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "DrawCount",
            "RefreshTime",
            "WishId",
            "WishValue",
            "WishFinishCount",
            "WishResetTime",
            "WishLimit",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            DrawCount,
            RefreshTime,
            WishId,
            WishValue,
            WishFinishCount,
            WishResetTime,
            WishLimit,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "DrawCount" => Ok(GeneratedField::DrawCount),
                            "RefreshTime" => Ok(GeneratedField::RefreshTime),
                            "WishId" => Ok(GeneratedField::WishId),
                            "WishValue" => Ok(GeneratedField::WishValue),
                            "WishFinishCount" => Ok(GeneratedField::WishFinishCount),
                            "WishResetTime" => Ok(GeneratedField::WishResetTime),
                            "WishLimit" => Ok(GeneratedField::WishLimit),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GashaInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GashaInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GashaInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut draw_count__ = None;
                let mut refresh_time__ = None;
                let mut wish_id__ = None;
                let mut wish_value__ = None;
                let mut wish_finish_count__ = None;
                let mut wish_reset_time__ = None;
                let mut wish_limit__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DrawCount => {
                            if draw_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DrawCount"));
                            }
                            draw_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RefreshTime => {
                            if refresh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshTime"));
                            }
                            refresh_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WishId => {
                            if wish_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WishId"));
                            }
                            wish_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WishValue => {
                            if wish_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WishValue"));
                            }
                            wish_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WishFinishCount => {
                            if wish_finish_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WishFinishCount"));
                            }
                            wish_finish_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WishResetTime => {
                            if wish_reset_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WishResetTime"));
                            }
                            wish_reset_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WishLimit => {
                            if wish_limit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WishLimit"));
                            }
                            wish_limit__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(GashaInfo {
                    id: id__,
                    draw_count: draw_count__,
                    refresh_time: refresh_time__,
                    wish_id: wish_id__,
                    wish_value: wish_value__,
                    wish_finish_count: wish_finish_count__,
                    wish_reset_time: wish_reset_time__,
                    wish_limit: wish_limit__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GashaInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetClientOptions {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetClientOptions", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetClientOptions {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetClientOptions;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetClientOptions")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetClientOptions, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(GetClientOptions {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetClientOptions", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetClientOptionsReply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.options.is_empty() {
            len += 1;
        }
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetClientOptionsReply", len)?;
        if !self.options.is_empty() {
            struct_ser.serialize_field("Options", &self.options)?;
        }
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetClientOptionsReply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Options",
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Options,
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Options" => Ok(GeneratedField::Options),
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetClientOptionsReply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetClientOptionsReply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetClientOptionsReply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut options__ = None;
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Options => {
                            if options__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Options"));
                            }
                            options__ = Some(
                                map_.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(GetClientOptionsReply {
                    options: options__.unwrap_or_default(),
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetClientOptionsReply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetClientOptionsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.keys.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetClientOptionsRequest", len)?;
        if !self.keys.is_empty() {
            struct_ser.serialize_field("Keys", &self.keys)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetClientOptionsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Keys",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Keys,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Keys" => Ok(GeneratedField::Keys),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetClientOptionsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetClientOptionsRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetClientOptionsRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut keys__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Keys => {
                            if keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Keys"));
                            }
                            keys__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(GetClientOptionsRequest {
                    keys: keys__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetClientOptionsRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetGitVersion {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetGitVersion", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetGitVersion {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetGitVersion;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetGitVersion")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetGitVersion, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(GetGitVersion {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetGitVersion", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetGitVersionReply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.git_version.is_some() {
            len += 1;
        }
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetGitVersionReply", len)?;
        if let Some(v) = self.git_version.as_ref() {
            struct_ser.serialize_field("GitVersion", v)?;
        }
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetGitVersionReply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "GitVersion",
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            GitVersion,
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "GitVersion" => Ok(GeneratedField::GitVersion),
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetGitVersionReply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetGitVersionReply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetGitVersionReply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut git_version__ = None;
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::GitVersion => {
                            if git_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GitVersion"));
                            }
                            git_version__ = map_.next_value()?;
                        }
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(GetGitVersionReply {
                    git_version: git_version__,
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetGitVersionReply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetGitVersionRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("blueprotobuf_package.GetGitVersionRequest", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetGitVersionRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Err(serde::de::Error::unknown_field(value, FIELDS))
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetGitVersionRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetGitVersionRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetGitVersionRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(GetGitVersionRequest {
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetGitVersionRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetHomelandBuildFurnitureInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetHomelandBuildFurnitureInfo", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetHomelandBuildFurnitureInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetHomelandBuildFurnitureInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetHomelandBuildFurnitureInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetHomelandBuildFurnitureInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(GetHomelandBuildFurnitureInfo {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetHomelandBuildFurnitureInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetHomelandBuildFurnitureInfoReply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.furniture_info.is_empty() {
            len += 1;
        }
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetHomelandBuildFurnitureInfoReply", len)?;
        if !self.furniture_info.is_empty() {
            struct_ser.serialize_field("FurnitureInfo", &self.furniture_info)?;
        }
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetHomelandBuildFurnitureInfoReply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FurnitureInfo",
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FurnitureInfo,
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FurnitureInfo" => Ok(GeneratedField::FurnitureInfo),
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetHomelandBuildFurnitureInfoReply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetHomelandBuildFurnitureInfoReply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetHomelandBuildFurnitureInfoReply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut furniture_info__ = None;
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FurnitureInfo => {
                            if furniture_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FurnitureInfo"));
                            }
                            furniture_info__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(GetHomelandBuildFurnitureInfoReply {
                    furniture_info: furniture_info__.unwrap_or_default(),
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetHomelandBuildFurnitureInfoReply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetHomelandBuildFurnitureInfoRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.build_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetHomelandBuildFurnitureInfoRequest", len)?;
        if let Some(v) = self.build_type.as_ref() {
            struct_ser.serialize_field("BuildType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetHomelandBuildFurnitureInfoRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BuildType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BuildType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BuildType" => Ok(GeneratedField::BuildType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetHomelandBuildFurnitureInfoRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetHomelandBuildFurnitureInfoRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetHomelandBuildFurnitureInfoRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut build_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BuildType => {
                            if build_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuildType"));
                            }
                            build_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(GetHomelandBuildFurnitureInfoRequest {
                    build_type: build_type__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetHomelandBuildFurnitureInfoRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetLuaSceneAttr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_attribute_name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetLuaSceneAttr", len)?;
        if let Some(v) = self.v_attribute_name.as_ref() {
            struct_ser.serialize_field("VAttributeName", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetLuaSceneAttr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VAttributeName",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VAttributeName,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VAttributeName" => Ok(GeneratedField::VAttributeName),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetLuaSceneAttr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetLuaSceneAttr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetLuaSceneAttr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_attribute_name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VAttributeName => {
                            if v_attribute_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VAttributeName"));
                            }
                            v_attribute_name__ = map_.next_value()?;
                        }
                    }
                }
                Ok(GetLuaSceneAttr {
                    v_attribute_name: v_attribute_name__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetLuaSceneAttr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetPath {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetPath", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetPath {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetPath;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetPath")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetPath, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(GetPath {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetPath", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetPathReply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.err_code.is_some() {
            len += 1;
        }
        if self.reply_bytes.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetPathReply", len)?;
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        if let Some(v) = self.reply_bytes.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ReplyBytes", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetPathReply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ErrCode",
            "ReplyBytes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ErrCode,
            ReplyBytes,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            "ReplyBytes" => Ok(GeneratedField::ReplyBytes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetPathReply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetPathReply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetPathReply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut err_code__ = None;
                let mut reply_bytes__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ReplyBytes => {
                            if reply_bytes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReplyBytes"));
                            }
                            reply_bytes__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(GetPathReply {
                    err_code: err_code__,
                    reply_bytes: reply_bytes__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetPathReply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetPathRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.request_bytes.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetPathRequest", len)?;
        if let Some(v) = self.request_bytes.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RequestBytes", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetPathRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RequestBytes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RequestBytes,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RequestBytes" => Ok(GeneratedField::RequestBytes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetPathRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetPathRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetPathRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut request_bytes__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RequestBytes => {
                            if request_bytes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RequestBytes"));
                            }
                            request_bytes__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(GetPathRequest {
                    request_bytes: request_bytes__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetPathRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetSocialData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetSocialData", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetSocialData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetSocialData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetSocialData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetSocialData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(GetSocialData {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetSocialData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetSocialDataReply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.mask.is_some() {
            len += 1;
        }
        if self.data.is_some() {
            len += 1;
        }
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetSocialDataReply", len)?;
        if let Some(v) = self.mask.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Mask", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.data.as_ref() {
            struct_ser.serialize_field("Data", v)?;
        }
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetSocialDataReply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Mask",
            "Data",
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Mask,
            Data,
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Mask" => Ok(GeneratedField::Mask),
                            "Data" => Ok(GeneratedField::Data),
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetSocialDataReply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetSocialDataReply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetSocialDataReply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut mask__ = None;
                let mut data__ = None;
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Mask => {
                            if mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Mask"));
                            }
                            mask__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Data"));
                            }
                            data__ = map_.next_value()?;
                        }
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(GetSocialDataReply {
                    mask: mask__,
                    data: data__,
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetSocialDataReply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetSocialDataRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.char_id.is_some() {
            len += 1;
        }
        if self.mask.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GetSocialDataRequest", len)?;
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.mask.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Mask", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetSocialDataRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CharId",
            "Mask",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CharId,
            Mask,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CharId" => Ok(GeneratedField::CharId),
                            "Mask" => Ok(GeneratedField::Mask),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetSocialDataRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GetSocialDataRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetSocialDataRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut char_id__ = None;
                let mut mask__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Mask => {
                            if mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Mask"));
                            }
                            mask__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(GetSocialDataRequest {
                    char_id: char_id__,
                    mask: mask__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GetSocialDataRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GmCmd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.command.is_some() {
            len += 1;
        }
        if self.target_char_id.is_some() {
            len += 1;
        }
        if self.parsing_type.is_some() {
            len += 1;
        }
        if self.parameter.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GmCmd", len)?;
        if let Some(v) = self.command.as_ref() {
            struct_ser.serialize_field("Command", v)?;
        }
        if let Some(v) = self.target_char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetCharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.parsing_type.as_ref() {
            let v = EGmParsingType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ParsingType", &v)?;
        }
        if let Some(v) = self.parameter.as_ref() {
            struct_ser.serialize_field("Parameter", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GmCmd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Command",
            "TargetCharId",
            "ParsingType",
            "Parameter",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Command,
            TargetCharId,
            ParsingType,
            Parameter,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Command" => Ok(GeneratedField::Command),
                            "TargetCharId" => Ok(GeneratedField::TargetCharId),
                            "ParsingType" => Ok(GeneratedField::ParsingType),
                            "Parameter" => Ok(GeneratedField::Parameter),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GmCmd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GmCmd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GmCmd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut command__ = None;
                let mut target_char_id__ = None;
                let mut parsing_type__ = None;
                let mut parameter__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Command => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Command"));
                            }
                            command__ = map_.next_value()?;
                        }
                        GeneratedField::TargetCharId => {
                            if target_char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetCharId"));
                            }
                            target_char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ParsingType => {
                            if parsing_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ParsingType"));
                            }
                            parsing_type__ = map_.next_value::<::std::option::Option<EGmParsingType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Parameter => {
                            if parameter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Parameter"));
                            }
                            parameter__ = map_.next_value()?;
                        }
                    }
                }
                Ok(GmCmd {
                    command: command__,
                    target_char_id: target_char_id__,
                    parsing_type: parsing_type__,
                    parameter: parameter__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GmCmd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GmResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.success.is_some() {
            len += 1;
        }
        if self.fail_reason.is_some() {
            len += 1;
        }
        if !self.ret_params.is_empty() {
            len += 1;
        }
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.GmResult", len)?;
        if let Some(v) = self.success.as_ref() {
            struct_ser.serialize_field("Success", v)?;
        }
        if let Some(v) = self.fail_reason.as_ref() {
            struct_ser.serialize_field("FailReason", v)?;
        }
        if !self.ret_params.is_empty() {
            struct_ser.serialize_field("RetParams", &self.ret_params)?;
        }
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GmResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Success",
            "FailReason",
            "RetParams",
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Success,
            FailReason,
            RetParams,
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Success" => Ok(GeneratedField::Success),
                            "FailReason" => Ok(GeneratedField::FailReason),
                            "RetParams" => Ok(GeneratedField::RetParams),
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GmResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.GmResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GmResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut success__ = None;
                let mut fail_reason__ = None;
                let mut ret_params__ = None;
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Success => {
                            if success__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Success"));
                            }
                            success__ = map_.next_value()?;
                        }
                        GeneratedField::FailReason => {
                            if fail_reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FailReason"));
                            }
                            fail_reason__ = map_.next_value()?;
                        }
                        GeneratedField::RetParams => {
                            if ret_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RetParams"));
                            }
                            ret_params__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(GmResult {
                    success: success__,
                    fail_reason: fail_reason__,
                    ret_params: ret_params__.unwrap_or_default(),
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.GmResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HandBookStruct {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.unlock.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HandBookStruct", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.unlock.as_ref() {
            struct_ser.serialize_field("Unlock", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HandBookStruct {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Unlock",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Unlock,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Unlock" => Ok(GeneratedField::Unlock),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HandBookStruct;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HandBookStruct")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HandBookStruct, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut unlock__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Unlock => {
                            if unlock__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Unlock"));
                            }
                            unlock__ = map_.next_value()?;
                        }
                    }
                }
                Ok(HandBookStruct {
                    id: id__,
                    unlock: unlock__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HandBookStruct", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HandbookData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.unlock_note_important_role_map.is_empty() {
            len += 1;
        }
        if !self.unlock_note_reading_book_map.is_empty() {
            len += 1;
        }
        if !self.unlock_note_dictionary_map.is_empty() {
            len += 1;
        }
        if !self.unlock_note_post_card_map.is_empty() {
            len += 1;
        }
        if !self.unlock_note_month_card_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HandbookData", len)?;
        if !self.unlock_note_important_role_map.is_empty() {
            struct_ser.serialize_field("UnlockNoteImportantRoleMap", &self.unlock_note_important_role_map)?;
        }
        if !self.unlock_note_reading_book_map.is_empty() {
            struct_ser.serialize_field("UnlockNoteReadingBookMap", &self.unlock_note_reading_book_map)?;
        }
        if !self.unlock_note_dictionary_map.is_empty() {
            struct_ser.serialize_field("UnlockNoteDictionaryMap", &self.unlock_note_dictionary_map)?;
        }
        if !self.unlock_note_post_card_map.is_empty() {
            struct_ser.serialize_field("UnlockNotePostCardMap", &self.unlock_note_post_card_map)?;
        }
        if !self.unlock_note_month_card_map.is_empty() {
            struct_ser.serialize_field("UnlockNoteMonthCardMap", &self.unlock_note_month_card_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HandbookData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UnlockNoteImportantRoleMap",
            "UnlockNoteReadingBookMap",
            "UnlockNoteDictionaryMap",
            "UnlockNotePostCardMap",
            "UnlockNoteMonthCardMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UnlockNoteImportantRoleMap,
            UnlockNoteReadingBookMap,
            UnlockNoteDictionaryMap,
            UnlockNotePostCardMap,
            UnlockNoteMonthCardMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UnlockNoteImportantRoleMap" => Ok(GeneratedField::UnlockNoteImportantRoleMap),
                            "UnlockNoteReadingBookMap" => Ok(GeneratedField::UnlockNoteReadingBookMap),
                            "UnlockNoteDictionaryMap" => Ok(GeneratedField::UnlockNoteDictionaryMap),
                            "UnlockNotePostCardMap" => Ok(GeneratedField::UnlockNotePostCardMap),
                            "UnlockNoteMonthCardMap" => Ok(GeneratedField::UnlockNoteMonthCardMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HandbookData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HandbookData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HandbookData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut unlock_note_important_role_map__ = None;
                let mut unlock_note_reading_book_map__ = None;
                let mut unlock_note_dictionary_map__ = None;
                let mut unlock_note_post_card_map__ = None;
                let mut unlock_note_month_card_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UnlockNoteImportantRoleMap => {
                            if unlock_note_important_role_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockNoteImportantRoleMap"));
                            }
                            unlock_note_important_role_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::UnlockNoteReadingBookMap => {
                            if unlock_note_reading_book_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockNoteReadingBookMap"));
                            }
                            unlock_note_reading_book_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::UnlockNoteDictionaryMap => {
                            if unlock_note_dictionary_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockNoteDictionaryMap"));
                            }
                            unlock_note_dictionary_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::UnlockNotePostCardMap => {
                            if unlock_note_post_card_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockNotePostCardMap"));
                            }
                            unlock_note_post_card_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::UnlockNoteMonthCardMap => {
                            if unlock_note_month_card_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockNoteMonthCardMap"));
                            }
                            unlock_note_month_card_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(HandbookData {
                    unlock_note_important_role_map: unlock_note_important_role_map__.unwrap_or_default(),
                    unlock_note_reading_book_map: unlock_note_reading_book_map__.unwrap_or_default(),
                    unlock_note_dictionary_map: unlock_note_dictionary_map__.unwrap_or_default(),
                    unlock_note_post_card_map: unlock_note_post_card_map__.unwrap_or_default(),
                    unlock_note_month_card_map: unlock_note_month_card_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HandbookData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HeroKeyItemInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.item.is_some() {
            len += 1;
        }
        if !self.roll_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HeroKeyItemInfo", len)?;
        if let Some(v) = self.item.as_ref() {
            struct_ser.serialize_field("Item", v)?;
        }
        if !self.roll_info.is_empty() {
            struct_ser.serialize_field("RollInfo", &self.roll_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HeroKeyItemInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Item",
            "RollInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Item,
            RollInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Item" => Ok(GeneratedField::Item),
                            "RollInfo" => Ok(GeneratedField::RollInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HeroKeyItemInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HeroKeyItemInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HeroKeyItemInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut item__ = None;
                let mut roll_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Item => {
                            if item__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Item"));
                            }
                            item__ = map_.next_value()?;
                        }
                        GeneratedField::RollInfo => {
                            if roll_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RollInfo"));
                            }
                            roll_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(HeroKeyItemInfo {
                    item: item__,
                    roll_info: roll_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HeroKeyItemInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HeroKeyRollInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.char_id.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if self.avatar.is_some() {
            len += 1;
        }
        if self.roll_value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HeroKeyRollInfo", len)?;
        if let Some(v) = self.r#type.as_ref() {
            let v = EHeroKeyRollType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Type", &v)?;
        }
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("Name", v)?;
        }
        if let Some(v) = self.avatar.as_ref() {
            struct_ser.serialize_field("Avatar", v)?;
        }
        if let Some(v) = self.roll_value.as_ref() {
            struct_ser.serialize_field("RollValue", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HeroKeyRollInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Type",
            "CharId",
            "Name",
            "Avatar",
            "RollValue",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            CharId,
            Name,
            Avatar,
            RollValue,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Type" => Ok(GeneratedField::Type),
                            "CharId" => Ok(GeneratedField::CharId),
                            "Name" => Ok(GeneratedField::Name),
                            "Avatar" => Ok(GeneratedField::Avatar),
                            "RollValue" => Ok(GeneratedField::RollValue),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HeroKeyRollInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HeroKeyRollInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HeroKeyRollInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut char_id__ = None;
                let mut name__ = None;
                let mut avatar__ = None;
                let mut roll_value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<EHeroKeyRollType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Avatar => {
                            if avatar__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Avatar"));
                            }
                            avatar__ = map_.next_value()?;
                        }
                        GeneratedField::RollValue => {
                            if roll_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RollValue"));
                            }
                            roll_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(HeroKeyRollInfo {
                    r#type: r#type__,
                    char_id: char_id__,
                    name: name__,
                    avatar: avatar__,
                    roll_value: roll_value__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HeroKeyRollInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HomeLandClutterGenerationRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.home_land_clutter_record.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HomeLandClutterGenerationRecord", len)?;
        if !self.home_land_clutter_record.is_empty() {
            struct_ser.serialize_field("HomeLandClutterRecord", &self.home_land_clutter_record)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HomeLandClutterGenerationRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HomeLandClutterRecord",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HomeLandClutterRecord,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "HomeLandClutterRecord" => Ok(GeneratedField::HomeLandClutterRecord),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HomeLandClutterGenerationRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HomeLandClutterGenerationRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HomeLandClutterGenerationRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut home_land_clutter_record__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HomeLandClutterRecord => {
                            if home_land_clutter_record__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomeLandClutterRecord"));
                            }
                            home_land_clutter_record__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(HomeLandClutterGenerationRecord {
                    home_land_clutter_record: home_land_clutter_record__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HomeLandClutterGenerationRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HomeLandClutterInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.home_land_clutter.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HomeLandClutterInfo", len)?;
        if !self.home_land_clutter.is_empty() {
            struct_ser.serialize_field("HomeLandClutter", &self.home_land_clutter)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HomeLandClutterInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HomeLandClutter",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HomeLandClutter,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "HomeLandClutter" => Ok(GeneratedField::HomeLandClutter),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HomeLandClutterInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HomeLandClutterInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HomeLandClutterInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut home_land_clutter__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HomeLandClutter => {
                            if home_land_clutter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomeLandClutter"));
                            }
                            home_land_clutter__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(HomeLandClutterInfo {
                    home_land_clutter: home_land_clutter__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HomeLandClutterInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HomeLandItemInstance {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.instance_id.is_some() {
            len += 1;
        }
        if self.config_id.is_some() {
            len += 1;
        }
        if !self.owner_to_stack_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HomeLandItemInstance", len)?;
        if let Some(v) = self.instance_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("InstanceId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.config_id.as_ref() {
            struct_ser.serialize_field("ConfigId", v)?;
        }
        if !self.owner_to_stack_map.is_empty() {
            struct_ser.serialize_field("OwnerToStackMap", &self.owner_to_stack_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HomeLandItemInstance {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "InstanceId",
            "ConfigId",
            "OwnerToStackMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            InstanceId,
            ConfigId,
            OwnerToStackMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "InstanceId" => Ok(GeneratedField::InstanceId),
                            "ConfigId" => Ok(GeneratedField::ConfigId),
                            "OwnerToStackMap" => Ok(GeneratedField::OwnerToStackMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HomeLandItemInstance;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HomeLandItemInstance")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HomeLandItemInstance, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut instance_id__ = None;
                let mut config_id__ = None;
                let mut owner_to_stack_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::InstanceId => {
                            if instance_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InstanceId"));
                            }
                            instance_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ConfigId => {
                            if config_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConfigId"));
                            }
                            config_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OwnerToStackMap => {
                            if owner_to_stack_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OwnerToStackMap"));
                            }
                            owner_to_stack_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(HomeLandItemInstance {
                    instance_id: instance_id__,
                    config_id: config_id__,
                    owner_to_stack_map: owner_to_stack_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HomeLandItemInstance", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HomeLandPlayerTaskInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.next_task_reflush_time.is_some() {
            len += 1;
        }
        if self.cur_left_times.is_some() {
            len += 1;
        }
        if !self.cur_task_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HomeLandPlayerTaskInfo", len)?;
        if let Some(v) = self.next_task_reflush_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("NextTaskReflushTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.cur_left_times.as_ref() {
            struct_ser.serialize_field("CurLeftTimes", v)?;
        }
        if !self.cur_task_map.is_empty() {
            struct_ser.serialize_field("CurTaskMap", &self.cur_task_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HomeLandPlayerTaskInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NextTaskReflushTime",
            "CurLeftTimes",
            "CurTaskMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            NextTaskReflushTime,
            CurLeftTimes,
            CurTaskMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "NextTaskReflushTime" => Ok(GeneratedField::NextTaskReflushTime),
                            "CurLeftTimes" => Ok(GeneratedField::CurLeftTimes),
                            "CurTaskMap" => Ok(GeneratedField::CurTaskMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HomeLandPlayerTaskInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HomeLandPlayerTaskInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HomeLandPlayerTaskInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut next_task_reflush_time__ = None;
                let mut cur_left_times__ = None;
                let mut cur_task_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::NextTaskReflushTime => {
                            if next_task_reflush_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NextTaskReflushTime"));
                            }
                            next_task_reflush_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurLeftTimes => {
                            if cur_left_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurLeftTimes"));
                            }
                            cur_left_times__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurTaskMap => {
                            if cur_task_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurTaskMap"));
                            }
                            cur_task_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(HomeLandPlayerTaskInfo {
                    next_task_reflush_time: next_task_reflush_time__,
                    cur_left_times: cur_left_times__,
                    cur_task_map: cur_task_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HomeLandPlayerTaskInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HomeLandSellShopInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_init.is_some() {
            len += 1;
        }
        if self.next_reflush_time.is_some() {
            len += 1;
        }
        if !self.collecting_items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HomeLandSellShopInfo", len)?;
        if let Some(v) = self.is_init.as_ref() {
            struct_ser.serialize_field("IsInit", v)?;
        }
        if let Some(v) = self.next_reflush_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("NextReflushTime", ToString::to_string(&v).as_str())?;
        }
        if !self.collecting_items.is_empty() {
            struct_ser.serialize_field("CollectingItems", &self.collecting_items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HomeLandSellShopInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsInit",
            "NextReflushTime",
            "CollectingItems",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsInit,
            NextReflushTime,
            CollectingItems,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsInit" => Ok(GeneratedField::IsInit),
                            "NextReflushTime" => Ok(GeneratedField::NextReflushTime),
                            "CollectingItems" => Ok(GeneratedField::CollectingItems),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HomeLandSellShopInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HomeLandSellShopInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HomeLandSellShopInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_init__ = None;
                let mut next_reflush_time__ = None;
                let mut collecting_items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsInit => {
                            if is_init__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsInit"));
                            }
                            is_init__ = map_.next_value()?;
                        }
                        GeneratedField::NextReflushTime => {
                            if next_reflush_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NextReflushTime"));
                            }
                            next_reflush_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CollectingItems => {
                            if collecting_items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CollectingItems"));
                            }
                            collecting_items__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(HomeLandSellShopInfo {
                    is_init: is_init__,
                    next_reflush_time: next_reflush_time__,
                    collecting_items: collecting_items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HomeLandSellShopInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HomeLandTask {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.finished.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HomeLandTask", len)?;
        if let Some(v) = self.finished.as_ref() {
            struct_ser.serialize_field("Finished", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HomeLandTask {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Finished",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Finished,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Finished" => Ok(GeneratedField::Finished),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HomeLandTask;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HomeLandTask")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HomeLandTask, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut finished__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Finished => {
                            if finished__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Finished"));
                            }
                            finished__ = map_.next_value()?;
                        }
                    }
                }
                Ok(HomeLandTask {
                    finished: finished__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HomeLandTask", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HomelandBaseInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.homeland_id.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        if self.exp.is_some() {
            len += 1;
        }
        if self.home_resource.is_some() {
            len += 1;
        }
        if self.cleanliness.is_some() {
            len += 1;
        }
        if self.lastsubtractcleanlinesstime.is_some() {
            len += 1;
        }
        if self.home_land_clutter.is_some() {
            len += 1;
        }
        if self.home_land_clutter_generation_record.is_some() {
            len += 1;
        }
        if self.home_land_sell_shop_info.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        if !self.slots.is_empty() {
            len += 1;
        }
        if !self.item_to_slot.is_empty() {
            len += 1;
        }
        if self.capacity.is_some() {
            len += 1;
        }
        if self.used_slots.is_some() {
            len += 1;
        }
        if self.house_owner_char_id.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if self.check_in_content.is_some() {
            len += 1;
        }
        if self.introduction.is_some() {
            len += 1;
        }
        if self.transfer_community.is_some() {
            len += 1;
        }
        if !self.cohabitant.is_empty() {
            len += 1;
        }
        if !self.furniture_state.is_empty() {
            len += 1;
        }
        if self.authority_info.is_some() {
            len += 1;
        }
        if self.field_id.is_some() {
            len += 1;
        }
        if self.outer_decoration_info.is_some() {
            len += 1;
        }
        if self.inner_decoration_info.is_some() {
            len += 1;
        }
        if !self.unlocked_areas.is_empty() {
            len += 1;
        }
        if self.housing_type.is_some() {
            len += 1;
        }
        if self.outer_empty_land.is_some() {
            len += 1;
        }
        if self.inner_empty_land.is_some() {
            len += 1;
        }
        if self.flowers_num.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HomelandBaseInfo", len)?;
        if let Some(v) = self.homeland_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HomelandId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if let Some(v) = self.exp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Exp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.home_resource.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HomeResource", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.cleanliness.as_ref() {
            struct_ser.serialize_field("Cleanliness", v)?;
        }
        if let Some(v) = self.lastsubtractcleanlinesstime.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Lastsubtractcleanlinesstime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.home_land_clutter.as_ref() {
            struct_ser.serialize_field("HomeLandClutter", v)?;
        }
        if let Some(v) = self.home_land_clutter_generation_record.as_ref() {
            struct_ser.serialize_field("HomeLandClutterGenerationRecord", v)?;
        }
        if let Some(v) = self.home_land_sell_shop_info.as_ref() {
            struct_ser.serialize_field("HomeLandSellShopInfo", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("Items", &self.items)?;
        }
        if !self.slots.is_empty() {
            let v: std::collections::HashMap<_, _> = self.slots.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("Slots", &v)?;
        }
        if !self.item_to_slot.is_empty() {
            let v: std::collections::HashMap<_, _> = self.item_to_slot.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("ItemToSlot", &v)?;
        }
        if let Some(v) = self.capacity.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Capacity", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.used_slots.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("UsedSlots", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.house_owner_char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HouseOwnerCharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("Name", v)?;
        }
        if let Some(v) = self.check_in_content.as_ref() {
            struct_ser.serialize_field("CheckInContent", v)?;
        }
        if let Some(v) = self.introduction.as_ref() {
            struct_ser.serialize_field("Introduction", v)?;
        }
        if let Some(v) = self.transfer_community.as_ref() {
            struct_ser.serialize_field("TransferCommunity", v)?;
        }
        if !self.cohabitant.is_empty() {
            struct_ser.serialize_field("Cohabitant", &self.cohabitant)?;
        }
        if !self.furniture_state.is_empty() {
            struct_ser.serialize_field("FurnitureState", &self.furniture_state)?;
        }
        if let Some(v) = self.authority_info.as_ref() {
            struct_ser.serialize_field("AuthorityInfo", v)?;
        }
        if let Some(v) = self.field_id.as_ref() {
            struct_ser.serialize_field("FieldId", v)?;
        }
        if let Some(v) = self.outer_decoration_info.as_ref() {
            struct_ser.serialize_field("OuterDecorationInfo", v)?;
        }
        if let Some(v) = self.inner_decoration_info.as_ref() {
            struct_ser.serialize_field("InnerDecorationInfo", v)?;
        }
        if !self.unlocked_areas.is_empty() {
            struct_ser.serialize_field("UnlockedAreas", &self.unlocked_areas)?;
        }
        if let Some(v) = self.housing_type.as_ref() {
            struct_ser.serialize_field("HousingType", v)?;
        }
        if let Some(v) = self.outer_empty_land.as_ref() {
            struct_ser.serialize_field("OuterEmptyLand", v)?;
        }
        if let Some(v) = self.inner_empty_land.as_ref() {
            struct_ser.serialize_field("InnerEmptyLand", v)?;
        }
        if let Some(v) = self.flowers_num.as_ref() {
            struct_ser.serialize_field("FlowersNum", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HomelandBaseInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HomelandId",
            "Level",
            "Exp",
            "HomeResource",
            "Cleanliness",
            "Lastsubtractcleanlinesstime",
            "HomeLandClutter",
            "HomeLandClutterGenerationRecord",
            "HomeLandSellShopInfo",
            "Items",
            "Slots",
            "ItemToSlot",
            "Capacity",
            "UsedSlots",
            "HouseOwnerCharId",
            "Name",
            "CheckInContent",
            "Introduction",
            "TransferCommunity",
            "Cohabitant",
            "FurnitureState",
            "AuthorityInfo",
            "FieldId",
            "OuterDecorationInfo",
            "InnerDecorationInfo",
            "UnlockedAreas",
            "HousingType",
            "OuterEmptyLand",
            "InnerEmptyLand",
            "FlowersNum",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HomelandId,
            Level,
            Exp,
            HomeResource,
            Cleanliness,
            Lastsubtractcleanlinesstime,
            HomeLandClutter,
            HomeLandClutterGenerationRecord,
            HomeLandSellShopInfo,
            Items,
            Slots,
            ItemToSlot,
            Capacity,
            UsedSlots,
            HouseOwnerCharId,
            Name,
            CheckInContent,
            Introduction,
            TransferCommunity,
            Cohabitant,
            FurnitureState,
            AuthorityInfo,
            FieldId,
            OuterDecorationInfo,
            InnerDecorationInfo,
            UnlockedAreas,
            HousingType,
            OuterEmptyLand,
            InnerEmptyLand,
            FlowersNum,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "HomelandId" => Ok(GeneratedField::HomelandId),
                            "Level" => Ok(GeneratedField::Level),
                            "Exp" => Ok(GeneratedField::Exp),
                            "HomeResource" => Ok(GeneratedField::HomeResource),
                            "Cleanliness" => Ok(GeneratedField::Cleanliness),
                            "Lastsubtractcleanlinesstime" => Ok(GeneratedField::Lastsubtractcleanlinesstime),
                            "HomeLandClutter" => Ok(GeneratedField::HomeLandClutter),
                            "HomeLandClutterGenerationRecord" => Ok(GeneratedField::HomeLandClutterGenerationRecord),
                            "HomeLandSellShopInfo" => Ok(GeneratedField::HomeLandSellShopInfo),
                            "Items" => Ok(GeneratedField::Items),
                            "Slots" => Ok(GeneratedField::Slots),
                            "ItemToSlot" => Ok(GeneratedField::ItemToSlot),
                            "Capacity" => Ok(GeneratedField::Capacity),
                            "UsedSlots" => Ok(GeneratedField::UsedSlots),
                            "HouseOwnerCharId" => Ok(GeneratedField::HouseOwnerCharId),
                            "Name" => Ok(GeneratedField::Name),
                            "CheckInContent" => Ok(GeneratedField::CheckInContent),
                            "Introduction" => Ok(GeneratedField::Introduction),
                            "TransferCommunity" => Ok(GeneratedField::TransferCommunity),
                            "Cohabitant" => Ok(GeneratedField::Cohabitant),
                            "FurnitureState" => Ok(GeneratedField::FurnitureState),
                            "AuthorityInfo" => Ok(GeneratedField::AuthorityInfo),
                            "FieldId" => Ok(GeneratedField::FieldId),
                            "OuterDecorationInfo" => Ok(GeneratedField::OuterDecorationInfo),
                            "InnerDecorationInfo" => Ok(GeneratedField::InnerDecorationInfo),
                            "UnlockedAreas" => Ok(GeneratedField::UnlockedAreas),
                            "HousingType" => Ok(GeneratedField::HousingType),
                            "OuterEmptyLand" => Ok(GeneratedField::OuterEmptyLand),
                            "InnerEmptyLand" => Ok(GeneratedField::InnerEmptyLand),
                            "FlowersNum" => Ok(GeneratedField::FlowersNum),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HomelandBaseInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HomelandBaseInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HomelandBaseInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut homeland_id__ = None;
                let mut level__ = None;
                let mut exp__ = None;
                let mut home_resource__ = None;
                let mut cleanliness__ = None;
                let mut lastsubtractcleanlinesstime__ = None;
                let mut home_land_clutter__ = None;
                let mut home_land_clutter_generation_record__ = None;
                let mut home_land_sell_shop_info__ = None;
                let mut items__ = None;
                let mut slots__ = None;
                let mut item_to_slot__ = None;
                let mut capacity__ = None;
                let mut used_slots__ = None;
                let mut house_owner_char_id__ = None;
                let mut name__ = None;
                let mut check_in_content__ = None;
                let mut introduction__ = None;
                let mut transfer_community__ = None;
                let mut cohabitant__ = None;
                let mut furniture_state__ = None;
                let mut authority_info__ = None;
                let mut field_id__ = None;
                let mut outer_decoration_info__ = None;
                let mut inner_decoration_info__ = None;
                let mut unlocked_areas__ = None;
                let mut housing_type__ = None;
                let mut outer_empty_land__ = None;
                let mut inner_empty_land__ = None;
                let mut flowers_num__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HomelandId => {
                            if homeland_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomelandId"));
                            }
                            homeland_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Exp => {
                            if exp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Exp"));
                            }
                            exp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HomeResource => {
                            if home_resource__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomeResource"));
                            }
                            home_resource__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Cleanliness => {
                            if cleanliness__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Cleanliness"));
                            }
                            cleanliness__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Lastsubtractcleanlinesstime => {
                            if lastsubtractcleanlinesstime__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Lastsubtractcleanlinesstime"));
                            }
                            lastsubtractcleanlinesstime__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HomeLandClutter => {
                            if home_land_clutter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomeLandClutter"));
                            }
                            home_land_clutter__ = map_.next_value()?;
                        }
                        GeneratedField::HomeLandClutterGenerationRecord => {
                            if home_land_clutter_generation_record__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomeLandClutterGenerationRecord"));
                            }
                            home_land_clutter_generation_record__ = map_.next_value()?;
                        }
                        GeneratedField::HomeLandSellShopInfo => {
                            if home_land_sell_shop_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomeLandSellShopInfo"));
                            }
                            home_land_sell_shop_info__ = map_.next_value()?;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Items"));
                            }
                            items__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::Slots => {
                            if slots__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Slots"));
                            }
                            slots__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::ItemToSlot => {
                            if item_to_slot__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ItemToSlot"));
                            }
                            item_to_slot__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::Capacity => {
                            if capacity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Capacity"));
                            }
                            capacity__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::UsedSlots => {
                            if used_slots__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UsedSlots"));
                            }
                            used_slots__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HouseOwnerCharId => {
                            if house_owner_char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HouseOwnerCharId"));
                            }
                            house_owner_char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::CheckInContent => {
                            if check_in_content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CheckInContent"));
                            }
                            check_in_content__ = map_.next_value()?;
                        }
                        GeneratedField::Introduction => {
                            if introduction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Introduction"));
                            }
                            introduction__ = map_.next_value()?;
                        }
                        GeneratedField::TransferCommunity => {
                            if transfer_community__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TransferCommunity"));
                            }
                            transfer_community__ = map_.next_value()?;
                        }
                        GeneratedField::Cohabitant => {
                            if cohabitant__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Cohabitant"));
                            }
                            cohabitant__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::FurnitureState => {
                            if furniture_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FurnitureState"));
                            }
                            furniture_state__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::AuthorityInfo => {
                            if authority_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AuthorityInfo"));
                            }
                            authority_info__ = map_.next_value()?;
                        }
                        GeneratedField::FieldId => {
                            if field_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FieldId"));
                            }
                            field_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OuterDecorationInfo => {
                            if outer_decoration_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OuterDecorationInfo"));
                            }
                            outer_decoration_info__ = map_.next_value()?;
                        }
                        GeneratedField::InnerDecorationInfo => {
                            if inner_decoration_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InnerDecorationInfo"));
                            }
                            inner_decoration_info__ = map_.next_value()?;
                        }
                        GeneratedField::UnlockedAreas => {
                            if unlocked_areas__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockedAreas"));
                            }
                            unlocked_areas__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::HousingType => {
                            if housing_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HousingType"));
                            }
                            housing_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OuterEmptyLand => {
                            if outer_empty_land__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OuterEmptyLand"));
                            }
                            outer_empty_land__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::InnerEmptyLand => {
                            if inner_empty_land__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InnerEmptyLand"));
                            }
                            inner_empty_land__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FlowersNum => {
                            if flowers_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FlowersNum"));
                            }
                            flowers_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(HomelandBaseInfo {
                    homeland_id: homeland_id__,
                    level: level__,
                    exp: exp__,
                    home_resource: home_resource__,
                    cleanliness: cleanliness__,
                    lastsubtractcleanlinesstime: lastsubtractcleanlinesstime__,
                    home_land_clutter: home_land_clutter__,
                    home_land_clutter_generation_record: home_land_clutter_generation_record__,
                    home_land_sell_shop_info: home_land_sell_shop_info__,
                    items: items__.unwrap_or_default(),
                    slots: slots__.unwrap_or_default(),
                    item_to_slot: item_to_slot__.unwrap_or_default(),
                    capacity: capacity__,
                    used_slots: used_slots__,
                    house_owner_char_id: house_owner_char_id__,
                    name: name__,
                    check_in_content: check_in_content__,
                    introduction: introduction__,
                    transfer_community: transfer_community__,
                    cohabitant: cohabitant__.unwrap_or_default(),
                    furniture_state: furniture_state__.unwrap_or_default(),
                    authority_info: authority_info__,
                    field_id: field_id__,
                    outer_decoration_info: outer_decoration_info__,
                    inner_decoration_info: inner_decoration_info__,
                    unlocked_areas: unlocked_areas__.unwrap_or_default(),
                    housing_type: housing_type__,
                    outer_empty_land: outer_empty_land__,
                    inner_empty_land: inner_empty_land__,
                    flowers_num: flowers_num__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HomelandBaseInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HomelandDecorationInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.lamplight_info.is_some() {
            len += 1;
        }
        if !self.material_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HomelandDecorationInfo", len)?;
        if let Some(v) = self.lamplight_info.as_ref() {
            struct_ser.serialize_field("LamplightInfo", v)?;
        }
        if !self.material_infos.is_empty() {
            struct_ser.serialize_field("MaterialInfos", &self.material_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HomelandDecorationInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LamplightInfo",
            "MaterialInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LamplightInfo,
            MaterialInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LamplightInfo" => Ok(GeneratedField::LamplightInfo),
                            "MaterialInfos" => Ok(GeneratedField::MaterialInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HomelandDecorationInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HomelandDecorationInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HomelandDecorationInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut lamplight_info__ = None;
                let mut material_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LamplightInfo => {
                            if lamplight_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LamplightInfo"));
                            }
                            lamplight_info__ = map_.next_value()?;
                        }
                        GeneratedField::MaterialInfos => {
                            if material_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaterialInfos"));
                            }
                            material_infos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(HomelandDecorationInfo {
                    lamplight_info: lamplight_info__,
                    material_infos: material_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HomelandDecorationInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HomelandLamplightInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.lamplight_level.is_some() {
            len += 1;
        }
        if self.lamplight_color.is_some() {
            len += 1;
        }
        if self.day_night_id.is_some() {
            len += 1;
        }
        if self.mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HomelandLamplightInfo", len)?;
        if let Some(v) = self.lamplight_level.as_ref() {
            struct_ser.serialize_field("LamplightLevel", v)?;
        }
        if let Some(v) = self.lamplight_color.as_ref() {
            struct_ser.serialize_field("LamplightColor", v)?;
        }
        if let Some(v) = self.day_night_id.as_ref() {
            struct_ser.serialize_field("DayNightId", v)?;
        }
        if let Some(v) = self.mode.as_ref() {
            struct_ser.serialize_field("Mode", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HomelandLamplightInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LamplightLevel",
            "LamplightColor",
            "DayNightId",
            "Mode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LamplightLevel,
            LamplightColor,
            DayNightId,
            Mode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LamplightLevel" => Ok(GeneratedField::LamplightLevel),
                            "LamplightColor" => Ok(GeneratedField::LamplightColor),
                            "DayNightId" => Ok(GeneratedField::DayNightId),
                            "Mode" => Ok(GeneratedField::Mode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HomelandLamplightInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HomelandLamplightInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HomelandLamplightInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut lamplight_level__ = None;
                let mut lamplight_color__ = None;
                let mut day_night_id__ = None;
                let mut mode__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LamplightLevel => {
                            if lamplight_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LamplightLevel"));
                            }
                            lamplight_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LamplightColor => {
                            if lamplight_color__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LamplightColor"));
                            }
                            lamplight_color__ = map_.next_value()?;
                        }
                        GeneratedField::DayNightId => {
                            if day_night_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DayNightId"));
                            }
                            day_night_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Mode => {
                            if mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Mode"));
                            }
                            mode__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(HomelandLamplightInfo {
                    lamplight_level: lamplight_level__,
                    lamplight_color: lamplight_color__,
                    day_night_id: day_night_id__,
                    mode: mode__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HomelandLamplightInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HomelandMaterialInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.material_id.is_some() {
            len += 1;
        }
        if self.char_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.HomelandMaterialInfo", len)?;
        if let Some(v) = self.material_id.as_ref() {
            struct_ser.serialize_field("MaterialId", v)?;
        }
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HomelandMaterialInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MaterialId",
            "CharId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MaterialId,
            CharId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MaterialId" => Ok(GeneratedField::MaterialId),
                            "CharId" => Ok(GeneratedField::CharId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HomelandMaterialInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.HomelandMaterialInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HomelandMaterialInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut material_id__ = None;
                let mut char_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MaterialId => {
                            if material_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaterialId"));
                            }
                            material_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(HomelandMaterialInfo {
                    material_id: material_id__,
                    char_id: char_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.HomelandMaterialInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ImageInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.size.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        if self.cos_url.is_some() {
            len += 1;
        }
        if self.extra_info.is_some() {
            len += 1;
        }
        if self.review_start_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ImageInfo", len)?;
        if let Some(v) = self.r#type.as_ref() {
            let v = EPictureType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Type", &v)?;
        }
        if let Some(v) = self.size.as_ref() {
            struct_ser.serialize_field("Size", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            struct_ser.serialize_field("Version", v)?;
        }
        if let Some(v) = self.cos_url.as_ref() {
            struct_ser.serialize_field("CosUrl", v)?;
        }
        if let Some(v) = self.extra_info.as_ref() {
            struct_ser.serialize_field("ExtraInfo", v)?;
        }
        if let Some(v) = self.review_start_time.as_ref() {
            struct_ser.serialize_field("ReviewStartTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ImageInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Type",
            "Size",
            "Version",
            "CosUrl",
            "ExtraInfo",
            "ReviewStartTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Size,
            Version,
            CosUrl,
            ExtraInfo,
            ReviewStartTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Type" => Ok(GeneratedField::Type),
                            "Size" => Ok(GeneratedField::Size),
                            "Version" => Ok(GeneratedField::Version),
                            "CosUrl" => Ok(GeneratedField::CosUrl),
                            "ExtraInfo" => Ok(GeneratedField::ExtraInfo),
                            "ReviewStartTime" => Ok(GeneratedField::ReviewStartTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ImageInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ImageInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ImageInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut size__ = None;
                let mut version__ = None;
                let mut cos_url__ = None;
                let mut extra_info__ = None;
                let mut review_start_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<EPictureType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Size"));
                            }
                            size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CosUrl => {
                            if cos_url__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CosUrl"));
                            }
                            cos_url__ = map_.next_value()?;
                        }
                        GeneratedField::ExtraInfo => {
                            if extra_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExtraInfo"));
                            }
                            extra_info__ = map_.next_value()?;
                        }
                        GeneratedField::ReviewStartTime => {
                            if review_start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReviewStartTime"));
                            }
                            review_start_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ImageInfo {
                    r#type: r#type__,
                    size: size__,
                    version: version__,
                    cos_url: cos_url__,
                    extra_info: extra_info__,
                    review_start_time: review_start_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ImageInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InitHomeLandInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_outer.is_some() {
            len += 1;
        }
        if !self.structures.is_empty() {
            len += 1;
        }
        if self.decoration_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.InitHomeLandInfo", len)?;
        if let Some(v) = self.is_outer.as_ref() {
            struct_ser.serialize_field("IsOuter", v)?;
        }
        if !self.structures.is_empty() {
            struct_ser.serialize_field("Structures", &self.structures)?;
        }
        if let Some(v) = self.decoration_info.as_ref() {
            struct_ser.serialize_field("DecorationInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InitHomeLandInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsOuter",
            "Structures",
            "DecorationInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsOuter,
            Structures,
            DecorationInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsOuter" => Ok(GeneratedField::IsOuter),
                            "Structures" => Ok(GeneratedField::Structures),
                            "DecorationInfo" => Ok(GeneratedField::DecorationInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InitHomeLandInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.InitHomeLandInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InitHomeLandInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_outer__ = None;
                let mut structures__ = None;
                let mut decoration_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsOuter => {
                            if is_outer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsOuter"));
                            }
                            is_outer__ = map_.next_value()?;
                        }
                        GeneratedField::Structures => {
                            if structures__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Structures"));
                            }
                            structures__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::DecorationInfo => {
                            if decoration_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DecorationInfo"));
                            }
                            decoration_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(InitHomeLandInfo {
                    is_outer: is_outer__,
                    structures: structures__.unwrap_or_default(),
                    decoration_info: decoration_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.InitHomeLandInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InstallResonanceSkillReq {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_position.is_some() {
            len += 1;
        }
        if self.v_resonance_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.InstallResonanceSkillReq", len)?;
        if let Some(v) = self.v_position.as_ref() {
            struct_ser.serialize_field("VPosition", v)?;
        }
        if let Some(v) = self.v_resonance_id.as_ref() {
            struct_ser.serialize_field("VResonanceId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InstallResonanceSkillReq {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VPosition",
            "VResonanceId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VPosition,
            VResonanceId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VPosition" => Ok(GeneratedField::VPosition),
                            "VResonanceId" => Ok(GeneratedField::VResonanceId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InstallResonanceSkillReq;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.InstallResonanceSkillReq")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InstallResonanceSkillReq, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_position__ = None;
                let mut v_resonance_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VPosition => {
                            if v_position__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VPosition"));
                            }
                            v_position__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VResonanceId => {
                            if v_resonance_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VResonanceId"));
                            }
                            v_resonance_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(InstallResonanceSkillReq {
                    v_position: v_position__,
                    v_resonance_id: v_resonance_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.InstallResonanceSkillReq", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for IntVec3 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.x.is_some() {
            len += 1;
        }
        if self.y.is_some() {
            len += 1;
        }
        if self.z.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.IntVec3", len)?;
        if let Some(v) = self.x.as_ref() {
            struct_ser.serialize_field("X", v)?;
        }
        if let Some(v) = self.y.as_ref() {
            struct_ser.serialize_field("Y", v)?;
        }
        if let Some(v) = self.z.as_ref() {
            struct_ser.serialize_field("Z", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for IntVec3 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "X",
            "Y",
            "Z",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            X,
            Y,
            Z,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "X" => Ok(GeneratedField::X),
                            "Y" => Ok(GeneratedField::Y),
                            "Z" => Ok(GeneratedField::Z),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = IntVec3;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.IntVec3")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<IntVec3, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut x__ = None;
                let mut y__ = None;
                let mut z__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::X => {
                            if x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("X"));
                            }
                            x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Y => {
                            if y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Y"));
                            }
                            y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Z => {
                            if z__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Z"));
                            }
                            z__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(IntVec3 {
                    x: x__,
                    y: y__,
                    z: z__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.IntVec3", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for IntVec3Db {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.x.is_some() {
            len += 1;
        }
        if self.y.is_some() {
            len += 1;
        }
        if self.z.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.IntVec3Db", len)?;
        if let Some(v) = self.x.as_ref() {
            struct_ser.serialize_field("X", v)?;
        }
        if let Some(v) = self.y.as_ref() {
            struct_ser.serialize_field("Y", v)?;
        }
        if let Some(v) = self.z.as_ref() {
            struct_ser.serialize_field("Z", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for IntVec3Db {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "X",
            "Y",
            "Z",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            X,
            Y,
            Z,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "X" => Ok(GeneratedField::X),
                            "Y" => Ok(GeneratedField::Y),
                            "Z" => Ok(GeneratedField::Z),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = IntVec3Db;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.IntVec3Db")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<IntVec3Db, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut x__ = None;
                let mut y__ = None;
                let mut z__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::X => {
                            if x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("X"));
                            }
                            x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Y => {
                            if y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Y"));
                            }
                            y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Z => {
                            if z__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Z"));
                            }
                            z__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(IntVec3Db {
                    x: x__,
                    y: y__,
                    z: z__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.IntVec3Db", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Interaction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Interaction", len)?;
        if let Some(v) = self.v_info.as_ref() {
            struct_ser.serialize_field("VInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Interaction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VInfo" => Ok(GeneratedField::VInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Interaction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Interaction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Interaction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VInfo => {
                            if v_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VInfo"));
                            }
                            v_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(Interaction {
                    v_info: v_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Interaction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InteractionActionEnd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cur_stage.is_some() {
            len += 1;
        }
        if self.action_type.is_some() {
            len += 1;
        }
        if self.is_success.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.InteractionActionEnd", len)?;
        if let Some(v) = self.cur_stage.as_ref() {
            struct_ser.serialize_field("CurStage", v)?;
        }
        if let Some(v) = self.action_type.as_ref() {
            let v = EInteractionAction::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ActionType", &v)?;
        }
        if let Some(v) = self.is_success.as_ref() {
            struct_ser.serialize_field("IsSuccess", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InteractionActionEnd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CurStage",
            "ActionType",
            "IsSuccess",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CurStage,
            ActionType,
            IsSuccess,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CurStage" => Ok(GeneratedField::CurStage),
                            "ActionType" => Ok(GeneratedField::ActionType),
                            "IsSuccess" => Ok(GeneratedField::IsSuccess),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InteractionActionEnd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.InteractionActionEnd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InteractionActionEnd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cur_stage__ = None;
                let mut action_type__ = None;
                let mut is_success__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CurStage => {
                            if cur_stage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurStage"));
                            }
                            cur_stage__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ActionType => {
                            if action_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActionType"));
                            }
                            action_type__ = map_.next_value::<::std::option::Option<EInteractionAction>>()?.map(|x| x as i32);
                        }
                        GeneratedField::IsSuccess => {
                            if is_success__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsSuccess"));
                            }
                            is_success__ = map_.next_value()?;
                        }
                    }
                }
                Ok(InteractionActionEnd {
                    cur_stage: cur_stage__,
                    action_type: action_type__,
                    is_success: is_success__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.InteractionActionEnd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InteractionInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.interaction_stage.is_some() {
            len += 1;
        }
        if self.action_id.is_some() {
            len += 1;
        }
        if self.originator_id.is_some() {
            len += 1;
        }
        if self.invitee_id.is_some() {
            len += 1;
        }
        if self.is_originator.is_some() {
            len += 1;
        }
        if self.interaction_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.InteractionInfo", len)?;
        if let Some(v) = self.interaction_stage.as_ref() {
            struct_ser.serialize_field("InteractionStage", v)?;
        }
        if let Some(v) = self.action_id.as_ref() {
            struct_ser.serialize_field("ActionId", v)?;
        }
        if let Some(v) = self.originator_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("OriginatorId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.invitee_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("InviteeId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.is_originator.as_ref() {
            struct_ser.serialize_field("IsOriginator", v)?;
        }
        if let Some(v) = self.interaction_type.as_ref() {
            struct_ser.serialize_field("InteractionType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InteractionInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "InteractionStage",
            "ActionId",
            "OriginatorId",
            "InviteeId",
            "IsOriginator",
            "InteractionType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            InteractionStage,
            ActionId,
            OriginatorId,
            InviteeId,
            IsOriginator,
            InteractionType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "InteractionStage" => Ok(GeneratedField::InteractionStage),
                            "ActionId" => Ok(GeneratedField::ActionId),
                            "OriginatorId" => Ok(GeneratedField::OriginatorId),
                            "InviteeId" => Ok(GeneratedField::InviteeId),
                            "IsOriginator" => Ok(GeneratedField::IsOriginator),
                            "InteractionType" => Ok(GeneratedField::InteractionType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InteractionInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.InteractionInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InteractionInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut interaction_stage__ = None;
                let mut action_id__ = None;
                let mut originator_id__ = None;
                let mut invitee_id__ = None;
                let mut is_originator__ = None;
                let mut interaction_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::InteractionStage => {
                            if interaction_stage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InteractionStage"));
                            }
                            interaction_stage__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ActionId => {
                            if action_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActionId"));
                            }
                            action_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OriginatorId => {
                            if originator_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OriginatorId"));
                            }
                            originator_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::InviteeId => {
                            if invitee_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InviteeId"));
                            }
                            invitee_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsOriginator => {
                            if is_originator__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsOriginator"));
                            }
                            is_originator__ = map_.next_value()?;
                        }
                        GeneratedField::InteractionType => {
                            if interaction_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InteractionType"));
                            }
                            interaction_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(InteractionInfo {
                    interaction_stage: interaction_stage__,
                    action_id: action_id__,
                    originator_id: originator_id__,
                    invitee_id: invitee_id__,
                    is_originator: is_originator__,
                    interaction_type: interaction_type__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.InteractionInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InteractionTemplateData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.object_id.is_some() {
            len += 1;
        }
        if self.template_id.is_some() {
            len += 1;
        }
        if self.homeland_id.is_some() {
            len += 1;
        }
        if self.pos_id.is_some() {
            len += 1;
        }
        if self.sub_template_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.InteractionTemplateData", len)?;
        if let Some(v) = self.r#type.as_ref() {
            let v = EInteractionTemplateAction::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Type", &v)?;
        }
        if let Some(v) = self.object_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ObjectId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.template_id.as_ref() {
            struct_ser.serialize_field("TemplateId", v)?;
        }
        if let Some(v) = self.homeland_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HomelandId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.pos_id.as_ref() {
            struct_ser.serialize_field("PosId", v)?;
        }
        if let Some(v) = self.sub_template_id.as_ref() {
            struct_ser.serialize_field("SubTemplateId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InteractionTemplateData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Type",
            "ObjectId",
            "TemplateId",
            "HomelandId",
            "PosId",
            "SubTemplateId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            ObjectId,
            TemplateId,
            HomelandId,
            PosId,
            SubTemplateId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Type" => Ok(GeneratedField::Type),
                            "ObjectId" => Ok(GeneratedField::ObjectId),
                            "TemplateId" => Ok(GeneratedField::TemplateId),
                            "HomelandId" => Ok(GeneratedField::HomelandId),
                            "PosId" => Ok(GeneratedField::PosId),
                            "SubTemplateId" => Ok(GeneratedField::SubTemplateId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InteractionTemplateData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.InteractionTemplateData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InteractionTemplateData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut object_id__ = None;
                let mut template_id__ = None;
                let mut homeland_id__ = None;
                let mut pos_id__ = None;
                let mut sub_template_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<EInteractionTemplateAction>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ObjectId => {
                            if object_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ObjectId"));
                            }
                            object_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TemplateId => {
                            if template_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TemplateId"));
                            }
                            template_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HomelandId => {
                            if homeland_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomelandId"));
                            }
                            homeland_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PosId => {
                            if pos_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PosId"));
                            }
                            pos_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SubTemplateId => {
                            if sub_template_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SubTemplateId"));
                            }
                            sub_template_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(InteractionTemplateData {
                    r#type: r#type__,
                    object_id: object_id__,
                    template_id: template_id__,
                    homeland_id: homeland_id__,
                    pos_id: pos_id__,
                    sub_template_id: sub_template_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.InteractionTemplateData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InteractionWithNotPlayer {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_entity_config_id.is_some() {
            len += 1;
        }
        if self.v_entity_type.is_some() {
            len += 1;
        }
        if self.v_action_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.InteractionWithNotPlayer", len)?;
        if let Some(v) = self.v_entity_config_id.as_ref() {
            struct_ser.serialize_field("VEntityConfigId", v)?;
        }
        if let Some(v) = self.v_entity_type.as_ref() {
            struct_ser.serialize_field("VEntityType", v)?;
        }
        if let Some(v) = self.v_action_id.as_ref() {
            struct_ser.serialize_field("VActionId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InteractionWithNotPlayer {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VEntityConfigId",
            "VEntityType",
            "VActionId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VEntityConfigId,
            VEntityType,
            VActionId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VEntityConfigId" => Ok(GeneratedField::VEntityConfigId),
                            "VEntityType" => Ok(GeneratedField::VEntityType),
                            "VActionId" => Ok(GeneratedField::VActionId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InteractionWithNotPlayer;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.InteractionWithNotPlayer")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InteractionWithNotPlayer, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_entity_config_id__ = None;
                let mut v_entity_type__ = None;
                let mut v_action_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VEntityConfigId => {
                            if v_entity_config_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VEntityConfigId"));
                            }
                            v_entity_config_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VEntityType => {
                            if v_entity_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VEntityType"));
                            }
                            v_entity_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VActionId => {
                            if v_action_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VActionId"));
                            }
                            v_action_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(InteractionWithNotPlayer {
                    v_entity_config_id: v_entity_config_id__,
                    v_entity_type: v_entity_type__,
                    v_action_id: v_action_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.InteractionWithNotPlayer", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InvestigateData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if !self.step_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.InvestigateData", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if !self.step_ids.is_empty() {
            struct_ser.serialize_field("StepIds", &self.step_ids)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InvestigateData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "StepIds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            StepIds,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "StepIds" => Ok(GeneratedField::StepIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InvestigateData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.InvestigateData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InvestigateData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut step_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StepIds => {
                            if step_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StepIds"));
                            }
                            step_ids__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(InvestigateData {
                    id: id__,
                    step_ids: step_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.InvestigateData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InvestigateList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.investigate_map.is_empty() {
            len += 1;
        }
        if !self.comp_investigate_map.is_empty() {
            len += 1;
        }
        if !self.comp_reasoning_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.InvestigateList", len)?;
        if !self.investigate_map.is_empty() {
            struct_ser.serialize_field("InvestigateMap", &self.investigate_map)?;
        }
        if !self.comp_investigate_map.is_empty() {
            struct_ser.serialize_field("CompInvestigateMap", &self.comp_investigate_map)?;
        }
        if !self.comp_reasoning_map.is_empty() {
            struct_ser.serialize_field("CompReasoningMap", &self.comp_reasoning_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InvestigateList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "InvestigateMap",
            "CompInvestigateMap",
            "CompReasoningMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            InvestigateMap,
            CompInvestigateMap,
            CompReasoningMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "InvestigateMap" => Ok(GeneratedField::InvestigateMap),
                            "CompInvestigateMap" => Ok(GeneratedField::CompInvestigateMap),
                            "CompReasoningMap" => Ok(GeneratedField::CompReasoningMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InvestigateList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.InvestigateList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InvestigateList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut investigate_map__ = None;
                let mut comp_investigate_map__ = None;
                let mut comp_reasoning_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::InvestigateMap => {
                            if investigate_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InvestigateMap"));
                            }
                            investigate_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::CompInvestigateMap => {
                            if comp_investigate_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CompInvestigateMap"));
                            }
                            comp_investigate_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::CompReasoningMap => {
                            if comp_reasoning_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CompReasoningMap"));
                            }
                            comp_reasoning_map__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(InvestigateList {
                    investigate_map: investigate_map__.unwrap_or_default(),
                    comp_investigate_map: comp_investigate_map__.unwrap_or_default(),
                    comp_reasoning_map: comp_reasoning_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.InvestigateList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for InvestigateStep {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.clues.is_empty() {
            len += 1;
        }
        if !self.reasoning_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.InvestigateStep", len)?;
        if !self.clues.is_empty() {
            struct_ser.serialize_field("Clues", &self.clues)?;
        }
        if !self.reasoning_map.is_empty() {
            struct_ser.serialize_field("ReasoningMap", &self.reasoning_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for InvestigateStep {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Clues",
            "ReasoningMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Clues,
            ReasoningMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Clues" => Ok(GeneratedField::Clues),
                            "ReasoningMap" => Ok(GeneratedField::ReasoningMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = InvestigateStep;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.InvestigateStep")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<InvestigateStep, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut clues__ = None;
                let mut reasoning_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Clues => {
                            if clues__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Clues"));
                            }
                            clues__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::ReasoningMap => {
                            if reasoning_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReasoningMap"));
                            }
                            reasoning_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(InvestigateStep {
                    clues: clues__.unwrap_or_default(),
                    reasoning_map: reasoning_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.InvestigateStep", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Item {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if self.config_id.is_some() {
            len += 1;
        }
        if self.count.is_some() {
            len += 1;
        }
        if self.invalid.is_some() {
            len += 1;
        }
        if self.bind_flag.is_some() {
            len += 1;
        }
        if self.create_time.is_some() {
            len += 1;
        }
        if self.expire_time.is_some() {
            len += 1;
        }
        if self.opt_src.is_some() {
            len += 1;
        }
        if self.quality.is_some() {
            len += 1;
        }
        if self.equip_attr.is_some() {
            len += 1;
        }
        if self.mod_attr.is_some() {
            len += 1;
        }
        if self.cool_down_expire_time.is_some() {
            len += 1;
        }
        if self.mod_new_attr.is_some() {
            len += 1;
        }
        if self.affix_data.is_some() {
            len += 1;
        }
        if !self.extend_attr.is_empty() {
            len += 1;
        }
        if self.reward_id.is_some() {
            len += 1;
        }
        if !self.gene_sequence.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Item", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.config_id.as_ref() {
            struct_ser.serialize_field("ConfigId", v)?;
        }
        if let Some(v) = self.count.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Count", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.invalid.as_ref() {
            struct_ser.serialize_field("Invalid", v)?;
        }
        if let Some(v) = self.bind_flag.as_ref() {
            let v = EItemBindFlag::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("BindFlag", &v)?;
        }
        if let Some(v) = self.create_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CreateTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.expire_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ExpireTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.opt_src.as_ref() {
            struct_ser.serialize_field("OptSrc", v)?;
        }
        if let Some(v) = self.quality.as_ref() {
            struct_ser.serialize_field("Quality", v)?;
        }
        if let Some(v) = self.equip_attr.as_ref() {
            struct_ser.serialize_field("EquipAttr", v)?;
        }
        if let Some(v) = self.mod_attr.as_ref() {
            struct_ser.serialize_field("ModAttr", v)?;
        }
        if let Some(v) = self.cool_down_expire_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CoolDownExpireTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.mod_new_attr.as_ref() {
            struct_ser.serialize_field("ModNewAttr", v)?;
        }
        if let Some(v) = self.affix_data.as_ref() {
            struct_ser.serialize_field("AffixData", v)?;
        }
        if !self.extend_attr.is_empty() {
            struct_ser.serialize_field("ExtendAttr", &self.extend_attr)?;
        }
        if let Some(v) = self.reward_id.as_ref() {
            struct_ser.serialize_field("RewardId", v)?;
        }
        if !self.gene_sequence.is_empty() {
            struct_ser.serialize_field("GeneSequence", &self.gene_sequence)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Item {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "ConfigId",
            "Count",
            "Invalid",
            "BindFlag",
            "CreateTime",
            "ExpireTime",
            "OptSrc",
            "Quality",
            "EquipAttr",
            "ModAttr",
            "CoolDownExpireTime",
            "ModNewAttr",
            "AffixData",
            "ExtendAttr",
            "RewardId",
            "GeneSequence",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            ConfigId,
            Count,
            Invalid,
            BindFlag,
            CreateTime,
            ExpireTime,
            OptSrc,
            Quality,
            EquipAttr,
            ModAttr,
            CoolDownExpireTime,
            ModNewAttr,
            AffixData,
            ExtendAttr,
            RewardId,
            GeneSequence,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "ConfigId" => Ok(GeneratedField::ConfigId),
                            "Count" => Ok(GeneratedField::Count),
                            "Invalid" => Ok(GeneratedField::Invalid),
                            "BindFlag" => Ok(GeneratedField::BindFlag),
                            "CreateTime" => Ok(GeneratedField::CreateTime),
                            "ExpireTime" => Ok(GeneratedField::ExpireTime),
                            "OptSrc" => Ok(GeneratedField::OptSrc),
                            "Quality" => Ok(GeneratedField::Quality),
                            "EquipAttr" => Ok(GeneratedField::EquipAttr),
                            "ModAttr" => Ok(GeneratedField::ModAttr),
                            "CoolDownExpireTime" => Ok(GeneratedField::CoolDownExpireTime),
                            "ModNewAttr" => Ok(GeneratedField::ModNewAttr),
                            "AffixData" => Ok(GeneratedField::AffixData),
                            "ExtendAttr" => Ok(GeneratedField::ExtendAttr),
                            "RewardId" => Ok(GeneratedField::RewardId),
                            "GeneSequence" => Ok(GeneratedField::GeneSequence),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Item;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Item")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Item, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut config_id__ = None;
                let mut count__ = None;
                let mut invalid__ = None;
                let mut bind_flag__ = None;
                let mut create_time__ = None;
                let mut expire_time__ = None;
                let mut opt_src__ = None;
                let mut quality__ = None;
                let mut equip_attr__ = None;
                let mut mod_attr__ = None;
                let mut cool_down_expire_time__ = None;
                let mut mod_new_attr__ = None;
                let mut affix_data__ = None;
                let mut extend_attr__ = None;
                let mut reward_id__ = None;
                let mut gene_sequence__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ConfigId => {
                            if config_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConfigId"));
                            }
                            config_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Count"));
                            }
                            count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Invalid => {
                            if invalid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Invalid"));
                            }
                            invalid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BindFlag => {
                            if bind_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BindFlag"));
                            }
                            bind_flag__ = map_.next_value::<::std::option::Option<EItemBindFlag>>()?.map(|x| x as i32);
                        }
                        GeneratedField::CreateTime => {
                            if create_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateTime"));
                            }
                            create_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExpireTime => {
                            if expire_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExpireTime"));
                            }
                            expire_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OptSrc => {
                            if opt_src__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OptSrc"));
                            }
                            opt_src__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Quality => {
                            if quality__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Quality"));
                            }
                            quality__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EquipAttr => {
                            if equip_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipAttr"));
                            }
                            equip_attr__ = map_.next_value()?;
                        }
                        GeneratedField::ModAttr => {
                            if mod_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ModAttr"));
                            }
                            mod_attr__ = map_.next_value()?;
                        }
                        GeneratedField::CoolDownExpireTime => {
                            if cool_down_expire_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CoolDownExpireTime"));
                            }
                            cool_down_expire_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ModNewAttr => {
                            if mod_new_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ModNewAttr"));
                            }
                            mod_new_attr__ = map_.next_value()?;
                        }
                        GeneratedField::AffixData => {
                            if affix_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AffixData"));
                            }
                            affix_data__ = map_.next_value()?;
                        }
                        GeneratedField::ExtendAttr => {
                            if extend_attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExtendAttr"));
                            }
                            extend_attr__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::RewardId => {
                            if reward_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RewardId"));
                            }
                            reward_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GeneSequence => {
                            if gene_sequence__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GeneSequence"));
                            }
                            gene_sequence__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(Item {
                    uuid: uuid__,
                    config_id: config_id__,
                    count: count__,
                    invalid: invalid__,
                    bind_flag: bind_flag__,
                    create_time: create_time__,
                    expire_time: expire_time__,
                    opt_src: opt_src__,
                    quality: quality__,
                    equip_attr: equip_attr__,
                    mod_attr: mod_attr__,
                    cool_down_expire_time: cool_down_expire_time__,
                    mod_new_attr: mod_new_attr__,
                    affix_data: affix_data__,
                    extend_attr: extend_attr__.unwrap_or_default(),
                    reward_id: reward_id__,
                    gene_sequence: gene_sequence__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Item", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ItemCurrency {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_init.is_some() {
            len += 1;
        }
        if !self.currency_datas.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ItemCurrency", len)?;
        if let Some(v) = self.is_init.as_ref() {
            struct_ser.serialize_field("IsInit", v)?;
        }
        if !self.currency_datas.is_empty() {
            struct_ser.serialize_field("CurrencyDatas", &self.currency_datas)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ItemCurrency {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsInit",
            "CurrencyDatas",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsInit,
            CurrencyDatas,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsInit" => Ok(GeneratedField::IsInit),
                            "CurrencyDatas" => Ok(GeneratedField::CurrencyDatas),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ItemCurrency;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ItemCurrency")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ItemCurrency, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_init__ = None;
                let mut currency_datas__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsInit => {
                            if is_init__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsInit"));
                            }
                            is_init__ = map_.next_value()?;
                        }
                        GeneratedField::CurrencyDatas => {
                            if currency_datas__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurrencyDatas"));
                            }
                            currency_datas__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ItemCurrency {
                    is_init: is_init__,
                    currency_datas: currency_datas__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ItemCurrency", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ItemExtendData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ItemExtendData", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("Value", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ItemExtendData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ItemExtendData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ItemExtendData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ItemExtendData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Value"));
                            }
                            value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ItemExtendData {
                    id: id__,
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ItemExtendData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ItemPackage {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.packages.is_empty() {
            len += 1;
        }
        if !self.unlock_items.is_empty() {
            len += 1;
        }
        if self.quick_bar.is_some() {
            len += 1;
        }
        if self.item_uuid.is_some() {
            len += 1;
        }
        if !self.use_group_cd.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ItemPackage", len)?;
        if !self.packages.is_empty() {
            struct_ser.serialize_field("Packages", &self.packages)?;
        }
        if !self.unlock_items.is_empty() {
            struct_ser.serialize_field("UnlockItems", &self.unlock_items)?;
        }
        if let Some(v) = self.quick_bar.as_ref() {
            struct_ser.serialize_field("QuickBar", v)?;
        }
        if let Some(v) = self.item_uuid.as_ref() {
            struct_ser.serialize_field("ItemUuid", v)?;
        }
        if !self.use_group_cd.is_empty() {
            let v: std::collections::HashMap<_, _> = self.use_group_cd.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("UseGroupCd", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ItemPackage {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Packages",
            "UnlockItems",
            "QuickBar",
            "ItemUuid",
            "UseGroupCd",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Packages,
            UnlockItems,
            QuickBar,
            ItemUuid,
            UseGroupCd,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Packages" => Ok(GeneratedField::Packages),
                            "UnlockItems" => Ok(GeneratedField::UnlockItems),
                            "QuickBar" => Ok(GeneratedField::QuickBar),
                            "ItemUuid" => Ok(GeneratedField::ItemUuid),
                            "UseGroupCd" => Ok(GeneratedField::UseGroupCd),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ItemPackage;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ItemPackage")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ItemPackage, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut packages__ = None;
                let mut unlock_items__ = None;
                let mut quick_bar__ = None;
                let mut item_uuid__ = None;
                let mut use_group_cd__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Packages => {
                            if packages__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Packages"));
                            }
                            packages__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::UnlockItems => {
                            if unlock_items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockItems"));
                            }
                            unlock_items__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::QuickBar => {
                            if quick_bar__.is_some() {
                                return Err(serde::de::Error::duplicate_field("QuickBar"));
                            }
                            quick_bar__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ItemUuid => {
                            if item_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ItemUuid"));
                            }
                            item_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::UseGroupCd => {
                            if use_group_cd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UseGroupCd"));
                            }
                            use_group_cd__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(ItemPackage {
                    packages: packages__.unwrap_or_default(),
                    unlock_items: unlock_items__.unwrap_or_default(),
                    quick_bar: quick_bar__,
                    item_uuid: item_uuid__,
                    use_group_cd: use_group_cd__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ItemPackage", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LastSceneData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scene_id.is_some() {
            len += 1;
        }
        if self.pos.is_some() {
            len += 1;
        }
        if self.scene_area_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LastSceneData", len)?;
        if let Some(v) = self.scene_id.as_ref() {
            struct_ser.serialize_field("SceneId", v)?;
        }
        if let Some(v) = self.pos.as_ref() {
            struct_ser.serialize_field("Pos", v)?;
        }
        if let Some(v) = self.scene_area_id.as_ref() {
            struct_ser.serialize_field("SceneAreaId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LastSceneData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SceneId",
            "Pos",
            "SceneAreaId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SceneId,
            Pos,
            SceneAreaId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SceneId" => Ok(GeneratedField::SceneId),
                            "Pos" => Ok(GeneratedField::Pos),
                            "SceneAreaId" => Ok(GeneratedField::SceneAreaId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LastSceneData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LastSceneData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LastSceneData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_id__ = None;
                let mut pos__ = None;
                let mut scene_area_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SceneId => {
                            if scene_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneId"));
                            }
                            scene_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Pos => {
                            if pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Pos"));
                            }
                            pos__ = map_.next_value()?;
                        }
                        GeneratedField::SceneAreaId => {
                            if scene_area_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneAreaId"));
                            }
                            scene_area_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(LastSceneData {
                    scene_id: scene_id__,
                    pos: pos__,
                    scene_area_id: scene_area_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LastSceneData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LaunchPlatform {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Null => "LaunchPlatformNull",
            Self::WeXin => "LaunchPlatformWeXin",
            Self::Qq => "LaunchPlatformQq",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for LaunchPlatform {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LaunchPlatformNull",
            "LaunchPlatformWeXin",
            "LaunchPlatformQq",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LaunchPlatform;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "LaunchPlatformNull" => Ok(LaunchPlatform::Null),
                    "LaunchPlatformWeXin" => Ok(LaunchPlatform::WeXin),
                    "LaunchPlatformQq" => Ok(LaunchPlatform::Qq),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for LaunchPrivilegeData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.launch_platform.is_some() {
            len += 1;
        }
        if self.is_privilege.is_some() {
            len += 1;
        }
        if self.bak_launch_platform.is_some() {
            len += 1;
        }
        if self.bak_privilege.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LaunchPrivilegeData", len)?;
        if let Some(v) = self.launch_platform.as_ref() {
            let v = LaunchPlatform::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("LaunchPlatform", &v)?;
        }
        if let Some(v) = self.is_privilege.as_ref() {
            struct_ser.serialize_field("IsPrivilege", v)?;
        }
        if let Some(v) = self.bak_launch_platform.as_ref() {
            let v = LaunchPlatform::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("BakLaunchPlatform", &v)?;
        }
        if let Some(v) = self.bak_privilege.as_ref() {
            struct_ser.serialize_field("BakPrivilege", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LaunchPrivilegeData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LaunchPlatform",
            "IsPrivilege",
            "BakLaunchPlatform",
            "BakPrivilege",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LaunchPlatform,
            IsPrivilege,
            BakLaunchPlatform,
            BakPrivilege,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LaunchPlatform" => Ok(GeneratedField::LaunchPlatform),
                            "IsPrivilege" => Ok(GeneratedField::IsPrivilege),
                            "BakLaunchPlatform" => Ok(GeneratedField::BakLaunchPlatform),
                            "BakPrivilege" => Ok(GeneratedField::BakPrivilege),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LaunchPrivilegeData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LaunchPrivilegeData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LaunchPrivilegeData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut launch_platform__ = None;
                let mut is_privilege__ = None;
                let mut bak_launch_platform__ = None;
                let mut bak_privilege__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LaunchPlatform => {
                            if launch_platform__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LaunchPlatform"));
                            }
                            launch_platform__ = map_.next_value::<::std::option::Option<LaunchPlatform>>()?.map(|x| x as i32);
                        }
                        GeneratedField::IsPrivilege => {
                            if is_privilege__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsPrivilege"));
                            }
                            is_privilege__ = map_.next_value()?;
                        }
                        GeneratedField::BakLaunchPlatform => {
                            if bak_launch_platform__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BakLaunchPlatform"));
                            }
                            bak_launch_platform__ = map_.next_value::<::std::option::Option<LaunchPlatform>>()?.map(|x| x as i32);
                        }
                        GeneratedField::BakPrivilege => {
                            if bak_privilege__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BakPrivilege"));
                            }
                            bak_privilege__ = map_.next_value()?;
                        }
                    }
                }
                Ok(LaunchPrivilegeData {
                    launch_platform: launch_platform__,
                    is_privilege: is_privilege__,
                    bak_launch_platform: bak_launch_platform__,
                    bak_privilege: bak_privilege__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LaunchPrivilegeData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LearnExpressionAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.expression_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LearnExpressionAction", len)?;
        if let Some(v) = self.expression_id.as_ref() {
            struct_ser.serialize_field("ExpressionId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LearnExpressionAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ExpressionId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ExpressionId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ExpressionId" => Ok(GeneratedField::ExpressionId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LearnExpressionAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LearnExpressionAction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LearnExpressionAction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut expression_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ExpressionId => {
                            if expression_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExpressionId"));
                            }
                            expression_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(LearnExpressionAction {
                    expression_id: expression_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LearnExpressionAction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LevelProficiency {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.using_proficiency_map.is_empty() {
            len += 1;
        }
        if !self.unlock_proficiency_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LevelProficiency", len)?;
        if !self.using_proficiency_map.is_empty() {
            struct_ser.serialize_field("UsingProficiencyMap", &self.using_proficiency_map)?;
        }
        if !self.unlock_proficiency_map.is_empty() {
            struct_ser.serialize_field("UnlockProficiencyMap", &self.unlock_proficiency_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LevelProficiency {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UsingProficiencyMap",
            "UnlockProficiencyMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UsingProficiencyMap,
            UnlockProficiencyMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UsingProficiencyMap" => Ok(GeneratedField::UsingProficiencyMap),
                            "UnlockProficiencyMap" => Ok(GeneratedField::UnlockProficiencyMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LevelProficiency;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LevelProficiency")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LevelProficiency, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut using_proficiency_map__ = None;
                let mut unlock_proficiency_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UsingProficiencyMap => {
                            if using_proficiency_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UsingProficiencyMap"));
                            }
                            using_proficiency_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::UnlockProficiencyMap => {
                            if unlock_proficiency_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockProficiencyMap"));
                            }
                            unlock_proficiency_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(LevelProficiency {
                    using_proficiency_map: using_proficiency_map__.unwrap_or_default(),
                    unlock_proficiency_map: unlock_proficiency_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LevelProficiency", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LevelUpAward {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.drop_times.is_some() {
            len += 1;
        }
        if self.last_drop_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LevelUpAward", len)?;
        if let Some(v) = self.drop_times.as_ref() {
            struct_ser.serialize_field("DropTimes", v)?;
        }
        if let Some(v) = self.last_drop_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastDropTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LevelUpAward {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DropTimes",
            "LastDropTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DropTimes,
            LastDropTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DropTimes" => Ok(GeneratedField::DropTimes),
                            "LastDropTime" => Ok(GeneratedField::LastDropTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LevelUpAward;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LevelUpAward")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LevelUpAward, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut drop_times__ = None;
                let mut last_drop_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DropTimes => {
                            if drop_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DropTimes"));
                            }
                            drop_times__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastDropTime => {
                            if last_drop_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastDropTime"));
                            }
                            last_drop_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(LevelUpAward {
                    drop_times: drop_times__,
                    last_drop_time: last_drop_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LevelUpAward", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LifeProfession {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.profession_info.is_empty() {
            len += 1;
        }
        if !self.life_target_info.is_empty() {
            len += 1;
        }
        if !self.life_profession_recipe.is_empty() {
            len += 1;
        }
        if self.life_profession_alchemy_info.is_some() {
            len += 1;
        }
        if !self.spare_energy.is_empty() {
            len += 1;
        }
        if self.point.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LifeProfession", len)?;
        if !self.profession_info.is_empty() {
            struct_ser.serialize_field("ProfessionInfo", &self.profession_info)?;
        }
        if !self.life_target_info.is_empty() {
            struct_ser.serialize_field("LifeTargetInfo", &self.life_target_info)?;
        }
        if !self.life_profession_recipe.is_empty() {
            struct_ser.serialize_field("LifeProfessionRecipe", &self.life_profession_recipe)?;
        }
        if let Some(v) = self.life_profession_alchemy_info.as_ref() {
            struct_ser.serialize_field("LifeProfessionAlchemyInfo", v)?;
        }
        if !self.spare_energy.is_empty() {
            struct_ser.serialize_field("SpareEnergy", &self.spare_energy)?;
        }
        if let Some(v) = self.point.as_ref() {
            struct_ser.serialize_field("Point", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LifeProfession {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ProfessionInfo",
            "LifeTargetInfo",
            "LifeProfessionRecipe",
            "LifeProfessionAlchemyInfo",
            "SpareEnergy",
            "Point",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ProfessionInfo,
            LifeTargetInfo,
            LifeProfessionRecipe,
            LifeProfessionAlchemyInfo,
            SpareEnergy,
            Point,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ProfessionInfo" => Ok(GeneratedField::ProfessionInfo),
                            "LifeTargetInfo" => Ok(GeneratedField::LifeTargetInfo),
                            "LifeProfessionRecipe" => Ok(GeneratedField::LifeProfessionRecipe),
                            "LifeProfessionAlchemyInfo" => Ok(GeneratedField::LifeProfessionAlchemyInfo),
                            "SpareEnergy" => Ok(GeneratedField::SpareEnergy),
                            "Point" => Ok(GeneratedField::Point),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LifeProfession;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LifeProfession")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LifeProfession, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut profession_info__ = None;
                let mut life_target_info__ = None;
                let mut life_profession_recipe__ = None;
                let mut life_profession_alchemy_info__ = None;
                let mut spare_energy__ = None;
                let mut point__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ProfessionInfo => {
                            if profession_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfessionInfo"));
                            }
                            profession_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::LifeTargetInfo => {
                            if life_target_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LifeTargetInfo"));
                            }
                            life_target_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::LifeProfessionRecipe => {
                            if life_profession_recipe__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LifeProfessionRecipe"));
                            }
                            life_profession_recipe__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::LifeProfessionAlchemyInfo => {
                            if life_profession_alchemy_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LifeProfessionAlchemyInfo"));
                            }
                            life_profession_alchemy_info__ = map_.next_value()?;
                        }
                        GeneratedField::SpareEnergy => {
                            if spare_energy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SpareEnergy"));
                            }
                            spare_energy__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::Point => {
                            if point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Point"));
                            }
                            point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(LifeProfession {
                    profession_info: profession_info__.unwrap_or_default(),
                    life_target_info: life_target_info__.unwrap_or_default(),
                    life_profession_recipe: life_profession_recipe__.unwrap_or_default(),
                    life_profession_alchemy_info: life_profession_alchemy_info__,
                    spare_energy: spare_energy__.unwrap_or_default(),
                    point: point__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LifeProfession", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LifeProfessionAlchemyInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.failure_count.is_some() {
            len += 1;
        }
        if self.rd_count.is_some() {
            len += 1;
        }
        if self.last_reset_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LifeProfessionAlchemyInfo", len)?;
        if let Some(v) = self.failure_count.as_ref() {
            struct_ser.serialize_field("FailureCount", v)?;
        }
        if let Some(v) = self.rd_count.as_ref() {
            struct_ser.serialize_field("RdCount", v)?;
        }
        if let Some(v) = self.last_reset_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastResetTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LifeProfessionAlchemyInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FailureCount",
            "RdCount",
            "LastResetTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FailureCount,
            RdCount,
            LastResetTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FailureCount" => Ok(GeneratedField::FailureCount),
                            "RdCount" => Ok(GeneratedField::RdCount),
                            "LastResetTime" => Ok(GeneratedField::LastResetTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LifeProfessionAlchemyInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LifeProfessionAlchemyInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LifeProfessionAlchemyInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut failure_count__ = None;
                let mut rd_count__ = None;
                let mut last_reset_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FailureCount => {
                            if failure_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FailureCount"));
                            }
                            failure_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RdCount => {
                            if rd_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RdCount"));
                            }
                            rd_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastResetTime => {
                            if last_reset_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastResetTime"));
                            }
                            last_reset_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(LifeProfessionAlchemyInfo {
                    failure_count: failure_count__,
                    rd_count: rd_count__,
                    last_reset_time: last_reset_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LifeProfessionAlchemyInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LifeProfessionBasic {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        if self.exp.is_some() {
            len += 1;
        }
        if !self.specialization.is_empty() {
            len += 1;
        }
        if self.current_specialization_point.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LifeProfessionBasic", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if let Some(v) = self.exp.as_ref() {
            struct_ser.serialize_field("Exp", v)?;
        }
        if !self.specialization.is_empty() {
            struct_ser.serialize_field("Specialization", &self.specialization)?;
        }
        if let Some(v) = self.current_specialization_point.as_ref() {
            struct_ser.serialize_field("CurrentSpecializationPoint", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LifeProfessionBasic {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Level",
            "Exp",
            "Specialization",
            "CurrentSpecializationPoint",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Level,
            Exp,
            Specialization,
            CurrentSpecializationPoint,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Level" => Ok(GeneratedField::Level),
                            "Exp" => Ok(GeneratedField::Exp),
                            "Specialization" => Ok(GeneratedField::Specialization),
                            "CurrentSpecializationPoint" => Ok(GeneratedField::CurrentSpecializationPoint),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LifeProfessionBasic;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LifeProfessionBasic")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LifeProfessionBasic, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut level__ = None;
                let mut exp__ = None;
                let mut specialization__ = None;
                let mut current_specialization_point__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Exp => {
                            if exp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Exp"));
                            }
                            exp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Specialization => {
                            if specialization__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Specialization"));
                            }
                            specialization__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::CurrentSpecializationPoint => {
                            if current_specialization_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurrentSpecializationPoint"));
                            }
                            current_specialization_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(LifeProfessionBasic {
                    id: id__,
                    level: level__,
                    exp: exp__,
                    specialization: specialization__.unwrap_or_default(),
                    current_specialization_point: current_specialization_point__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LifeProfessionBasic", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LifeProfessionRecipe {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.unlock_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LifeProfessionRecipe", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.unlock_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("UnlockTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LifeProfessionRecipe {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "UnlockTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            UnlockTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "UnlockTime" => Ok(GeneratedField::UnlockTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LifeProfessionRecipe;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LifeProfessionRecipe")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LifeProfessionRecipe, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut unlock_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::UnlockTime => {
                            if unlock_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockTime"));
                            }
                            unlock_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(LifeProfessionRecipe {
                    id: id__,
                    unlock_time: unlock_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LifeProfessionRecipe", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LifeProfessionTargetInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        if !self.life_target_reward_states.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LifeProfessionTargetInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("Value", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if !self.life_target_reward_states.is_empty() {
            struct_ser.serialize_field("LifeTargetRewardStates", &self.life_target_reward_states)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LifeProfessionTargetInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Value",
            "Level",
            "LifeTargetRewardStates",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Value,
            Level,
            LifeTargetRewardStates,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Value" => Ok(GeneratedField::Value),
                            "Level" => Ok(GeneratedField::Level),
                            "LifeTargetRewardStates" => Ok(GeneratedField::LifeTargetRewardStates),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LifeProfessionTargetInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LifeProfessionTargetInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LifeProfessionTargetInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut value__ = None;
                let mut level__ = None;
                let mut life_target_reward_states__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Value"));
                            }
                            value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LifeTargetRewardStates => {
                            if life_target_reward_states__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LifeTargetRewardStates"));
                            }
                            life_target_reward_states__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(LifeProfessionTargetInfo {
                    id: id__,
                    value: value__,
                    level: level__,
                    life_target_reward_states: life_target_reward_states__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LifeProfessionTargetInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LifeProfessionWork {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.life_profession_work_info.is_some() {
            len += 1;
        }
        if !self.life_profession_work_history_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LifeProfessionWork", len)?;
        if let Some(v) = self.life_profession_work_info.as_ref() {
            struct_ser.serialize_field("LifeProfessionWorkInfo", v)?;
        }
        if !self.life_profession_work_history_info.is_empty() {
            struct_ser.serialize_field("LifeProfessionWorkHistoryInfo", &self.life_profession_work_history_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LifeProfessionWork {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LifeProfessionWorkInfo",
            "LifeProfessionWorkHistoryInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LifeProfessionWorkInfo,
            LifeProfessionWorkHistoryInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LifeProfessionWorkInfo" => Ok(GeneratedField::LifeProfessionWorkInfo),
                            "LifeProfessionWorkHistoryInfo" => Ok(GeneratedField::LifeProfessionWorkHistoryInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LifeProfessionWork;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LifeProfessionWork")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LifeProfessionWork, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut life_profession_work_info__ = None;
                let mut life_profession_work_history_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LifeProfessionWorkInfo => {
                            if life_profession_work_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LifeProfessionWorkInfo"));
                            }
                            life_profession_work_info__ = map_.next_value()?;
                        }
                        GeneratedField::LifeProfessionWorkHistoryInfo => {
                            if life_profession_work_history_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LifeProfessionWorkHistoryInfo"));
                            }
                            life_profession_work_history_info__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(LifeProfessionWork {
                    life_profession_work_info: life_profession_work_info__,
                    life_profession_work_history_info: life_profession_work_history_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LifeProfessionWork", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LifeProfessionWorkInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.life_profession_id.is_some() {
            len += 1;
        }
        if self.begin_time.is_some() {
            len += 1;
        }
        if self.end_time.is_some() {
            len += 1;
        }
        if self.count.is_some() {
            len += 1;
        }
        if self.cost.is_some() {
            len += 1;
        }
        if !self.reward.is_empty() {
            len += 1;
        }
        if self.cost_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LifeProfessionWorkInfo", len)?;
        if let Some(v) = self.life_profession_id.as_ref() {
            struct_ser.serialize_field("LifeProfessionId", v)?;
        }
        if let Some(v) = self.begin_time.as_ref() {
            struct_ser.serialize_field("BeginTime", v)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            struct_ser.serialize_field("EndTime", v)?;
        }
        if let Some(v) = self.count.as_ref() {
            struct_ser.serialize_field("Count", v)?;
        }
        if let Some(v) = self.cost.as_ref() {
            struct_ser.serialize_field("Cost", v)?;
        }
        if !self.reward.is_empty() {
            struct_ser.serialize_field("Reward", &self.reward)?;
        }
        if let Some(v) = self.cost_id.as_ref() {
            struct_ser.serialize_field("CostId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LifeProfessionWorkInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LifeProfessionId",
            "BeginTime",
            "EndTime",
            "Count",
            "Cost",
            "Reward",
            "CostId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LifeProfessionId,
            BeginTime,
            EndTime,
            Count,
            Cost,
            Reward,
            CostId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LifeProfessionId" => Ok(GeneratedField::LifeProfessionId),
                            "BeginTime" => Ok(GeneratedField::BeginTime),
                            "EndTime" => Ok(GeneratedField::EndTime),
                            "Count" => Ok(GeneratedField::Count),
                            "Cost" => Ok(GeneratedField::Cost),
                            "Reward" => Ok(GeneratedField::Reward),
                            "CostId" => Ok(GeneratedField::CostId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LifeProfessionWorkInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LifeProfessionWorkInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LifeProfessionWorkInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut life_profession_id__ = None;
                let mut begin_time__ = None;
                let mut end_time__ = None;
                let mut count__ = None;
                let mut cost__ = None;
                let mut reward__ = None;
                let mut cost_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LifeProfessionId => {
                            if life_profession_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LifeProfessionId"));
                            }
                            life_profession_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BeginTime => {
                            if begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeginTime"));
                            }
                            begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EndTime"));
                            }
                            end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Count"));
                            }
                            count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Cost => {
                            if cost__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Cost"));
                            }
                            cost__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Reward => {
                            if reward__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Reward"));
                            }
                            reward__ = Some(map_.next_value()?);
                        }
                        GeneratedField::CostId => {
                            if cost_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CostId"));
                            }
                            cost_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(LifeProfessionWorkInfo {
                    life_profession_id: life_profession_id__,
                    begin_time: begin_time__,
                    end_time: end_time__,
                    count: count__,
                    cost: cost__,
                    reward: reward__.unwrap_or_default(),
                    cost_id: cost_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LifeProfessionWorkInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LiftProfessionSpecialization {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LiftProfessionSpecialization", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LiftProfessionSpecialization {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Level",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Level,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Level" => Ok(GeneratedField::Level),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LiftProfessionSpecialization;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LiftProfessionSpecialization")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LiftProfessionSpecialization, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut level__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(LiftProfessionSpecialization {
                    id: id__,
                    level: level__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LiftProfessionSpecialization", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LineDrawing {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.lines.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LineDrawing", len)?;
        if let Some(v) = self.lines.as_ref() {
            struct_ser.serialize_field("Lines", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LineDrawing {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Lines",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Lines,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Lines" => Ok(GeneratedField::Lines),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LineDrawing;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LineDrawing")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LineDrawing, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut lines__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Lines => {
                            if lines__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Lines"));
                            }
                            lines__ = map_.next_value()?;
                        }
                    }
                }
                Ok(LineDrawing {
                    lines: lines__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LineDrawing", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LinkingInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_delete.is_some() {
            len += 1;
        }
        if self.effectid.is_some() {
            len += 1;
        }
        if self.buff_uuid.is_some() {
            len += 1;
        }
        if !self.target_uuids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LinkingInfo", len)?;
        if let Some(v) = self.is_delete.as_ref() {
            struct_ser.serialize_field("IsDelete", v)?;
        }
        if let Some(v) = self.effectid.as_ref() {
            struct_ser.serialize_field("Effectid", v)?;
        }
        if let Some(v) = self.buff_uuid.as_ref() {
            struct_ser.serialize_field("BuffUuid", v)?;
        }
        if !self.target_uuids.is_empty() {
            struct_ser.serialize_field("TargetUuids", &self.target_uuids)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LinkingInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsDelete",
            "Effectid",
            "BuffUuid",
            "TargetUuids",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsDelete,
            Effectid,
            BuffUuid,
            TargetUuids,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsDelete" => Ok(GeneratedField::IsDelete),
                            "Effectid" => Ok(GeneratedField::Effectid),
                            "BuffUuid" => Ok(GeneratedField::BuffUuid),
                            "TargetUuids" => Ok(GeneratedField::TargetUuids),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LinkingInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LinkingInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LinkingInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_delete__ = None;
                let mut effectid__ = None;
                let mut buff_uuid__ = None;
                let mut target_uuids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsDelete => {
                            if is_delete__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsDelete"));
                            }
                            is_delete__ = map_.next_value()?;
                        }
                        GeneratedField::Effectid => {
                            if effectid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Effectid"));
                            }
                            effectid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BuffUuid => {
                            if buff_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffUuid"));
                            }
                            buff_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetUuids => {
                            if target_uuids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuids"));
                            }
                            target_uuids__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(LinkingInfo {
                    is_delete: is_delete__,
                    effectid: effectid__,
                    buff_uuid: buff_uuid__,
                    target_uuids: target_uuids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LinkingInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LoadMapSuccess {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LoadMapSuccess", len)?;
        if let Some(v) = self.v_param.as_ref() {
            struct_ser.serialize_field("VParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LoadMapSuccess {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VParam" => Ok(GeneratedField::VParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LoadMapSuccess;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LoadMapSuccess")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LoadMapSuccess, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VParam => {
                            if v_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VParam"));
                            }
                            v_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(LoadMapSuccess {
                    v_param: v_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LoadMapSuccess", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LoadMapSuccessParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scene_guid.is_some() {
            len += 1;
        }
        if self.aoi_sync_count.is_some() {
            len += 1;
        }
        if self.connect_guid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LoadMapSuccessParam", len)?;
        if let Some(v) = self.scene_guid.as_ref() {
            struct_ser.serialize_field("SceneGuid", v)?;
        }
        if let Some(v) = self.aoi_sync_count.as_ref() {
            struct_ser.serialize_field("AoiSyncCount", v)?;
        }
        if let Some(v) = self.connect_guid.as_ref() {
            struct_ser.serialize_field("ConnectGuid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LoadMapSuccessParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SceneGuid",
            "AoiSyncCount",
            "ConnectGuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SceneGuid,
            AoiSyncCount,
            ConnectGuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SceneGuid" => Ok(GeneratedField::SceneGuid),
                            "AoiSyncCount" => Ok(GeneratedField::AoiSyncCount),
                            "ConnectGuid" => Ok(GeneratedField::ConnectGuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LoadMapSuccessParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LoadMapSuccessParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LoadMapSuccessParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_guid__ = None;
                let mut aoi_sync_count__ = None;
                let mut connect_guid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SceneGuid => {
                            if scene_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneGuid"));
                            }
                            scene_guid__ = map_.next_value()?;
                        }
                        GeneratedField::AoiSyncCount => {
                            if aoi_sync_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AoiSyncCount"));
                            }
                            aoi_sync_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ConnectGuid => {
                            if connect_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConnectGuid"));
                            }
                            connect_guid__ = map_.next_value()?;
                        }
                    }
                }
                Ok(LoadMapSuccessParam {
                    scene_guid: scene_guid__,
                    aoi_sync_count: aoi_sync_count__,
                    connect_guid: connect_guid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LoadMapSuccessParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LuaSceneAttrReply {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.attr.is_some() {
            len += 1;
        }
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LuaSceneAttrReply", len)?;
        if let Some(v) = self.attr.as_ref() {
            struct_ser.serialize_field("Attr", v)?;
        }
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LuaSceneAttrReply {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Attr",
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Attr,
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Attr" => Ok(GeneratedField::Attr),
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LuaSceneAttrReply;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LuaSceneAttrReply")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LuaSceneAttrReply, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut attr__ = None;
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Attr => {
                            if attr__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Attr"));
                            }
                            attr__ = map_.next_value()?;
                        }
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(LuaSceneAttrReply {
                    attr: attr__,
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LuaSceneAttrReply", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LuckyValueInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.luck_id.is_some() {
            len += 1;
        }
        if self.luck_value.is_some() {
            len += 1;
        }
        if self.next_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LuckyValueInfo", len)?;
        if let Some(v) = self.luck_id.as_ref() {
            struct_ser.serialize_field("LuckId", v)?;
        }
        if let Some(v) = self.luck_value.as_ref() {
            struct_ser.serialize_field("LuckValue", v)?;
        }
        if let Some(v) = self.next_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("NextTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LuckyValueInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LuckId",
            "LuckValue",
            "NextTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LuckId,
            LuckValue,
            NextTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LuckId" => Ok(GeneratedField::LuckId),
                            "LuckValue" => Ok(GeneratedField::LuckValue),
                            "NextTime" => Ok(GeneratedField::NextTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LuckyValueInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LuckyValueInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LuckyValueInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut luck_id__ = None;
                let mut luck_value__ = None;
                let mut next_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LuckId => {
                            if luck_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LuckId"));
                            }
                            luck_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LuckValue => {
                            if luck_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LuckValue"));
                            }
                            luck_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextTime => {
                            if next_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NextTime"));
                            }
                            next_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(LuckyValueInfo {
                    luck_id: luck_id__,
                    luck_value: luck_value__,
                    next_time: next_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LuckyValueInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LuckyValueMgr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.luck_value_info.is_empty() {
            len += 1;
        }
        if self.init_value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.LuckyValueMgr", len)?;
        if !self.luck_value_info.is_empty() {
            struct_ser.serialize_field("LuckValueInfo", &self.luck_value_info)?;
        }
        if let Some(v) = self.init_value.as_ref() {
            struct_ser.serialize_field("InitValue", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LuckyValueMgr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LuckValueInfo",
            "InitValue",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LuckValueInfo,
            InitValue,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LuckValueInfo" => Ok(GeneratedField::LuckValueInfo),
                            "InitValue" => Ok(GeneratedField::InitValue),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LuckyValueMgr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.LuckyValueMgr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LuckyValueMgr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut luck_value_info__ = None;
                let mut init_value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LuckValueInfo => {
                            if luck_value_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LuckValueInfo"));
                            }
                            luck_value_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::InitValue => {
                            if init_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InitValue"));
                            }
                            init_value__ = map_.next_value()?;
                        }
                    }
                }
                Ok(LuckyValueMgr {
                    luck_value_info: luck_value_info__.unwrap_or_default(),
                    init_value: init_value__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.LuckyValueMgr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MagneticQueueAppearInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.passenger_uuid_list.is_empty() {
            len += 1;
        }
        if self.is_circle.is_some() {
            len += 1;
        }
        if self.path_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MagneticQueueAppearInfo", len)?;
        if !self.passenger_uuid_list.is_empty() {
            struct_ser.serialize_field("PassengerUuidList", &self.passenger_uuid_list.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if let Some(v) = self.is_circle.as_ref() {
            struct_ser.serialize_field("IsCircle", v)?;
        }
        if let Some(v) = self.path_length.as_ref() {
            struct_ser.serialize_field("PathLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MagneticQueueAppearInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PassengerUuidList",
            "IsCircle",
            "PathLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PassengerUuidList,
            IsCircle,
            PathLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PassengerUuidList" => Ok(GeneratedField::PassengerUuidList),
                            "IsCircle" => Ok(GeneratedField::IsCircle),
                            "PathLength" => Ok(GeneratedField::PathLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MagneticQueueAppearInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MagneticQueueAppearInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MagneticQueueAppearInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut passenger_uuid_list__ = None;
                let mut is_circle__ = None;
                let mut path_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PassengerUuidList => {
                            if passenger_uuid_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PassengerUuidList"));
                            }
                            passenger_uuid_list__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::IsCircle => {
                            if is_circle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsCircle"));
                            }
                            is_circle__ = map_.next_value()?;
                        }
                        GeneratedField::PathLength => {
                            if path_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PathLength"));
                            }
                            path_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MagneticQueueAppearInfo {
                    passenger_uuid_list: passenger_uuid_list__.unwrap_or_default(),
                    is_circle: is_circle__,
                    path_length: path_length__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MagneticQueueAppearInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MagneticRidePassengerChangeInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.passenger_change_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MagneticRidePassengerChangeInfo", len)?;
        if !self.passenger_change_list.is_empty() {
            struct_ser.serialize_field("PassengerChangeList", &self.passenger_change_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MagneticRidePassengerChangeInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PassengerChangeList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PassengerChangeList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PassengerChangeList" => Ok(GeneratedField::PassengerChangeList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MagneticRidePassengerChangeInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MagneticRidePassengerChangeInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MagneticRidePassengerChangeInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut passenger_change_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PassengerChangeList => {
                            if passenger_change_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PassengerChangeList"));
                            }
                            passenger_change_list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MagneticRidePassengerChangeInfo {
                    passenger_change_list: passenger_change_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MagneticRidePassengerChangeInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MagneticRidePathPointChangeInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.path_point_change_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MagneticRidePathPointChangeInfo", len)?;
        if !self.path_point_change_list.is_empty() {
            struct_ser.serialize_field("PathPointChangeList", &self.path_point_change_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MagneticRidePathPointChangeInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PathPointChangeList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PathPointChangeList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PathPointChangeList" => Ok(GeneratedField::PathPointChangeList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MagneticRidePathPointChangeInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MagneticRidePathPointChangeInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MagneticRidePathPointChangeInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut path_point_change_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PathPointChangeList => {
                            if path_point_change_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PathPointChangeList"));
                            }
                            path_point_change_list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MagneticRidePathPointChangeInfo {
                    path_point_change_list: path_point_change_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MagneticRidePathPointChangeInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MagneticRideQueueChangeInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.queue_uuid.is_some() {
            len += 1;
        }
        if self.passenger_change_info.is_some() {
            len += 1;
        }
        if self.path_point_change_info.is_some() {
            len += 1;
        }
        if self.is_circle.is_some() {
            len += 1;
        }
        if self.is_remove.is_some() {
            len += 1;
        }
        if self.path_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MagneticRideQueueChangeInfo", len)?;
        if let Some(v) = self.queue_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("QueueUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.passenger_change_info.as_ref() {
            struct_ser.serialize_field("PassengerChangeInfo", v)?;
        }
        if let Some(v) = self.path_point_change_info.as_ref() {
            struct_ser.serialize_field("PathPointChangeInfo", v)?;
        }
        if let Some(v) = self.is_circle.as_ref() {
            struct_ser.serialize_field("IsCircle", v)?;
        }
        if let Some(v) = self.is_remove.as_ref() {
            struct_ser.serialize_field("IsRemove", v)?;
        }
        if let Some(v) = self.path_length.as_ref() {
            struct_ser.serialize_field("PathLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MagneticRideQueueChangeInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "QueueUuid",
            "PassengerChangeInfo",
            "PathPointChangeInfo",
            "IsCircle",
            "IsRemove",
            "PathLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            QueueUuid,
            PassengerChangeInfo,
            PathPointChangeInfo,
            IsCircle,
            IsRemove,
            PathLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "QueueUuid" => Ok(GeneratedField::QueueUuid),
                            "PassengerChangeInfo" => Ok(GeneratedField::PassengerChangeInfo),
                            "PathPointChangeInfo" => Ok(GeneratedField::PathPointChangeInfo),
                            "IsCircle" => Ok(GeneratedField::IsCircle),
                            "IsRemove" => Ok(GeneratedField::IsRemove),
                            "PathLength" => Ok(GeneratedField::PathLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MagneticRideQueueChangeInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MagneticRideQueueChangeInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MagneticRideQueueChangeInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut queue_uuid__ = None;
                let mut passenger_change_info__ = None;
                let mut path_point_change_info__ = None;
                let mut is_circle__ = None;
                let mut is_remove__ = None;
                let mut path_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::QueueUuid => {
                            if queue_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("QueueUuid"));
                            }
                            queue_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PassengerChangeInfo => {
                            if passenger_change_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PassengerChangeInfo"));
                            }
                            passenger_change_info__ = map_.next_value()?;
                        }
                        GeneratedField::PathPointChangeInfo => {
                            if path_point_change_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PathPointChangeInfo"));
                            }
                            path_point_change_info__ = map_.next_value()?;
                        }
                        GeneratedField::IsCircle => {
                            if is_circle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsCircle"));
                            }
                            is_circle__ = map_.next_value()?;
                        }
                        GeneratedField::IsRemove => {
                            if is_remove__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsRemove"));
                            }
                            is_remove__ = map_.next_value()?;
                        }
                        GeneratedField::PathLength => {
                            if path_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PathLength"));
                            }
                            path_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MagneticRideQueueChangeInfo {
                    queue_uuid: queue_uuid__,
                    passenger_change_info: passenger_change_info__,
                    path_point_change_info: path_point_change_info__,
                    is_circle: is_circle__,
                    is_remove: is_remove__,
                    path_length: path_length__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MagneticRideQueueChangeInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MailClaimedInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.attachment_mail_list.is_empty() {
            len += 1;
        }
        if !self.claimed_mails.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MailClaimedInfo", len)?;
        if !self.attachment_mail_list.is_empty() {
            struct_ser.serialize_field("AttachmentMailList", &self.attachment_mail_list.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if !self.claimed_mails.is_empty() {
            let v: std::collections::HashMap<_, _> = self.claimed_mails.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("ClaimedMails", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MailClaimedInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AttachmentMailList",
            "ClaimedMails",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AttachmentMailList,
            ClaimedMails,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AttachmentMailList" => Ok(GeneratedField::AttachmentMailList),
                            "ClaimedMails" => Ok(GeneratedField::ClaimedMails),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MailClaimedInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MailClaimedInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MailClaimedInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut attachment_mail_list__ = None;
                let mut claimed_mails__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AttachmentMailList => {
                            if attachment_mail_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AttachmentMailList"));
                            }
                            attachment_mail_list__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::ClaimedMails => {
                            if claimed_mails__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ClaimedMails"));
                            }
                            claimed_mails__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(MailClaimedInfo {
                    attachment_mail_list: attachment_mail_list__.unwrap_or_default(),
                    claimed_mails: claimed_mails__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MailClaimedInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MapAttr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_clear.is_some() {
            len += 1;
        }
        if self.id.is_some() {
            len += 1;
        }
        if !self.attrs.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MapAttr", len)?;
        if let Some(v) = self.is_clear.as_ref() {
            struct_ser.serialize_field("IsClear", v)?;
        }
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if !self.attrs.is_empty() {
            struct_ser.serialize_field("Attrs", &self.attrs)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MapAttr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsClear",
            "Id",
            "Attrs",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsClear,
            Id,
            Attrs,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsClear" => Ok(GeneratedField::IsClear),
                            "Id" => Ok(GeneratedField::Id),
                            "Attrs" => Ok(GeneratedField::Attrs),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MapAttr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MapAttr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MapAttr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_clear__ = None;
                let mut id__ = None;
                let mut attrs__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsClear => {
                            if is_clear__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsClear"));
                            }
                            is_clear__ = map_.next_value()?;
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Attrs => {
                            if attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Attrs"));
                            }
                            attrs__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(MapAttr {
                    is_clear: is_clear__,
                    id: id__,
                    attrs: attrs__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MapAttr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MapAttrValue {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_remove.is_some() {
            len += 1;
        }
        if self.key.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MapAttrValue", len)?;
        if let Some(v) = self.is_remove.as_ref() {
            struct_ser.serialize_field("IsRemove", v)?;
        }
        if let Some(v) = self.key.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Key", pbjson::private::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.value.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Value", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MapAttrValue {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsRemove",
            "Key",
            "Value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsRemove,
            Key,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsRemove" => Ok(GeneratedField::IsRemove),
                            "Key" => Ok(GeneratedField::Key),
                            "Value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MapAttrValue;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MapAttrValue")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MapAttrValue, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_remove__ = None;
                let mut key__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsRemove => {
                            if is_remove__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsRemove"));
                            }
                            is_remove__ = map_.next_value()?;
                        }
                        GeneratedField::Key => {
                            if key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Key"));
                            }
                            key__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Value"));
                            }
                            value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MapAttrValue {
                    is_remove: is_remove__,
                    key: key__,
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MapAttrValue", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MapBookInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if !self.map_sticker_map.is_empty() {
            len += 1;
        }
        if self.award_flag.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MapBookInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if !self.map_sticker_map.is_empty() {
            struct_ser.serialize_field("MapStickerMap", &self.map_sticker_map)?;
        }
        if let Some(v) = self.award_flag.as_ref() {
            struct_ser.serialize_field("AwardFlag", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MapBookInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "MapStickerMap",
            "AwardFlag",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            MapStickerMap,
            AwardFlag,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "MapStickerMap" => Ok(GeneratedField::MapStickerMap),
                            "AwardFlag" => Ok(GeneratedField::AwardFlag),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MapBookInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MapBookInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MapBookInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut map_sticker_map__ = None;
                let mut award_flag__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MapStickerMap => {
                            if map_sticker_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MapStickerMap"));
                            }
                            map_sticker_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::AwardFlag => {
                            if award_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardFlag"));
                            }
                            award_flag__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MapBookInfo {
                    id: id__,
                    map_sticker_map: map_sticker_map__.unwrap_or_default(),
                    award_flag: award_flag__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MapBookInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MapBookInfoList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.map_book_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MapBookInfoList", len)?;
        if !self.map_book_map.is_empty() {
            struct_ser.serialize_field("MapBookMap", &self.map_book_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MapBookInfoList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MapBookMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MapBookMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MapBookMap" => Ok(GeneratedField::MapBookMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MapBookInfoList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MapBookInfoList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MapBookInfoList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut map_book_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MapBookMap => {
                            if map_book_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MapBookMap"));
                            }
                            map_book_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(MapBookInfoList {
                    map_book_map: map_book_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MapBookInfoList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MapData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.mark_data_map.is_empty() {
            len += 1;
        }
        if !self.ares_map.is_empty() {
            len += 1;
        }
        if self.mark_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MapData", len)?;
        if !self.mark_data_map.is_empty() {
            struct_ser.serialize_field("MarkDataMap", &self.mark_data_map)?;
        }
        if !self.ares_map.is_empty() {
            struct_ser.serialize_field("AresMap", &self.ares_map)?;
        }
        if let Some(v) = self.mark_uuid.as_ref() {
            struct_ser.serialize_field("MarkUuid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MapData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MarkDataMap",
            "AresMap",
            "MarkUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MarkDataMap,
            AresMap,
            MarkUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MarkDataMap" => Ok(GeneratedField::MarkDataMap),
                            "AresMap" => Ok(GeneratedField::AresMap),
                            "MarkUuid" => Ok(GeneratedField::MarkUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MapData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MapData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MapData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut mark_data_map__ = None;
                let mut ares_map__ = None;
                let mut mark_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MarkDataMap => {
                            if mark_data_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MarkDataMap"));
                            }
                            mark_data_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::AresMap => {
                            if ares_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AresMap"));
                            }
                            ares_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::MarkUuid => {
                            if mark_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MarkUuid"));
                            }
                            mark_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MapData {
                    mark_data_map: mark_data_map__.unwrap_or_default(),
                    ares_map: ares_map__.unwrap_or_default(),
                    mark_uuid: mark_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MapData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MapStickerInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sticker_map.is_empty() {
            len += 1;
        }
        if !self.finish_map.is_empty() {
            len += 1;
        }
        if self.award_flag.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MapStickerInfo", len)?;
        if !self.sticker_map.is_empty() {
            struct_ser.serialize_field("StickerMap", &self.sticker_map)?;
        }
        if !self.finish_map.is_empty() {
            struct_ser.serialize_field("FinishMap", &self.finish_map)?;
        }
        if let Some(v) = self.award_flag.as_ref() {
            struct_ser.serialize_field("AwardFlag", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MapStickerInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "StickerMap",
            "FinishMap",
            "AwardFlag",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StickerMap,
            FinishMap,
            AwardFlag,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "StickerMap" => Ok(GeneratedField::StickerMap),
                            "FinishMap" => Ok(GeneratedField::FinishMap),
                            "AwardFlag" => Ok(GeneratedField::AwardFlag),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MapStickerInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MapStickerInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MapStickerInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sticker_map__ = None;
                let mut finish_map__ = None;
                let mut award_flag__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StickerMap => {
                            if sticker_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StickerMap"));
                            }
                            sticker_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::FinishMap => {
                            if finish_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FinishMap"));
                            }
                            finish_map__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::AwardFlag => {
                            if award_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardFlag"));
                            }
                            award_flag__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MapStickerInfo {
                    sticker_map: sticker_map__.unwrap_or_default(),
                    finish_map: finish_map__.unwrap_or_default(),
                    award_flag: award_flag__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MapStickerInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MapStickerTaskInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.task_id.is_some() {
            len += 1;
        }
        if !self.target_num.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MapStickerTaskInfo", len)?;
        if let Some(v) = self.task_id.as_ref() {
            struct_ser.serialize_field("TaskId", v)?;
        }
        if !self.target_num.is_empty() {
            struct_ser.serialize_field("TargetNum", &self.target_num)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MapStickerTaskInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TaskId",
            "TargetNum",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TaskId,
            TargetNum,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TaskId" => Ok(GeneratedField::TaskId),
                            "TargetNum" => Ok(GeneratedField::TargetNum),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MapStickerTaskInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MapStickerTaskInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MapStickerTaskInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut task_id__ = None;
                let mut target_num__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TaskId => {
                            if task_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TaskId"));
                            }
                            task_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetNum => {
                            if target_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetNum"));
                            }
                            target_num__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(MapStickerTaskInfo {
                    task_id: task_id__,
                    target_num: target_num__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MapStickerTaskInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MarkData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if !self.mark_info_map.is_empty() {
            len += 1;
        }
        if self.mark_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MarkData", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if !self.mark_info_map.is_empty() {
            struct_ser.serialize_field("MarkInfoMap", &self.mark_info_map)?;
        }
        if let Some(v) = self.mark_uuid.as_ref() {
            struct_ser.serialize_field("MarkUuid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MarkData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "MarkInfoMap",
            "MarkUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            MarkInfoMap,
            MarkUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "MarkInfoMap" => Ok(GeneratedField::MarkInfoMap),
                            "MarkUuid" => Ok(GeneratedField::MarkUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MarkData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MarkData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MarkData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut mark_info_map__ = None;
                let mut mark_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MarkInfoMap => {
                            if mark_info_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MarkInfoMap"));
                            }
                            mark_info_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::MarkUuid => {
                            if mark_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MarkUuid"));
                            }
                            mark_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MarkData {
                    id: id__,
                    mark_info_map: mark_info_map__.unwrap_or_default(),
                    mark_uuid: mark_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MarkData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MarkInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.tag_id.is_some() {
            len += 1;
        }
        if self.title.is_some() {
            len += 1;
        }
        if self.content.is_some() {
            len += 1;
        }
        if self.icon_id.is_some() {
            len += 1;
        }
        if self.position.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MarkInfo", len)?;
        if let Some(v) = self.tag_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TagId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.title.as_ref() {
            struct_ser.serialize_field("Title", v)?;
        }
        if let Some(v) = self.content.as_ref() {
            struct_ser.serialize_field("Content", v)?;
        }
        if let Some(v) = self.icon_id.as_ref() {
            struct_ser.serialize_field("IconId", v)?;
        }
        if let Some(v) = self.position.as_ref() {
            struct_ser.serialize_field("Position", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MarkInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TagId",
            "Title",
            "Content",
            "IconId",
            "Position",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TagId,
            Title,
            Content,
            IconId,
            Position,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TagId" => Ok(GeneratedField::TagId),
                            "Title" => Ok(GeneratedField::Title),
                            "Content" => Ok(GeneratedField::Content),
                            "IconId" => Ok(GeneratedField::IconId),
                            "Position" => Ok(GeneratedField::Position),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MarkInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MarkInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MarkInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut tag_id__ = None;
                let mut title__ = None;
                let mut content__ = None;
                let mut icon_id__ = None;
                let mut position__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TagId => {
                            if tag_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TagId"));
                            }
                            tag_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Title => {
                            if title__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Title"));
                            }
                            title__ = map_.next_value()?;
                        }
                        GeneratedField::Content => {
                            if content__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Content"));
                            }
                            content__ = map_.next_value()?;
                        }
                        GeneratedField::IconId => {
                            if icon_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IconId"));
                            }
                            icon_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Position => {
                            if position__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Position"));
                            }
                            position__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MarkInfo {
                    tag_id: tag_id__,
                    title: title__,
                    content: content__,
                    icon_id: icon_id__,
                    position: position__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MarkInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MarkPosition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.x.is_some() {
            len += 1;
        }
        if self.y.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MarkPosition", len)?;
        if let Some(v) = self.x.as_ref() {
            struct_ser.serialize_field("X", v)?;
        }
        if let Some(v) = self.y.as_ref() {
            struct_ser.serialize_field("Y", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MarkPosition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "X",
            "Y",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            X,
            Y,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "X" => Ok(GeneratedField::X),
                            "Y" => Ok(GeneratedField::Y),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MarkPosition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MarkPosition")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MarkPosition, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut x__ = None;
                let mut y__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::X => {
                            if x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("X"));
                            }
                            x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Y => {
                            if y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Y"));
                            }
                            y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MarkPosition {
                    x: x__,
                    y: y__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MarkPosition", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MasterModeDiffDungeonInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dungeon_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MasterModeDiffDungeonInfo", len)?;
        if !self.dungeon_info.is_empty() {
            struct_ser.serialize_field("DungeonInfo", &self.dungeon_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MasterModeDiffDungeonInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DungeonInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DungeonInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DungeonInfo" => Ok(GeneratedField::DungeonInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MasterModeDiffDungeonInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MasterModeDiffDungeonInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MasterModeDiffDungeonInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dungeon_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DungeonInfo => {
                            if dungeon_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonInfo"));
                            }
                            dungeon_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(MasterModeDiffDungeonInfo {
                    dungeon_info: dungeon_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MasterModeDiffDungeonInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MasterModeDungeonData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.season_score.is_some() {
            len += 1;
        }
        if self.is_show.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MasterModeDungeonData", len)?;
        if let Some(v) = self.season_score.as_ref() {
            struct_ser.serialize_field("SeasonScore", v)?;
        }
        if let Some(v) = self.is_show.as_ref() {
            struct_ser.serialize_field("IsShow", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MasterModeDungeonData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SeasonScore",
            "IsShow",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SeasonScore,
            IsShow,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SeasonScore" => Ok(GeneratedField::SeasonScore),
                            "IsShow" => Ok(GeneratedField::IsShow),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MasterModeDungeonData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MasterModeDungeonData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MasterModeDungeonData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut season_score__ = None;
                let mut is_show__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SeasonScore => {
                            if season_score__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonScore"));
                            }
                            season_score__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsShow => {
                            if is_show__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsShow"));
                            }
                            is_show__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MasterModeDungeonData {
                    season_score: season_score__,
                    is_show: is_show__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MasterModeDungeonData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MasterModeDungeonInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.master_mode_dungeon_info.is_empty() {
            len += 1;
        }
        if self.is_show.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MasterModeDungeonInfo", len)?;
        if !self.master_mode_dungeon_info.is_empty() {
            struct_ser.serialize_field("MasterModeDungeonInfo", &self.master_mode_dungeon_info)?;
        }
        if let Some(v) = self.is_show.as_ref() {
            struct_ser.serialize_field("IsShow", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MasterModeDungeonInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MasterModeDungeonInfo_",
            "MasterModeDungeonInfo",
            "IsShow",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MasterModeDungeonInfo,
            IsShow,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MasterModeDungeonInfo" | "MasterModeDungeonInfo_" => Ok(GeneratedField::MasterModeDungeonInfo),
                            "IsShow" => Ok(GeneratedField::IsShow),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MasterModeDungeonInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MasterModeDungeonInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MasterModeDungeonInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut master_mode_dungeon_info__ = None;
                let mut is_show__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MasterModeDungeonInfo => {
                            if master_mode_dungeon_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MasterModeDungeonInfo"));
                            }
                            master_mode_dungeon_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::IsShow => {
                            if is_show__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsShow"));
                            }
                            is_show__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MasterModeDungeonInfo {
                    master_mode_dungeon_info: master_mode_dungeon_info__.unwrap_or_default(),
                    is_show: is_show__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MasterModeDungeonInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MedalHole {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.hole_id.is_some() {
            len += 1;
        }
        if self.hole_level.is_some() {
            len += 1;
        }
        if self.cur_exp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MedalHole", len)?;
        if let Some(v) = self.hole_id.as_ref() {
            struct_ser.serialize_field("HoleId", v)?;
        }
        if let Some(v) = self.hole_level.as_ref() {
            struct_ser.serialize_field("HoleLevel", v)?;
        }
        if let Some(v) = self.cur_exp.as_ref() {
            struct_ser.serialize_field("CurExp", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MedalHole {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HoleId",
            "HoleLevel",
            "CurExp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HoleId,
            HoleLevel,
            CurExp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "HoleId" => Ok(GeneratedField::HoleId),
                            "HoleLevel" => Ok(GeneratedField::HoleLevel),
                            "CurExp" => Ok(GeneratedField::CurExp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MedalHole;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MedalHole")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MedalHole, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut hole_id__ = None;
                let mut hole_level__ = None;
                let mut cur_exp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HoleId => {
                            if hole_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HoleId"));
                            }
                            hole_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HoleLevel => {
                            if hole_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HoleLevel"));
                            }
                            hole_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurExp => {
                            if cur_exp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurExp"));
                            }
                            cur_exp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MedalHole {
                    hole_id: hole_id__,
                    hole_level: hole_level__,
                    cur_exp: cur_exp__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MedalHole", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MedalNode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.node_id.is_some() {
            len += 1;
        }
        if self.node_level.is_some() {
            len += 1;
        }
        if self.choose.is_some() {
            len += 1;
        }
        if self.slot.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MedalNode", len)?;
        if let Some(v) = self.node_id.as_ref() {
            struct_ser.serialize_field("NodeId", v)?;
        }
        if let Some(v) = self.node_level.as_ref() {
            struct_ser.serialize_field("NodeLevel", v)?;
        }
        if let Some(v) = self.choose.as_ref() {
            struct_ser.serialize_field("Choose", v)?;
        }
        if let Some(v) = self.slot.as_ref() {
            struct_ser.serialize_field("Slot", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MedalNode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NodeId",
            "NodeLevel",
            "Choose",
            "Slot",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            NodeId,
            NodeLevel,
            Choose,
            Slot,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "NodeId" => Ok(GeneratedField::NodeId),
                            "NodeLevel" => Ok(GeneratedField::NodeLevel),
                            "Choose" => Ok(GeneratedField::Choose),
                            "Slot" => Ok(GeneratedField::Slot),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MedalNode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MedalNode")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MedalNode, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut node_id__ = None;
                let mut node_level__ = None;
                let mut choose__ = None;
                let mut slot__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::NodeId => {
                            if node_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NodeId"));
                            }
                            node_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NodeLevel => {
                            if node_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NodeLevel"));
                            }
                            node_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Choose => {
                            if choose__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Choose"));
                            }
                            choose__ = map_.next_value()?;
                        }
                        GeneratedField::Slot => {
                            if slot__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Slot"));
                            }
                            slot__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MedalNode {
                    node_id: node_id__,
                    node_level: node_level__,
                    choose: choose__,
                    slot: slot__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MedalNode", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MiscInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.expression_ids_learned.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MiscInfo", len)?;
        if !self.expression_ids_learned.is_empty() {
            struct_ser.serialize_field("ExpressionIdsLearned", &self.expression_ids_learned)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MiscInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ExpressionIdsLearned",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ExpressionIdsLearned,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ExpressionIdsLearned" => Ok(GeneratedField::ExpressionIdsLearned),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MiscInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MiscInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MiscInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut expression_ids_learned__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ExpressionIdsLearned => {
                            if expression_ids_learned__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExpressionIdsLearned"));
                            }
                            expression_ids_learned__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(MiscInfo {
                    expression_ids_learned: expression_ids_learned__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MiscInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Mod {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.mod_slots.is_empty() {
            len += 1;
        }
        if !self.mod_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Mod", len)?;
        if !self.mod_slots.is_empty() {
            let v: std::collections::HashMap<_, _> = self.mod_slots.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("ModSlots", &v)?;
        }
        if !self.mod_infos.is_empty() {
            struct_ser.serialize_field("ModInfos", &self.mod_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Mod {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ModSlots",
            "ModInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ModSlots,
            ModInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ModSlots" => Ok(GeneratedField::ModSlots),
                            "ModInfos" => Ok(GeneratedField::ModInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Mod;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Mod")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Mod, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut mod_slots__ = None;
                let mut mod_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ModSlots => {
                            if mod_slots__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ModSlots"));
                            }
                            mod_slots__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::ModInfos => {
                            if mod_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ModInfos"));
                            }
                            mod_infos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(Mod {
                    mod_slots: mod_slots__.unwrap_or_default(),
                    mod_infos: mod_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Mod", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ModAttr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.load_flag.is_some() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        if !self.mod_attr_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ModAttr", len)?;
        if let Some(v) = self.load_flag.as_ref() {
            struct_ser.serialize_field("LoadFlag", v)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("Type", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if !self.mod_attr_info.is_empty() {
            struct_ser.serialize_field("ModAttrInfo", &self.mod_attr_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ModAttr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LoadFlag",
            "Type",
            "Level",
            "ModAttrInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LoadFlag,
            Type,
            Level,
            ModAttrInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LoadFlag" => Ok(GeneratedField::LoadFlag),
                            "Type" => Ok(GeneratedField::Type),
                            "Level" => Ok(GeneratedField::Level),
                            "ModAttrInfo" => Ok(GeneratedField::ModAttrInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ModAttr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ModAttr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ModAttr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut load_flag__ = None;
                let mut r#type__ = None;
                let mut level__ = None;
                let mut mod_attr_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LoadFlag => {
                            if load_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LoadFlag"));
                            }
                            load_flag__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ModAttrInfo => {
                            if mod_attr_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ModAttrInfo"));
                            }
                            mod_attr_info__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ModAttr {
                    load_flag: load_flag__,
                    r#type: r#type__,
                    level: level__,
                    mod_attr_info: mod_attr_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ModAttr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ModAttrInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.id.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        if !self.effect_parameter.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ModAttrInfo", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("Type", v)?;
        }
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("Value", v)?;
        }
        if !self.effect_parameter.is_empty() {
            struct_ser.serialize_field("EffectParameter", &self.effect_parameter)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ModAttrInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Type",
            "Id",
            "Value",
            "EffectParameter",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            Id,
            Value,
            EffectParameter,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Type" => Ok(GeneratedField::Type),
                            "Id" => Ok(GeneratedField::Id),
                            "Value" => Ok(GeneratedField::Value),
                            "EffectParameter" => Ok(GeneratedField::EffectParameter),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ModAttrInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ModAttrInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ModAttrInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut id__ = None;
                let mut value__ = None;
                let mut effect_parameter__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Value"));
                            }
                            value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EffectParameter => {
                            if effect_parameter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EffectParameter"));
                            }
                            effect_parameter__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ModAttrInfo {
                    r#type: r#type__,
                    id: id__,
                    value: value__,
                    effect_parameter: effect_parameter__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ModAttrInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ModInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.part_ids.is_empty() {
            len += 1;
        }
        if !self.upgrade_records.is_empty() {
            len += 1;
        }
        if self.success_rate.is_some() {
            len += 1;
        }
        if !self.init_link_nums.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ModInfo", len)?;
        if !self.part_ids.is_empty() {
            struct_ser.serialize_field("PartIds", &self.part_ids)?;
        }
        if !self.upgrade_records.is_empty() {
            struct_ser.serialize_field("UpgradeRecords", &self.upgrade_records)?;
        }
        if let Some(v) = self.success_rate.as_ref() {
            struct_ser.serialize_field("SuccessRate", v)?;
        }
        if !self.init_link_nums.is_empty() {
            struct_ser.serialize_field("InitLinkNums", &self.init_link_nums)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ModInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PartIds",
            "UpgradeRecords",
            "SuccessRate",
            "InitLinkNums",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PartIds,
            UpgradeRecords,
            SuccessRate,
            InitLinkNums,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PartIds" => Ok(GeneratedField::PartIds),
                            "UpgradeRecords" => Ok(GeneratedField::UpgradeRecords),
                            "SuccessRate" => Ok(GeneratedField::SuccessRate),
                            "InitLinkNums" => Ok(GeneratedField::InitLinkNums),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ModInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ModInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ModInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut part_ids__ = None;
                let mut upgrade_records__ = None;
                let mut success_rate__ = None;
                let mut init_link_nums__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PartIds => {
                            if part_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartIds"));
                            }
                            part_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::UpgradeRecords => {
                            if upgrade_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UpgradeRecords"));
                            }
                            upgrade_records__ = Some(map_.next_value()?);
                        }
                        GeneratedField::SuccessRate => {
                            if success_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SuccessRate"));
                            }
                            success_rate__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::InitLinkNums => {
                            if init_link_nums__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InitLinkNums"));
                            }
                            init_link_nums__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(ModInfo {
                    part_ids: part_ids__.unwrap_or_default(),
                    upgrade_records: upgrade_records__.unwrap_or_default(),
                    success_rate: success_rate__,
                    init_link_nums: init_link_nums__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ModInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ModNewAttr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.mod_parts.is_empty() {
            len += 1;
        }
        if !self.upgrade_records.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ModNewAttr", len)?;
        if !self.mod_parts.is_empty() {
            struct_ser.serialize_field("ModParts", &self.mod_parts)?;
        }
        if !self.upgrade_records.is_empty() {
            struct_ser.serialize_field("UpgradeRecords", &self.upgrade_records)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ModNewAttr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ModParts",
            "UpgradeRecords",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ModParts,
            UpgradeRecords,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ModParts" => Ok(GeneratedField::ModParts),
                            "UpgradeRecords" => Ok(GeneratedField::UpgradeRecords),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ModNewAttr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ModNewAttr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ModNewAttr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut mod_parts__ = None;
                let mut upgrade_records__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ModParts => {
                            if mod_parts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ModParts"));
                            }
                            mod_parts__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::UpgradeRecords => {
                            if upgrade_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UpgradeRecords"));
                            }
                            upgrade_records__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ModNewAttr {
                    mod_parts: mod_parts__.unwrap_or_default(),
                    upgrade_records: upgrade_records__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ModNewAttr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ModPartUpgradeRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.part_id.is_some() {
            len += 1;
        }
        if self.is_success.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ModPartUpgradeRecord", len)?;
        if let Some(v) = self.part_id.as_ref() {
            struct_ser.serialize_field("PartId", v)?;
        }
        if let Some(v) = self.is_success.as_ref() {
            struct_ser.serialize_field("IsSuccess", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ModPartUpgradeRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PartId",
            "IsSuccess",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PartId,
            IsSuccess,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PartId" => Ok(GeneratedField::PartId),
                            "IsSuccess" => Ok(GeneratedField::IsSuccess),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ModPartUpgradeRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ModPartUpgradeRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ModPartUpgradeRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut part_id__ = None;
                let mut is_success__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PartId => {
                            if part_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartId"));
                            }
                            part_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsSuccess => {
                            if is_success__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsSuccess"));
                            }
                            is_success__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ModPartUpgradeRecord {
                    part_id: part_id__,
                    is_success: is_success__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ModPartUpgradeRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MonitorBehaviorTreeOfEntity {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.entity_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MonitorBehaviorTreeOfEntity", len)?;
        if let Some(v) = self.entity_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("EntityId", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MonitorBehaviorTreeOfEntity {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EntityId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EntityId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EntityId" => Ok(GeneratedField::EntityId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonitorBehaviorTreeOfEntity;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MonitorBehaviorTreeOfEntity")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MonitorBehaviorTreeOfEntity, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut entity_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EntityId => {
                            if entity_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EntityId"));
                            }
                            entity_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MonitorBehaviorTreeOfEntity {
                    entity_id: entity_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MonitorBehaviorTreeOfEntity", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MonsterCastSkill {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.self_uuid.is_some() {
            len += 1;
        }
        if self.skill_id.is_some() {
            len += 1;
        }
        if self.target_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MonsterCastSkill", len)?;
        if let Some(v) = self.self_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SelfUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.skill_id.as_ref() {
            struct_ser.serialize_field("SkillId", v)?;
        }
        if let Some(v) = self.target_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetUuid", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MonsterCastSkill {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SelfUuid",
            "SkillId",
            "TargetUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SelfUuid,
            SkillId,
            TargetUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SelfUuid" => Ok(GeneratedField::SelfUuid),
                            "SkillId" => Ok(GeneratedField::SkillId),
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonsterCastSkill;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MonsterCastSkill")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MonsterCastSkill, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut self_uuid__ = None;
                let mut skill_id__ = None;
                let mut target_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SelfUuid => {
                            if self_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SelfUuid"));
                            }
                            self_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillId => {
                            if skill_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillId"));
                            }
                            skill_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MonsterCastSkill {
                    self_uuid: self_uuid__,
                    skill_id: skill_id__,
                    target_uuid: target_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MonsterCastSkill", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MonsterExploreInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_unlock.is_some() {
            len += 1;
        }
        if !self.target_num.is_empty() {
            len += 1;
        }
        if self.award_flag.is_some() {
            len += 1;
        }
        if self.is_flag.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MonsterExploreInfo", len)?;
        if let Some(v) = self.is_unlock.as_ref() {
            struct_ser.serialize_field("IsUnlock", v)?;
        }
        if !self.target_num.is_empty() {
            struct_ser.serialize_field("TargetNum", &self.target_num)?;
        }
        if let Some(v) = self.award_flag.as_ref() {
            struct_ser.serialize_field("AwardFlag", v)?;
        }
        if let Some(v) = self.is_flag.as_ref() {
            struct_ser.serialize_field("IsFlag", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MonsterExploreInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsUnlock",
            "TargetNum",
            "AwardFlag",
            "IsFlag",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsUnlock,
            TargetNum,
            AwardFlag,
            IsFlag,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsUnlock" => Ok(GeneratedField::IsUnlock),
                            "TargetNum" => Ok(GeneratedField::TargetNum),
                            "AwardFlag" => Ok(GeneratedField::AwardFlag),
                            "IsFlag" => Ok(GeneratedField::IsFlag),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonsterExploreInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MonsterExploreInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MonsterExploreInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_unlock__ = None;
                let mut target_num__ = None;
                let mut award_flag__ = None;
                let mut is_flag__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsUnlock => {
                            if is_unlock__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsUnlock"));
                            }
                            is_unlock__ = map_.next_value()?;
                        }
                        GeneratedField::TargetNum => {
                            if target_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetNum"));
                            }
                            target_num__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::AwardFlag => {
                            if award_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardFlag"));
                            }
                            award_flag__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsFlag => {
                            if is_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsFlag"));
                            }
                            is_flag__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MonsterExploreInfo {
                    is_unlock: is_unlock__,
                    target_num: target_num__.unwrap_or_default(),
                    award_flag: award_flag__,
                    is_flag: is_flag__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MonsterExploreInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MonsterExploreList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.monster_explore_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MonsterExploreList", len)?;
        if !self.monster_explore_list.is_empty() {
            struct_ser.serialize_field("MonsterExploreList", &self.monster_explore_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MonsterExploreList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MonsterExploreList_",
            "MonsterExploreList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MonsterExploreList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MonsterExploreList" | "MonsterExploreList_" => Ok(GeneratedField::MonsterExploreList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonsterExploreList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MonsterExploreList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MonsterExploreList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut monster_explore_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MonsterExploreList => {
                            if monster_explore_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MonsterExploreList"));
                            }
                            monster_explore_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(MonsterExploreList {
                    monster_explore_list: monster_explore_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MonsterExploreList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MonsterHuntInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.monster_hunt_list.is_empty() {
            len += 1;
        }
        if self.cur_level.is_some() {
            len += 1;
        }
        if self.cur_exp.is_some() {
            len += 1;
        }
        if !self.level_award_flag.is_empty() {
            len += 1;
        }
        if !self.monster_hunt_refrsh_time.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MonsterHuntInfo", len)?;
        if !self.monster_hunt_list.is_empty() {
            struct_ser.serialize_field("MonsterHuntList", &self.monster_hunt_list)?;
        }
        if let Some(v) = self.cur_level.as_ref() {
            struct_ser.serialize_field("CurLevel", v)?;
        }
        if let Some(v) = self.cur_exp.as_ref() {
            struct_ser.serialize_field("CurExp", v)?;
        }
        if !self.level_award_flag.is_empty() {
            struct_ser.serialize_field("LevelAwardFlag", &self.level_award_flag)?;
        }
        if !self.monster_hunt_refrsh_time.is_empty() {
            let v: std::collections::HashMap<_, _> = self.monster_hunt_refrsh_time.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("MonsterHuntRefrshTime", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MonsterHuntInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MonsterHuntList",
            "CurLevel",
            "CurExp",
            "LevelAwardFlag",
            "MonsterHuntRefrshTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MonsterHuntList,
            CurLevel,
            CurExp,
            LevelAwardFlag,
            MonsterHuntRefrshTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MonsterHuntList" => Ok(GeneratedField::MonsterHuntList),
                            "CurLevel" => Ok(GeneratedField::CurLevel),
                            "CurExp" => Ok(GeneratedField::CurExp),
                            "LevelAwardFlag" => Ok(GeneratedField::LevelAwardFlag),
                            "MonsterHuntRefrshTime" => Ok(GeneratedField::MonsterHuntRefrshTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonsterHuntInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MonsterHuntInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MonsterHuntInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut monster_hunt_list__ = None;
                let mut cur_level__ = None;
                let mut cur_exp__ = None;
                let mut level_award_flag__ = None;
                let mut monster_hunt_refrsh_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MonsterHuntList => {
                            if monster_hunt_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MonsterHuntList"));
                            }
                            monster_hunt_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::CurLevel => {
                            if cur_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurLevel"));
                            }
                            cur_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurExp => {
                            if cur_exp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurExp"));
                            }
                            cur_exp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LevelAwardFlag => {
                            if level_award_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LevelAwardFlag"));
                            }
                            level_award_flag__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::MonsterHuntRefrshTime => {
                            if monster_hunt_refrsh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MonsterHuntRefrshTime"));
                            }
                            monster_hunt_refrsh_time__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(MonsterHuntInfo {
                    monster_hunt_list: monster_hunt_list__.unwrap_or_default(),
                    cur_level: cur_level__,
                    cur_exp: cur_exp__,
                    level_award_flag: level_award_flag__.unwrap_or_default(),
                    monster_hunt_refrsh_time: monster_hunt_refrsh_time__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MonsterHuntInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MonsterHuntTarget {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.monster_id.is_some() {
            len += 1;
        }
        if !self.target_info_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MonsterHuntTarget", len)?;
        if let Some(v) = self.monster_id.as_ref() {
            struct_ser.serialize_field("MonsterId", v)?;
        }
        if !self.target_info_list.is_empty() {
            struct_ser.serialize_field("TargetInfoList", &self.target_info_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MonsterHuntTarget {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MonsterId",
            "TargetInfoList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MonsterId,
            TargetInfoList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MonsterId" => Ok(GeneratedField::MonsterId),
                            "TargetInfoList" => Ok(GeneratedField::TargetInfoList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonsterHuntTarget;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MonsterHuntTarget")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MonsterHuntTarget, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut monster_id__ = None;
                let mut target_info_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MonsterId => {
                            if monster_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MonsterId"));
                            }
                            monster_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetInfoList => {
                            if target_info_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetInfoList"));
                            }
                            target_info_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(MonsterHuntTarget {
                    monster_id: monster_id__,
                    target_info_list: target_info_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MonsterHuntTarget", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MonsterHuntUnlockMonster {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MonsterHuntUnlockMonster", len)?;
        if let Some(v) = self.info.as_ref() {
            struct_ser.serialize_field("Info", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MonsterHuntUnlockMonster {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Info",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Info,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Info" => Ok(GeneratedField::Info),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonsterHuntUnlockMonster;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MonsterHuntUnlockMonster")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MonsterHuntUnlockMonster, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Info => {
                            if info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Info"));
                            }
                            info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(MonsterHuntUnlockMonster {
                    info: info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MonsterHuntUnlockMonster", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MonsterTargetAward {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Null => "MonsterTargetAwardNull",
            Self::Get => "MonsterTargetAwardGet",
            Self::Received => "MonsterTargetAwardReceived",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for MonsterTargetAward {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MonsterTargetAwardNull",
            "MonsterTargetAwardGet",
            "MonsterTargetAwardReceived",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonsterTargetAward;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "MonsterTargetAwardNull" => Ok(MonsterTargetAward::Null),
                    "MonsterTargetAwardGet" => Ok(MonsterTargetAward::Get),
                    "MonsterTargetAwardReceived" => Ok(MonsterTargetAward::Received),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for MonsterTargetInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.target_uuid.is_some() {
            len += 1;
        }
        if self.target_type.is_some() {
            len += 1;
        }
        if self.target_num.is_some() {
            len += 1;
        }
        if self.award_flag.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MonsterTargetInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.target_uuid.as_ref() {
            struct_ser.serialize_field("TargetUuid", v)?;
        }
        if let Some(v) = self.target_type.as_ref() {
            struct_ser.serialize_field("TargetType", v)?;
        }
        if let Some(v) = self.target_num.as_ref() {
            struct_ser.serialize_field("TargetNum", v)?;
        }
        if let Some(v) = self.award_flag.as_ref() {
            let v = MonsterTargetAward::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("AwardFlag", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MonsterTargetInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "TargetUuid",
            "TargetType",
            "TargetNum",
            "AwardFlag",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            TargetUuid,
            TargetType,
            TargetNum,
            AwardFlag,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            "TargetType" => Ok(GeneratedField::TargetType),
                            "TargetNum" => Ok(GeneratedField::TargetNum),
                            "AwardFlag" => Ok(GeneratedField::AwardFlag),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonsterTargetInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MonsterTargetInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MonsterTargetInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut target_uuid__ = None;
                let mut target_type__ = None;
                let mut target_num__ = None;
                let mut award_flag__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetType => {
                            if target_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetType"));
                            }
                            target_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetNum => {
                            if target_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetNum"));
                            }
                            target_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AwardFlag => {
                            if award_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardFlag"));
                            }
                            award_flag__ = map_.next_value::<::std::option::Option<MonsterTargetAward>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(MonsterTargetInfo {
                    id: id__,
                    target_uuid: target_uuid__,
                    target_type: target_type__,
                    target_num: target_num__,
                    award_flag: award_flag__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MonsterTargetInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MonthCardItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.item_id.is_some() {
            len += 1;
        }
        if self.create_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MonthCardItem", len)?;
        if let Some(v) = self.item_id.as_ref() {
            struct_ser.serialize_field("ItemId", v)?;
        }
        if let Some(v) = self.create_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CreateTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MonthCardItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ItemId",
            "CreateTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ItemId,
            CreateTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ItemId" => Ok(GeneratedField::ItemId),
                            "CreateTime" => Ok(GeneratedField::CreateTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonthCardItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MonthCardItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MonthCardItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut item_id__ = None;
                let mut create_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ItemId => {
                            if item_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ItemId"));
                            }
                            item_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CreateTime => {
                            if create_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CreateTime"));
                            }
                            create_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MonthCardItem {
                    item_id: item_id__,
                    create_time: create_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MonthCardItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MonthlyCard {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.expire_time.is_some() {
            len += 1;
        }
        if !self.monthly_card_info.is_empty() {
            len += 1;
        }
        if self.last_award_monthly_card_time.is_some() {
            len += 1;
        }
        if self.tips_clicked.is_some() {
            len += 1;
        }
        if self.tips_day.is_some() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        if !self.monthly_card_buy_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MonthlyCard", len)?;
        if let Some(v) = self.expire_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ExpireTime", ToString::to_string(&v).as_str())?;
        }
        if !self.monthly_card_info.is_empty() {
            struct_ser.serialize_field("MonthlyCardInfo", &self.monthly_card_info)?;
        }
        if let Some(v) = self.last_award_monthly_card_time.as_ref() {
            struct_ser.serialize_field("LastAwardMonthlyCardTime", v)?;
        }
        if let Some(v) = self.tips_clicked.as_ref() {
            struct_ser.serialize_field("TipsClicked", v)?;
        }
        if let Some(v) = self.tips_day.as_ref() {
            struct_ser.serialize_field("TipsDay", v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("Items", &self.items)?;
        }
        if !self.monthly_card_buy_list.is_empty() {
            struct_ser.serialize_field("MonthlyCardBuyList", &self.monthly_card_buy_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MonthlyCard {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ExpireTime",
            "MonthlyCardInfo",
            "LastAwardMonthlyCardTime",
            "TipsClicked",
            "TipsDay",
            "Items",
            "MonthlyCardBuyList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ExpireTime,
            MonthlyCardInfo,
            LastAwardMonthlyCardTime,
            TipsClicked,
            TipsDay,
            Items,
            MonthlyCardBuyList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ExpireTime" => Ok(GeneratedField::ExpireTime),
                            "MonthlyCardInfo" => Ok(GeneratedField::MonthlyCardInfo),
                            "LastAwardMonthlyCardTime" => Ok(GeneratedField::LastAwardMonthlyCardTime),
                            "TipsClicked" => Ok(GeneratedField::TipsClicked),
                            "TipsDay" => Ok(GeneratedField::TipsDay),
                            "Items" => Ok(GeneratedField::Items),
                            "MonthlyCardBuyList" => Ok(GeneratedField::MonthlyCardBuyList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonthlyCard;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MonthlyCard")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MonthlyCard, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut expire_time__ = None;
                let mut monthly_card_info__ = None;
                let mut last_award_monthly_card_time__ = None;
                let mut tips_clicked__ = None;
                let mut tips_day__ = None;
                let mut items__ = None;
                let mut monthly_card_buy_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ExpireTime => {
                            if expire_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExpireTime"));
                            }
                            expire_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MonthlyCardInfo => {
                            if monthly_card_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MonthlyCardInfo"));
                            }
                            monthly_card_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::LastAwardMonthlyCardTime => {
                            if last_award_monthly_card_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastAwardMonthlyCardTime"));
                            }
                            last_award_monthly_card_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TipsClicked => {
                            if tips_clicked__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TipsClicked"));
                            }
                            tips_clicked__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TipsDay => {
                            if tips_day__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TipsDay"));
                            }
                            tips_day__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Items"));
                            }
                            items__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MonthlyCardBuyList => {
                            if monthly_card_buy_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MonthlyCardBuyList"));
                            }
                            monthly_card_buy_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(MonthlyCard {
                    expire_time: expire_time__,
                    monthly_card_info: monthly_card_info__.unwrap_or_default(),
                    last_award_monthly_card_time: last_award_monthly_card_time__,
                    tips_clicked: tips_clicked__,
                    tips_day: tips_day__,
                    items: items__.unwrap_or_default(),
                    monthly_card_buy_list: monthly_card_buy_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MonthlyCard", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MonthlyCardBuyList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.begin_time.is_some() {
            len += 1;
        }
        if self.end_time.is_some() {
            len += 1;
        }
        if self.last_award_day_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MonthlyCardBuyList", len)?;
        if let Some(v) = self.begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.end_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("EndTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.last_award_day_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastAwardDayTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MonthlyCardBuyList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BeginTime",
            "EndTime",
            "LastAwardDayTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BeginTime,
            EndTime,
            LastAwardDayTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BeginTime" => Ok(GeneratedField::BeginTime),
                            "EndTime" => Ok(GeneratedField::EndTime),
                            "LastAwardDayTime" => Ok(GeneratedField::LastAwardDayTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonthlyCardBuyList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MonthlyCardBuyList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MonthlyCardBuyList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut begin_time__ = None;
                let mut end_time__ = None;
                let mut last_award_day_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BeginTime => {
                            if begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeginTime"));
                            }
                            begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EndTime"));
                            }
                            end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastAwardDayTime => {
                            if last_award_day_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastAwardDayTime"));
                            }
                            last_award_day_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MonthlyCardBuyList {
                    begin_time: begin_time__,
                    end_time: end_time__,
                    last_award_day_time: last_award_day_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MonthlyCardBuyList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MonthlyCardInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.limit_award_status.is_some() {
            len += 1;
        }
        if self.award_status.is_some() {
            len += 1;
        }
        if self.month_card_item.is_some() {
            len += 1;
        }
        if self.begin_time.is_some() {
            len += 1;
        }
        if self.end_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.MonthlyCardInfo", len)?;
        if let Some(v) = self.limit_award_status.as_ref() {
            let v = EReceiveRewardStatus::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("LimitAwardStatus", &v)?;
        }
        if let Some(v) = self.award_status.as_ref() {
            let v = EReceiveRewardStatus::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("AwardStatus", &v)?;
        }
        if let Some(v) = self.month_card_item.as_ref() {
            struct_ser.serialize_field("MonthCardItem", v)?;
        }
        if let Some(v) = self.begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.end_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("EndTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MonthlyCardInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LimitAwardStatus",
            "AwardStatus",
            "MonthCardItem",
            "BeginTime",
            "EndTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LimitAwardStatus,
            AwardStatus,
            MonthCardItem,
            BeginTime,
            EndTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LimitAwardStatus" => Ok(GeneratedField::LimitAwardStatus),
                            "AwardStatus" => Ok(GeneratedField::AwardStatus),
                            "MonthCardItem" => Ok(GeneratedField::MonthCardItem),
                            "BeginTime" => Ok(GeneratedField::BeginTime),
                            "EndTime" => Ok(GeneratedField::EndTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MonthlyCardInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.MonthlyCardInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MonthlyCardInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut limit_award_status__ = None;
                let mut award_status__ = None;
                let mut month_card_item__ = None;
                let mut begin_time__ = None;
                let mut end_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LimitAwardStatus => {
                            if limit_award_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LimitAwardStatus"));
                            }
                            limit_award_status__ = map_.next_value::<::std::option::Option<EReceiveRewardStatus>>()?.map(|x| x as i32);
                        }
                        GeneratedField::AwardStatus => {
                            if award_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardStatus"));
                            }
                            award_status__ = map_.next_value::<::std::option::Option<EReceiveRewardStatus>>()?.map(|x| x as i32);
                        }
                        GeneratedField::MonthCardItem => {
                            if month_card_item__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MonthCardItem"));
                            }
                            month_card_item__ = map_.next_value()?;
                        }
                        GeneratedField::BeginTime => {
                            if begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeginTime"));
                            }
                            begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EndTime"));
                            }
                            end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(MonthlyCardInfo {
                    limit_award_status: limit_award_status__,
                    award_status: award_status__,
                    month_card_item: month_card_item__,
                    begin_time: begin_time__,
                    end_time: end_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.MonthlyCardInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NewMove {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NewMove", len)?;
        if let Some(v) = self.info.as_ref() {
            struct_ser.serialize_field("Info", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NewMove {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Info",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Info,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Info" => Ok(GeneratedField::Info),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NewMove;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NewMove")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NewMove, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Info => {
                            if info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Info"));
                            }
                            info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NewMove {
                    info: info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NewMove", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NewbieData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.total_online_time.is_some() {
            len += 1;
        }
        if self.is_newbie.is_some() {
            len += 1;
        }
        if self.is_cancel_newbie.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NewbieData", len)?;
        if let Some(v) = self.total_online_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TotalOnlineTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.is_newbie.as_ref() {
            struct_ser.serialize_field("IsNewbie", v)?;
        }
        if let Some(v) = self.is_cancel_newbie.as_ref() {
            struct_ser.serialize_field("IsCancelNewbie", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NewbieData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TotalOnlineTime",
            "IsNewbie",
            "IsCancelNewbie",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TotalOnlineTime,
            IsNewbie,
            IsCancelNewbie,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TotalOnlineTime" => Ok(GeneratedField::TotalOnlineTime),
                            "IsNewbie" => Ok(GeneratedField::IsNewbie),
                            "IsCancelNewbie" => Ok(GeneratedField::IsCancelNewbie),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NewbieData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NewbieData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NewbieData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut total_online_time__ = None;
                let mut is_newbie__ = None;
                let mut is_cancel_newbie__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TotalOnlineTime => {
                            if total_online_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TotalOnlineTime"));
                            }
                            total_online_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsNewbie => {
                            if is_newbie__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsNewbie"));
                            }
                            is_newbie__ = map_.next_value()?;
                        }
                        GeneratedField::IsCancelNewbie => {
                            if is_cancel_newbie__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsCancelNewbie"));
                            }
                            is_cancel_newbie__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NewbieData {
                    total_online_time: total_online_time__,
                    is_newbie: is_newbie__,
                    is_cancel_newbie: is_cancel_newbie__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NewbieData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotGetProceedAwardInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.award_id_times.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotGetProceedAwardInfo", len)?;
        if !self.award_id_times.is_empty() {
            struct_ser.serialize_field("AwardIdTimes", &self.award_id_times)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotGetProceedAwardInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AwardIdTimes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AwardIdTimes,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AwardIdTimes" => Ok(GeneratedField::AwardIdTimes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotGetProceedAwardInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotGetProceedAwardInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotGetProceedAwardInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut award_id_times__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AwardIdTimes => {
                            if award_id_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardIdTimes"));
                            }
                            award_id_times__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<u32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(NotGetProceedAwardInfo {
                    award_id_times: award_id_times__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotGetProceedAwardInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyAntiData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyAntiData", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyAntiData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyAntiData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyAntiData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyAntiData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyAntiData {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyAntiData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyAntiDataRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.tss_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyAntiDataRequest", len)?;
        if let Some(v) = self.tss_info.as_ref() {
            struct_ser.serialize_field("TssInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyAntiDataRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TssInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TssInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TssInfo" => Ok(GeneratedField::TssInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyAntiDataRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyAntiDataRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyAntiDataRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut tss_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TssInfo => {
                            if tss_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TssInfo"));
                            }
                            tss_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyAntiDataRequest {
                    tss_info: tss_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyAntiDataRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyBuffChange {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.old_buff_id.is_some() {
            len += 1;
        }
        if self.new_buff_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyBuffChange", len)?;
        if let Some(v) = self.old_buff_id.as_ref() {
            struct_ser.serialize_field("OldBuffId", v)?;
        }
        if let Some(v) = self.new_buff_id.as_ref() {
            struct_ser.serialize_field("NewBuffId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyBuffChange {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OldBuffId",
            "NewBuffId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OldBuffId,
            NewBuffId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "OldBuffId" => Ok(GeneratedField::OldBuffId),
                            "NewBuffId" => Ok(GeneratedField::NewBuffId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyBuffChange;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyBuffChange")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyBuffChange, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut old_buff_id__ = None;
                let mut new_buff_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OldBuffId => {
                            if old_buff_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OldBuffId"));
                            }
                            old_buff_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NewBuffId => {
                            if new_buff_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NewBuffId"));
                            }
                            new_buff_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(NotifyBuffChange {
                    old_buff_id: old_buff_id__,
                    new_buff_id: new_buff_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyBuffChange", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyBuildFurnitureOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.op_type.is_some() {
            len += 1;
        }
        if self.furniture.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyBuildFurnitureOp", len)?;
        if let Some(v) = self.op_type.as_ref() {
            let v = BuildFurnitureOpType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("OpType", &v)?;
        }
        if let Some(v) = self.furniture.as_ref() {
            struct_ser.serialize_field("Furniture", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyBuildFurnitureOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OpType",
            "Furniture",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OpType,
            Furniture,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "OpType" => Ok(GeneratedField::OpType),
                            "Furniture" => Ok(GeneratedField::Furniture),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyBuildFurnitureOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyBuildFurnitureOp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyBuildFurnitureOp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut op_type__ = None;
                let mut furniture__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OpType => {
                            if op_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OpType"));
                            }
                            op_type__ = map_.next_value::<::std::option::Option<BuildFurnitureOpType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Furniture => {
                            if furniture__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Furniture"));
                            }
                            furniture__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyBuildFurnitureOp {
                    op_type: op_type__,
                    furniture: furniture__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyBuildFurnitureOp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyClientKickOff {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyClientKickOff", len)?;
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyClientKickOff {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyClientKickOff;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyClientKickOff")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyClientKickOff, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(NotifyClientKickOff {
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyClientKickOff", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyCommunityHomeLandDecorationInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyCommunityHomeLandDecorationInfo", len)?;
        if let Some(v) = self.request.as_ref() {
            struct_ser.serialize_field("Request", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyCommunityHomeLandDecorationInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Request",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Request,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Request" => Ok(GeneratedField::Request),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyCommunityHomeLandDecorationInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyCommunityHomeLandDecorationInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyCommunityHomeLandDecorationInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Request => {
                            if request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Request"));
                            }
                            request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyCommunityHomeLandDecorationInfo {
                    request: request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyCommunityHomeLandDecorationInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyCommunityHomeLandDecorationInfoRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_outer.is_some() {
            len += 1;
        }
        if self.decoration_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyCommunityHomeLandDecorationInfoRequest", len)?;
        if let Some(v) = self.is_outer.as_ref() {
            struct_ser.serialize_field("IsOuter", v)?;
        }
        if let Some(v) = self.decoration_info.as_ref() {
            struct_ser.serialize_field("DecorationInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyCommunityHomeLandDecorationInfoRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsOuter",
            "DecorationInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsOuter,
            DecorationInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsOuter" => Ok(GeneratedField::IsOuter),
                            "DecorationInfo" => Ok(GeneratedField::DecorationInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyCommunityHomeLandDecorationInfoRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyCommunityHomeLandDecorationInfoRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyCommunityHomeLandDecorationInfoRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_outer__ = None;
                let mut decoration_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsOuter => {
                            if is_outer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsOuter"));
                            }
                            is_outer__ = map_.next_value()?;
                        }
                        GeneratedField::DecorationInfo => {
                            if decoration_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DecorationInfo"));
                            }
                            decoration_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyCommunityHomeLandDecorationInfoRequest {
                    is_outer: is_outer__,
                    decoration_info: decoration_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyCommunityHomeLandDecorationInfoRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyCommunityHomeLandHousingTypeUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyCommunityHomeLandHousingTypeUpdate", len)?;
        if let Some(v) = self.request.as_ref() {
            struct_ser.serialize_field("Request", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyCommunityHomeLandHousingTypeUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Request",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Request,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Request" => Ok(GeneratedField::Request),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyCommunityHomeLandHousingTypeUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyCommunityHomeLandHousingTypeUpdate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyCommunityHomeLandHousingTypeUpdate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Request => {
                            if request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Request"));
                            }
                            request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyCommunityHomeLandHousingTypeUpdate {
                    request: request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyCommunityHomeLandHousingTypeUpdate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyCommunityHomeLandHousingTypeUpdateRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.community_id.is_some() {
            len += 1;
        }
        if self.homeland_id.is_some() {
            len += 1;
        }
        if self.old_housing_type.is_some() {
            len += 1;
        }
        if self.new_housing_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyCommunityHomeLandHousingTypeUpdateRequest", len)?;
        if let Some(v) = self.community_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CommunityId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.homeland_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HomelandId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.old_housing_type.as_ref() {
            struct_ser.serialize_field("OldHousingType", v)?;
        }
        if let Some(v) = self.new_housing_type.as_ref() {
            struct_ser.serialize_field("NewHousingType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyCommunityHomeLandHousingTypeUpdateRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CommunityId",
            "HomelandId",
            "OldHousingType",
            "NewHousingType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CommunityId,
            HomelandId,
            OldHousingType,
            NewHousingType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CommunityId" => Ok(GeneratedField::CommunityId),
                            "HomelandId" => Ok(GeneratedField::HomelandId),
                            "OldHousingType" => Ok(GeneratedField::OldHousingType),
                            "NewHousingType" => Ok(GeneratedField::NewHousingType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyCommunityHomeLandHousingTypeUpdateRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyCommunityHomeLandHousingTypeUpdateRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyCommunityHomeLandHousingTypeUpdateRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut community_id__ = None;
                let mut homeland_id__ = None;
                let mut old_housing_type__ = None;
                let mut new_housing_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CommunityId => {
                            if community_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CommunityId"));
                            }
                            community_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HomelandId => {
                            if homeland_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomelandId"));
                            }
                            homeland_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OldHousingType => {
                            if old_housing_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OldHousingType"));
                            }
                            old_housing_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NewHousingType => {
                            if new_housing_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NewHousingType"));
                            }
                            new_housing_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(NotifyCommunityHomeLandHousingTypeUpdateRequest {
                    community_id: community_id__,
                    homeland_id: homeland_id__,
                    old_housing_type: old_housing_type__,
                    new_housing_type: new_housing_type__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyCommunityHomeLandHousingTypeUpdateRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyCommunityHomeLandUnlockedAreasUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyCommunityHomeLandUnlockedAreasUpdate", len)?;
        if let Some(v) = self.request.as_ref() {
            struct_ser.serialize_field("Request", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyCommunityHomeLandUnlockedAreasUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Request",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Request,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Request" => Ok(GeneratedField::Request),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyCommunityHomeLandUnlockedAreasUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyCommunityHomeLandUnlockedAreasUpdate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyCommunityHomeLandUnlockedAreasUpdate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Request => {
                            if request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Request"));
                            }
                            request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyCommunityHomeLandUnlockedAreasUpdate {
                    request: request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyCommunityHomeLandUnlockedAreasUpdate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyCommunityHomeLandUnlockedAreasUpdateRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.community_id.is_some() {
            len += 1;
        }
        if self.homeland_id.is_some() {
            len += 1;
        }
        if !self.unlock_outer_areas.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyCommunityHomeLandUnlockedAreasUpdateRequest", len)?;
        if let Some(v) = self.community_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CommunityId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.homeland_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HomelandId", ToString::to_string(&v).as_str())?;
        }
        if !self.unlock_outer_areas.is_empty() {
            struct_ser.serialize_field("UnlockOuterAreas", &self.unlock_outer_areas)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyCommunityHomeLandUnlockedAreasUpdateRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CommunityId",
            "HomelandId",
            "UnlockOuterAreas",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CommunityId,
            HomelandId,
            UnlockOuterAreas,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CommunityId" => Ok(GeneratedField::CommunityId),
                            "HomelandId" => Ok(GeneratedField::HomelandId),
                            "UnlockOuterAreas" => Ok(GeneratedField::UnlockOuterAreas),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyCommunityHomeLandUnlockedAreasUpdateRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyCommunityHomeLandUnlockedAreasUpdateRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyCommunityHomeLandUnlockedAreasUpdateRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut community_id__ = None;
                let mut homeland_id__ = None;
                let mut unlock_outer_areas__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CommunityId => {
                            if community_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CommunityId"));
                            }
                            community_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HomelandId => {
                            if homeland_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomelandId"));
                            }
                            homeland_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::UnlockOuterAreas => {
                            if unlock_outer_areas__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockOuterAreas"));
                            }
                            unlock_outer_areas__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(NotifyCommunityHomeLandUnlockedAreasUpdateRequest {
                    community_id: community_id__,
                    homeland_id: homeland_id__,
                    unlock_outer_areas: unlock_outer_areas__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyCommunityHomeLandUnlockedAreasUpdateRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyEnterWorld {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyEnterWorld", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyEnterWorld {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyEnterWorld;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyEnterWorld")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyEnterWorld, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyEnterWorld {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyEnterWorld", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyEnterWorldRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.account_id.is_some() {
            len += 1;
        }
        if self.token.is_some() {
            len += 1;
        }
        if self.scene_ip.is_some() {
            len += 1;
        }
        if self.scene_port.is_some() {
            len += 1;
        }
        if self.transform.is_some() {
            len += 1;
        }
        if self.scene_line_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyEnterWorldRequest", len)?;
        if let Some(v) = self.account_id.as_ref() {
            struct_ser.serialize_field("AccountId", v)?;
        }
        if let Some(v) = self.token.as_ref() {
            struct_ser.serialize_field("Token", v)?;
        }
        if let Some(v) = self.scene_ip.as_ref() {
            struct_ser.serialize_field("SceneIp", v)?;
        }
        if let Some(v) = self.scene_port.as_ref() {
            struct_ser.serialize_field("ScenePort", v)?;
        }
        if let Some(v) = self.transform.as_ref() {
            struct_ser.serialize_field("Transform", v)?;
        }
        if let Some(v) = self.scene_line_data.as_ref() {
            struct_ser.serialize_field("SceneLineData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyEnterWorldRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AccountId",
            "Token",
            "SceneIp",
            "ScenePort",
            "Transform",
            "SceneLineData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AccountId,
            Token,
            SceneIp,
            ScenePort,
            Transform,
            SceneLineData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AccountId" => Ok(GeneratedField::AccountId),
                            "Token" => Ok(GeneratedField::Token),
                            "SceneIp" => Ok(GeneratedField::SceneIp),
                            "ScenePort" => Ok(GeneratedField::ScenePort),
                            "Transform" => Ok(GeneratedField::Transform),
                            "SceneLineData" => Ok(GeneratedField::SceneLineData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyEnterWorldRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyEnterWorldRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyEnterWorldRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut account_id__ = None;
                let mut token__ = None;
                let mut scene_ip__ = None;
                let mut scene_port__ = None;
                let mut transform__ = None;
                let mut scene_line_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AccountId => {
                            if account_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccountId"));
                            }
                            account_id__ = map_.next_value()?;
                        }
                        GeneratedField::Token => {
                            if token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Token"));
                            }
                            token__ = map_.next_value()?;
                        }
                        GeneratedField::SceneIp => {
                            if scene_ip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneIp"));
                            }
                            scene_ip__ = map_.next_value()?;
                        }
                        GeneratedField::ScenePort => {
                            if scene_port__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ScenePort"));
                            }
                            scene_port__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Transform => {
                            if transform__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Transform"));
                            }
                            transform__ = map_.next_value()?;
                        }
                        GeneratedField::SceneLineData => {
                            if scene_line_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneLineData"));
                            }
                            scene_line_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyEnterWorldRequest {
                    account_id: account_id__,
                    token: token__,
                    scene_ip: scene_ip__,
                    scene_port: scene_port__,
                    transform: transform__,
                    scene_line_data: scene_line_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyEnterWorldRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyFunctionParams {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.close_function.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyFunctionParams", len)?;
        if !self.close_function.is_empty() {
            struct_ser.serialize_field("CloseFunction", &self.close_function)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyFunctionParams {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CloseFunction",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CloseFunction,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CloseFunction" => Ok(GeneratedField::CloseFunction),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyFunctionParams;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyFunctionParams")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyFunctionParams, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut close_function__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CloseFunction => {
                            if close_function__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CloseFunction"));
                            }
                            close_function__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(NotifyFunctionParams {
                    close_function: close_function__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyFunctionParams", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyHomelandBuildFurnitureOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyHomelandBuildFurnitureOp", len)?;
        if let Some(v) = self.request.as_ref() {
            struct_ser.serialize_field("Request", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyHomelandBuildFurnitureOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Request",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Request,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Request" => Ok(GeneratedField::Request),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyHomelandBuildFurnitureOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyHomelandBuildFurnitureOp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyHomelandBuildFurnitureOp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Request => {
                            if request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Request"));
                            }
                            request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyHomelandBuildFurnitureOp {
                    request: request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyHomelandBuildFurnitureOp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyHomelandBuildFurnitureOpRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.community_id.is_some() {
            len += 1;
        }
        if self.homeland_id.is_some() {
            len += 1;
        }
        if self.is_outer.is_some() {
            len += 1;
        }
        if self.scene_guid.is_some() {
            len += 1;
        }
        if !self.build_furniture_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyHomelandBuildFurnitureOpRequest", len)?;
        if let Some(v) = self.community_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CommunityId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.homeland_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HomelandId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.is_outer.as_ref() {
            struct_ser.serialize_field("IsOuter", v)?;
        }
        if let Some(v) = self.scene_guid.as_ref() {
            struct_ser.serialize_field("SceneGuid", v)?;
        }
        if !self.build_furniture_infos.is_empty() {
            struct_ser.serialize_field("BuildFurnitureInfos", &self.build_furniture_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyHomelandBuildFurnitureOpRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CommunityId",
            "HomelandId",
            "IsOuter",
            "SceneGuid",
            "BuildFurnitureInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CommunityId,
            HomelandId,
            IsOuter,
            SceneGuid,
            BuildFurnitureInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CommunityId" => Ok(GeneratedField::CommunityId),
                            "HomelandId" => Ok(GeneratedField::HomelandId),
                            "IsOuter" => Ok(GeneratedField::IsOuter),
                            "SceneGuid" => Ok(GeneratedField::SceneGuid),
                            "BuildFurnitureInfos" => Ok(GeneratedField::BuildFurnitureInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyHomelandBuildFurnitureOpRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyHomelandBuildFurnitureOpRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyHomelandBuildFurnitureOpRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut community_id__ = None;
                let mut homeland_id__ = None;
                let mut is_outer__ = None;
                let mut scene_guid__ = None;
                let mut build_furniture_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CommunityId => {
                            if community_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CommunityId"));
                            }
                            community_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HomelandId => {
                            if homeland_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomelandId"));
                            }
                            homeland_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsOuter => {
                            if is_outer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsOuter"));
                            }
                            is_outer__ = map_.next_value()?;
                        }
                        GeneratedField::SceneGuid => {
                            if scene_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneGuid"));
                            }
                            scene_guid__ = map_.next_value()?;
                        }
                        GeneratedField::BuildFurnitureInfos => {
                            if build_furniture_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuildFurnitureInfos"));
                            }
                            build_furniture_infos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(NotifyHomelandBuildFurnitureOpRequest {
                    community_id: community_id__,
                    homeland_id: homeland_id__,
                    is_outer: is_outer__,
                    scene_guid: scene_guid__,
                    build_furniture_infos: build_furniture_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyHomelandBuildFurnitureOpRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyKickOutOff {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyKickOutOff", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyKickOutOff {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyKickOutOff;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyKickOutOff")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyKickOutOff, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyKickOutOff {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyKickOutOff", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyKickOutOffRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyKickOutOffRequest", len)?;
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyKickOutOffRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyKickOutOffRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyKickOutOffRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyKickOutOffRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(NotifyKickOutOffRequest {
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyKickOutOffRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyLoadSceneEnd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.resp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyLoadSceneEnd", len)?;
        if let Some(v) = self.resp.as_ref() {
            struct_ser.serialize_field("Resp", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyLoadSceneEnd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Resp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Resp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Resp" => Ok(GeneratedField::Resp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyLoadSceneEnd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyLoadSceneEnd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyLoadSceneEnd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut resp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Resp => {
                            if resp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Resp"));
                            }
                            resp__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyLoadSceneEnd {
                    resp: resp__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyLoadSceneEnd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyLoadSceneEndResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scene_id.is_some() {
            len += 1;
        }
        if self.scene_guid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyLoadSceneEndResponse", len)?;
        if let Some(v) = self.scene_id.as_ref() {
            struct_ser.serialize_field("SceneId", v)?;
        }
        if let Some(v) = self.scene_guid.as_ref() {
            struct_ser.serialize_field("SceneGuid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyLoadSceneEndResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SceneId",
            "SceneGuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SceneId,
            SceneGuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SceneId" => Ok(GeneratedField::SceneId),
                            "SceneGuid" => Ok(GeneratedField::SceneGuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyLoadSceneEndResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyLoadSceneEndResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyLoadSceneEndResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_id__ = None;
                let mut scene_guid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SceneId => {
                            if scene_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneId"));
                            }
                            scene_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SceneGuid => {
                            if scene_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneGuid"));
                            }
                            scene_guid__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyLoadSceneEndResponse {
                    scene_id: scene_id__,
                    scene_guid: scene_guid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyLoadSceneEndResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyPlayerBeginInteraction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyPlayerBeginInteraction", len)?;
        if let Some(v) = self.v_param.as_ref() {
            struct_ser.serialize_field("VParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyPlayerBeginInteraction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VParam" => Ok(GeneratedField::VParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyPlayerBeginInteraction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyPlayerBeginInteraction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyPlayerBeginInteraction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VParam => {
                            if v_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VParam"));
                            }
                            v_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyPlayerBeginInteraction {
                    v_param: v_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyPlayerBeginInteraction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyPlayerBeginInteractionParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.object_id.is_some() {
            len += 1;
        }
        if self.template_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyPlayerBeginInteractionParam", len)?;
        if let Some(v) = self.object_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ObjectId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.template_id.as_ref() {
            struct_ser.serialize_field("TemplateId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyPlayerBeginInteractionParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ObjectId",
            "TemplateId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ObjectId,
            TemplateId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ObjectId" => Ok(GeneratedField::ObjectId),
                            "TemplateId" => Ok(GeneratedField::TemplateId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyPlayerBeginInteractionParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyPlayerBeginInteractionParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyPlayerBeginInteractionParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut object_id__ = None;
                let mut template_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ObjectId => {
                            if object_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ObjectId"));
                            }
                            object_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TemplateId => {
                            if template_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TemplateId"));
                            }
                            template_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(NotifyPlayerBeginInteractionParam {
                    object_id: object_id__,
                    template_id: template_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyPlayerBeginInteractionParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyReviveUser {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_actor_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyReviveUser", len)?;
        if let Some(v) = self.v_actor_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("VActorUuid", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyReviveUser {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VActorUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VActorUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VActorUuid" => Ok(GeneratedField::VActorUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyReviveUser;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyReviveUser")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyReviveUser, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_actor_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VActorUuid => {
                            if v_actor_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VActorUuid"));
                            }
                            v_actor_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(NotifyReviveUser {
                    v_actor_uuid: v_actor_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyReviveUser", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyServerCloseFunction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyServerCloseFunction", len)?;
        if let Some(v) = self.v_param.as_ref() {
            struct_ser.serialize_field("VParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyServerCloseFunction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VParam" => Ok(GeneratedField::VParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyServerCloseFunction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyServerCloseFunction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyServerCloseFunction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VParam => {
                            if v_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VParam"));
                            }
                            v_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyServerCloseFunction {
                    v_param: v_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyServerCloseFunction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifySwitchScene {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifySwitchScene", len)?;
        if let Some(v) = self.request.as_ref() {
            struct_ser.serialize_field("Request", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifySwitchScene {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Request",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Request,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Request" => Ok(GeneratedField::Request),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifySwitchScene;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifySwitchScene")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifySwitchScene, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Request => {
                            if request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Request"));
                            }
                            request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifySwitchScene {
                    request: request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifySwitchScene", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifySwitchSceneEnd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.resp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifySwitchSceneEnd", len)?;
        if let Some(v) = self.resp.as_ref() {
            struct_ser.serialize_field("Resp", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifySwitchSceneEnd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Resp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Resp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Resp" => Ok(GeneratedField::Resp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifySwitchSceneEnd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifySwitchSceneEnd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifySwitchSceneEnd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut resp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Resp => {
                            if resp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Resp"));
                            }
                            resp__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifySwitchSceneEnd {
                    resp: resp__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifySwitchSceneEnd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifySwitchSceneRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.transfer_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifySwitchSceneRequest", len)?;
        if let Some(v) = self.transfer_param.as_ref() {
            struct_ser.serialize_field("TransferParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifySwitchSceneRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TransferParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TransferParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TransferParam" => Ok(GeneratedField::TransferParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifySwitchSceneRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifySwitchSceneRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifySwitchSceneRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transfer_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TransferParam => {
                            if transfer_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TransferParam"));
                            }
                            transfer_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifySwitchSceneRequest {
                    transfer_param: transfer_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifySwitchSceneRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyTimerList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.timer_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyTimerList", len)?;
        if let Some(v) = self.timer_info.as_ref() {
            struct_ser.serialize_field("TimerInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyTimerList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TimerInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TimerInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TimerInfo" => Ok(GeneratedField::TimerInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyTimerList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyTimerList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyTimerList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timer_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TimerInfo => {
                            if timer_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TimerInfo"));
                            }
                            timer_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyTimerList {
                    timer_info: timer_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyTimerList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyTimerListParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.timer_info_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyTimerListParam", len)?;
        if !self.timer_info_list.is_empty() {
            struct_ser.serialize_field("TimerInfoList", &self.timer_info_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyTimerListParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TimerInfoList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TimerInfoList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TimerInfoList" => Ok(GeneratedField::TimerInfoList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyTimerListParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyTimerListParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyTimerListParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timer_info_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TimerInfoList => {
                            if timer_info_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TimerInfoList"));
                            }
                            timer_info_list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(NotifyTimerListParam {
                    timer_info_list: timer_info_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyTimerListParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyTimerUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.timer_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyTimerUpdate", len)?;
        if let Some(v) = self.timer_info.as_ref() {
            struct_ser.serialize_field("TimerInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyTimerUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TimerInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TimerInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TimerInfo" => Ok(GeneratedField::TimerInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyTimerUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyTimerUpdate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyTimerUpdate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timer_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TimerInfo => {
                            if timer_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TimerInfo"));
                            }
                            timer_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyTimerUpdate {
                    timer_info: timer_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyTimerUpdate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NotifyUserCloseFunction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.NotifyUserCloseFunction", len)?;
        if let Some(v) = self.v_param.as_ref() {
            struct_ser.serialize_field("VParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NotifyUserCloseFunction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VParam" => Ok(GeneratedField::VParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NotifyUserCloseFunction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.NotifyUserCloseFunction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NotifyUserCloseFunction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VParam => {
                            if v_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VParam"));
                            }
                            v_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(NotifyUserCloseFunction {
                    v_param: v_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.NotifyUserCloseFunction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Package {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.max_capacity.is_some() {
            len += 1;
        }
        if !self.item_cd.is_empty() {
            len += 1;
        }
        if !self.items.is_empty() {
            len += 1;
        }
        if self.public_cd.is_some() {
            len += 1;
        }
        if self.change_version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Package", len)?;
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("Type", v)?;
        }
        if let Some(v) = self.max_capacity.as_ref() {
            struct_ser.serialize_field("MaxCapacity", v)?;
        }
        if !self.item_cd.is_empty() {
            let v: std::collections::HashMap<_, _> = self.item_cd.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("ItemCd", &v)?;
        }
        if !self.items.is_empty() {
            struct_ser.serialize_field("Items", &self.items)?;
        }
        if let Some(v) = self.public_cd.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("PublicCd", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.change_version.as_ref() {
            struct_ser.serialize_field("ChangeVersion", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Package {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Type",
            "MaxCapacity",
            "ItemCd",
            "Items",
            "PublicCd",
            "ChangeVersion",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            MaxCapacity,
            ItemCd,
            Items,
            PublicCd,
            ChangeVersion,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Type" => Ok(GeneratedField::Type),
                            "MaxCapacity" => Ok(GeneratedField::MaxCapacity),
                            "ItemCd" => Ok(GeneratedField::ItemCd),
                            "Items" => Ok(GeneratedField::Items),
                            "PublicCd" => Ok(GeneratedField::PublicCd),
                            "ChangeVersion" => Ok(GeneratedField::ChangeVersion),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Package;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Package")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Package, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut max_capacity__ = None;
                let mut item_cd__ = None;
                let mut items__ = None;
                let mut public_cd__ = None;
                let mut change_version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxCapacity => {
                            if max_capacity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaxCapacity"));
                            }
                            max_capacity__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ItemCd => {
                            if item_cd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ItemCd"));
                            }
                            item_cd__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Items"));
                            }
                            items__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::PublicCd => {
                            if public_cd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PublicCd"));
                            }
                            public_cd__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ChangeVersion => {
                            if change_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ChangeVersion"));
                            }
                            change_version__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Package {
                    r#type: r#type__,
                    max_capacity: max_capacity__,
                    item_cd: item_cd__.unwrap_or_default(),
                    items: items__.unwrap_or_default(),
                    public_cd: public_cd__,
                    change_version: change_version__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Package", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ParkourRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.time.is_some() {
            len += 1;
        }
        if self.state.is_some() {
            len += 1;
        }
        if self.perfect_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ParkourRecord", len)?;
        if let Some(v) = self.time.as_ref() {
            struct_ser.serialize_field("Time", v)?;
        }
        if let Some(v) = self.state.as_ref() {
            struct_ser.serialize_field("State", v)?;
        }
        if let Some(v) = self.perfect_time.as_ref() {
            struct_ser.serialize_field("PerfectTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ParkourRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Time",
            "State",
            "PerfectTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Time,
            State,
            PerfectTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Time" => Ok(GeneratedField::Time),
                            "State" => Ok(GeneratedField::State),
                            "PerfectTime" => Ok(GeneratedField::PerfectTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ParkourRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ParkourRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ParkourRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut time__ = None;
                let mut state__ = None;
                let mut perfect_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Time"));
                            }
                            time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("State"));
                            }
                            state__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PerfectTime => {
                            if perfect_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PerfectTime"));
                            }
                            perfect_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ParkourRecord {
                    time: time__,
                    state: state__,
                    perfect_time: perfect_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ParkourRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ParkourRecordList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.record_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ParkourRecordList", len)?;
        if !self.record_list.is_empty() {
            struct_ser.serialize_field("RecordList", &self.record_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ParkourRecordList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RecordList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RecordList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RecordList" => Ok(GeneratedField::RecordList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ParkourRecordList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ParkourRecordList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ParkourRecordList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut record_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RecordList => {
                            if record_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RecordList"));
                            }
                            record_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ParkourRecordList {
                    record_list: record_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ParkourRecordList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PassengerChangeParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_add_passenger.is_some() {
            len += 1;
        }
        if self.add_or_remove_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PassengerChangeParam", len)?;
        if let Some(v) = self.is_add_passenger.as_ref() {
            struct_ser.serialize_field("IsAddPassenger", v)?;
        }
        if let Some(v) = self.add_or_remove_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("AddOrRemoveUuid", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PassengerChangeParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsAddPassenger",
            "AddOrRemoveUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsAddPassenger,
            AddOrRemoveUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsAddPassenger" => Ok(GeneratedField::IsAddPassenger),
                            "AddOrRemoveUuid" => Ok(GeneratedField::AddOrRemoveUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PassengerChangeParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PassengerChangeParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PassengerChangeParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_add_passenger__ = None;
                let mut add_or_remove_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsAddPassenger => {
                            if is_add_passenger__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsAddPassenger"));
                            }
                            is_add_passenger__ = map_.next_value()?;
                        }
                        GeneratedField::AddOrRemoveUuid => {
                            if add_or_remove_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AddOrRemoveUuid"));
                            }
                            add_or_remove_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PassengerChangeParam {
                    is_add_passenger: is_add_passenger__,
                    add_or_remove_uuid: add_or_remove_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PassengerChangeParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PassiveSkillInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if self.target_uuid.is_some() {
            len += 1;
        }
        if self.stage_begin_time.is_some() {
            len += 1;
        }
        if self.begin_time.is_some() {
            len += 1;
        }
        if self.stage_play_num.is_some() {
            len += 1;
        }
        if self.skill_id.is_some() {
            len += 1;
        }
        if self.skill_level.is_some() {
            len += 1;
        }
        if self.skill_stage.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PassiveSkillInfo", len)?;
        if let Some(v) = self.uuid.as_ref() {
            struct_ser.serialize_field("Uuid", v)?;
        }
        if let Some(v) = self.target_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.stage_begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("StageBeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.stage_play_num.as_ref() {
            struct_ser.serialize_field("StagePlayNum", v)?;
        }
        if let Some(v) = self.skill_id.as_ref() {
            struct_ser.serialize_field("SkillId", v)?;
        }
        if let Some(v) = self.skill_level.as_ref() {
            struct_ser.serialize_field("SkillLevel", v)?;
        }
        if let Some(v) = self.skill_stage.as_ref() {
            struct_ser.serialize_field("SkillStage", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PassiveSkillInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "TargetUuid",
            "StageBeginTime",
            "BeginTime",
            "StagePlayNum",
            "SkillId",
            "SkillLevel",
            "SkillStage",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            TargetUuid,
            StageBeginTime,
            BeginTime,
            StagePlayNum,
            SkillId,
            SkillLevel,
            SkillStage,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            "StageBeginTime" => Ok(GeneratedField::StageBeginTime),
                            "BeginTime" => Ok(GeneratedField::BeginTime),
                            "StagePlayNum" => Ok(GeneratedField::StagePlayNum),
                            "SkillId" => Ok(GeneratedField::SkillId),
                            "SkillLevel" => Ok(GeneratedField::SkillLevel),
                            "SkillStage" => Ok(GeneratedField::SkillStage),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PassiveSkillInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PassiveSkillInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PassiveSkillInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut target_uuid__ = None;
                let mut stage_begin_time__ = None;
                let mut begin_time__ = None;
                let mut stage_play_num__ = None;
                let mut skill_id__ = None;
                let mut skill_level__ = None;
                let mut skill_stage__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StageBeginTime => {
                            if stage_begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StageBeginTime"));
                            }
                            stage_begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BeginTime => {
                            if begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeginTime"));
                            }
                            begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StagePlayNum => {
                            if stage_play_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StagePlayNum"));
                            }
                            stage_play_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillId => {
                            if skill_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillId"));
                            }
                            skill_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillLevel => {
                            if skill_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillLevel"));
                            }
                            skill_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillStage => {
                            if skill_stage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillStage"));
                            }
                            skill_stage__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PassiveSkillInfo {
                    uuid: uuid__,
                    target_uuid: target_uuid__,
                    stage_begin_time: stage_begin_time__,
                    begin_time: begin_time__,
                    stage_play_num: stage_play_num__,
                    skill_id: skill_id__,
                    skill_level: skill_level__,
                    skill_stage: skill_stage__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PassiveSkillInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PathNode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.x.is_some() {
            len += 1;
        }
        if self.y.is_some() {
            len += 1;
        }
        if self.z.is_some() {
            len += 1;
        }
        if self.is_before.is_some() {
            len += 1;
        }
        if self.is_ground.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PathNode", len)?;
        if let Some(v) = self.x.as_ref() {
            struct_ser.serialize_field("X", v)?;
        }
        if let Some(v) = self.y.as_ref() {
            struct_ser.serialize_field("Y", v)?;
        }
        if let Some(v) = self.z.as_ref() {
            struct_ser.serialize_field("Z", v)?;
        }
        if let Some(v) = self.is_before.as_ref() {
            struct_ser.serialize_field("IsBefore", v)?;
        }
        if let Some(v) = self.is_ground.as_ref() {
            struct_ser.serialize_field("IsGround", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PathNode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "X",
            "Y",
            "Z",
            "IsBefore",
            "IsGround",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            X,
            Y,
            Z,
            IsBefore,
            IsGround,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "X" => Ok(GeneratedField::X),
                            "Y" => Ok(GeneratedField::Y),
                            "Z" => Ok(GeneratedField::Z),
                            "IsBefore" => Ok(GeneratedField::IsBefore),
                            "IsGround" => Ok(GeneratedField::IsGround),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PathNode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PathNode")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PathNode, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut x__ = None;
                let mut y__ = None;
                let mut z__ = None;
                let mut is_before__ = None;
                let mut is_ground__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::X => {
                            if x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("X"));
                            }
                            x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Y => {
                            if y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Y"));
                            }
                            y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Z => {
                            if z__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Z"));
                            }
                            z__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsBefore => {
                            if is_before__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsBefore"));
                            }
                            is_before__ = map_.next_value()?;
                        }
                        GeneratedField::IsGround => {
                            if is_ground__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsGround"));
                            }
                            is_ground__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PathNode {
                    x: x__,
                    y: y__,
                    z: z__,
                    is_before: is_before__,
                    is_ground: is_ground__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PathNode", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PathNodeList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if !self.nodes.is_empty() {
            len += 1;
        }
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PathNodeList", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if !self.nodes.is_empty() {
            struct_ser.serialize_field("Nodes", &self.nodes)?;
        }
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PathNodeList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "Nodes",
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            Nodes,
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "Nodes" => Ok(GeneratedField::Nodes),
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PathNodeList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PathNodeList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PathNodeList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut nodes__ = None;
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Nodes => {
                            if nodes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Nodes"));
                            }
                            nodes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(PathNodeList {
                    uuid: uuid__,
                    nodes: nodes__.unwrap_or_default(),
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PathNodeList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PathPointChangeParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.operation.is_some() {
            len += 1;
        }
        if self.add_point.is_some() {
            len += 1;
        }
        if self.remove_point_count.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PathPointChangeParam", len)?;
        if let Some(v) = self.operation.as_ref() {
            struct_ser.serialize_field("Operation", v)?;
        }
        if let Some(v) = self.add_point.as_ref() {
            struct_ser.serialize_field("AddPoint", v)?;
        }
        if let Some(v) = self.remove_point_count.as_ref() {
            struct_ser.serialize_field("RemovePointCount", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PathPointChangeParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Operation",
            "AddPoint",
            "RemovePointCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Operation,
            AddPoint,
            RemovePointCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Operation" => Ok(GeneratedField::Operation),
                            "AddPoint" => Ok(GeneratedField::AddPoint),
                            "RemovePointCount" => Ok(GeneratedField::RemovePointCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PathPointChangeParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PathPointChangeParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PathPointChangeParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut operation__ = None;
                let mut add_point__ = None;
                let mut remove_point_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Operation => {
                            if operation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Operation"));
                            }
                            operation__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AddPoint => {
                            if add_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AddPoint"));
                            }
                            add_point__ = map_.next_value()?;
                        }
                        GeneratedField::RemovePointCount => {
                            if remove_point_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RemovePointCount"));
                            }
                            remove_point_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PathPointChangeParam {
                    operation: operation__,
                    add_point: add_point__,
                    remove_point_count: remove_point_count__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PathPointChangeParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PayData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.pay_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PayData", len)?;
        if !self.pay_data.is_empty() {
            struct_ser.serialize_field("PayData", &self.pay_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PayData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PayData_",
            "PayData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PayData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PayData" | "PayData_" => Ok(GeneratedField::PayData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PayData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PayData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PayData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pay_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PayData => {
                            if pay_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PayData"));
                            }
                            pay_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(PayData {
                    pay_data: pay_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PayData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PayOrderList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.pay_order_list.is_empty() {
            len += 1;
        }
        if !self.pay_refund_list.is_empty() {
            len += 1;
        }
        if self.first_pay.is_some() {
            len += 1;
        }
        if !self.order_list.is_empty() {
            len += 1;
        }
        if !self.order_index_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PayOrderList", len)?;
        if !self.pay_order_list.is_empty() {
            struct_ser.serialize_field("PayOrderList", &self.pay_order_list)?;
        }
        if !self.pay_refund_list.is_empty() {
            struct_ser.serialize_field("PayRefundList", &self.pay_refund_list)?;
        }
        if let Some(v) = self.first_pay.as_ref() {
            struct_ser.serialize_field("FirstPay", v)?;
        }
        if !self.order_list.is_empty() {
            struct_ser.serialize_field("OrderList", &self.order_list)?;
        }
        if !self.order_index_list.is_empty() {
            struct_ser.serialize_field("OrderIndexList", &self.order_index_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PayOrderList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PayOrderList_",
            "PayOrderList",
            "PayRefundList",
            "FirstPay",
            "OrderList",
            "OrderIndexList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PayOrderList,
            PayRefundList,
            FirstPay,
            OrderList,
            OrderIndexList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PayOrderList" | "PayOrderList_" => Ok(GeneratedField::PayOrderList),
                            "PayRefundList" => Ok(GeneratedField::PayRefundList),
                            "FirstPay" => Ok(GeneratedField::FirstPay),
                            "OrderList" => Ok(GeneratedField::OrderList),
                            "OrderIndexList" => Ok(GeneratedField::OrderIndexList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PayOrderList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PayOrderList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PayOrderList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pay_order_list__ = None;
                let mut pay_refund_list__ = None;
                let mut first_pay__ = None;
                let mut order_list__ = None;
                let mut order_index_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PayOrderList => {
                            if pay_order_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PayOrderList"));
                            }
                            pay_order_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PayRefundList => {
                            if pay_refund_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PayRefundList"));
                            }
                            pay_refund_list__ = Some(map_.next_value()?);
                        }
                        GeneratedField::FirstPay => {
                            if first_pay__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FirstPay"));
                            }
                            first_pay__ = map_.next_value()?;
                        }
                        GeneratedField::OrderList => {
                            if order_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OrderList"));
                            }
                            order_list__ = Some(
                                map_.next_value::<std::collections::HashMap<_, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k, v.0)).collect()
                            );
                        }
                        GeneratedField::OrderIndexList => {
                            if order_index_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OrderIndexList"));
                            }
                            order_index_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(PayOrderList {
                    pay_order_list: pay_order_list__.unwrap_or_default(),
                    pay_refund_list: pay_refund_list__.unwrap_or_default(),
                    first_pay: first_pay__,
                    order_list: order_list__.unwrap_or_default(),
                    order_index_list: order_index_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PayOrderList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersonalGroupObjectUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_param_list.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PersonalGroupObjectUpdate", len)?;
        if let Some(v) = self.v_param_list.as_ref() {
            struct_ser.serialize_field("VParamList", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersonalGroupObjectUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VParamList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VParamList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VParamList" => Ok(GeneratedField::VParamList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersonalGroupObjectUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PersonalGroupObjectUpdate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PersonalGroupObjectUpdate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_param_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VParamList => {
                            if v_param_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VParamList"));
                            }
                            v_param_list__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PersonalGroupObjectUpdate {
                    v_param_list: v_param_list__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PersonalGroupObjectUpdate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersonalObject {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.scene_obj_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PersonalObject", len)?;
        if !self.scene_obj_data.is_empty() {
            struct_ser.serialize_field("SceneObjData", &self.scene_obj_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersonalObject {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SceneObjData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SceneObjData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SceneObjData" => Ok(GeneratedField::SceneObjData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersonalObject;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PersonalObject")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PersonalObject, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_obj_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SceneObjData => {
                            if scene_obj_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneObjData"));
                            }
                            scene_obj_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(PersonalObject {
                    scene_obj_data: scene_obj_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PersonalObject", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersonalObjectAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_obj_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PersonalObjectAction", len)?;
        if let Some(v) = self.v_obj_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("VObjUuid", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersonalObjectAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VObjUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VObjUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VObjUuid" => Ok(GeneratedField::VObjUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersonalObjectAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PersonalObjectAction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PersonalObjectAction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_obj_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VObjUuid => {
                            if v_obj_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VObjUuid"));
                            }
                            v_obj_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PersonalObjectAction {
                    v_obj_uuid: v_obj_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PersonalObjectAction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersonalObjectUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PersonalObjectUpdate", len)?;
        if let Some(v) = self.v_param.as_ref() {
            struct_ser.serialize_field("VParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersonalObjectUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VParam" => Ok(GeneratedField::VParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersonalObjectUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PersonalObjectUpdate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PersonalObjectUpdate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VParam => {
                            if v_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VParam"));
                            }
                            v_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PersonalObjectUpdate {
                    v_param: v_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PersonalObjectUpdate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersonalWorldBossInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.score.is_some() {
            len += 1;
        }
        if !self.score_award_info.is_empty() {
            len += 1;
        }
        if !self.boss_award_info.is_empty() {
            len += 1;
        }
        if self.uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PersonalWorldBossInfo", len)?;
        if let Some(v) = self.score.as_ref() {
            struct_ser.serialize_field("Score", v)?;
        }
        if !self.score_award_info.is_empty() {
            struct_ser.serialize_field("ScoreAwardInfo", &self.score_award_info)?;
        }
        if !self.boss_award_info.is_empty() {
            struct_ser.serialize_field("BossAwardInfo", &self.boss_award_info)?;
        }
        if let Some(v) = self.uuid.as_ref() {
            struct_ser.serialize_field("Uuid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersonalWorldBossInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Score",
            "ScoreAwardInfo",
            "BossAwardInfo",
            "Uuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Score,
            ScoreAwardInfo,
            BossAwardInfo,
            Uuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Score" => Ok(GeneratedField::Score),
                            "ScoreAwardInfo" => Ok(GeneratedField::ScoreAwardInfo),
                            "BossAwardInfo" => Ok(GeneratedField::BossAwardInfo),
                            "Uuid" => Ok(GeneratedField::Uuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersonalWorldBossInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PersonalWorldBossInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PersonalWorldBossInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut score__ = None;
                let mut score_award_info__ = None;
                let mut boss_award_info__ = None;
                let mut uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Score => {
                            if score__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Score"));
                            }
                            score__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ScoreAwardInfo => {
                            if score_award_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ScoreAwardInfo"));
                            }
                            score_award_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::BossAwardInfo => {
                            if boss_award_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BossAwardInfo"));
                            }
                            boss_award_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PersonalWorldBossInfo {
                    score: score__,
                    score_award_info: score_award_info__.unwrap_or_default(),
                    boss_award_info: boss_award_info__.unwrap_or_default(),
                    uuid: uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PersonalWorldBossInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersonalZone {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.online_periods.is_empty() {
            len += 1;
        }
        if !self.tags.is_empty() {
            len += 1;
        }
        if !self.medals.is_empty() {
            len += 1;
        }
        if self.theme_id.is_some() {
            len += 1;
        }
        if self.business_card_style_id.is_some() {
            len += 1;
        }
        if self.avatar_frame_id.is_some() {
            len += 1;
        }
        if self.action_info.is_some() {
            len += 1;
        }
        if !self.ui_position.is_empty() {
            len += 1;
        }
        if self.title_id.is_some() {
            len += 1;
        }
        if self.fashion_refresh_flag.is_some() {
            len += 1;
        }
        if self.fashion_collect_point.is_some() {
            len += 1;
        }
        if !self.fashion_collect_quality_count.is_empty() {
            len += 1;
        }
        if !self.photos.is_empty() {
            len += 1;
        }
        if !self.unlock_target_record.is_empty() {
            len += 1;
        }
        if !self.unlock_get_reward_record.is_empty() {
            len += 1;
        }
        if self.ride_collect_point.is_some() {
            len += 1;
        }
        if !self.ride_collect_quality_count.is_empty() {
            len += 1;
        }
        if self.weapon_skin_collect_point.is_some() {
            len += 1;
        }
        if !self.photos_wall.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PersonalZone", len)?;
        if !self.online_periods.is_empty() {
            struct_ser.serialize_field("OnlinePeriods", &self.online_periods)?;
        }
        if !self.tags.is_empty() {
            struct_ser.serialize_field("Tags", &self.tags)?;
        }
        if !self.medals.is_empty() {
            struct_ser.serialize_field("Medals", &self.medals)?;
        }
        if let Some(v) = self.theme_id.as_ref() {
            struct_ser.serialize_field("ThemeId", v)?;
        }
        if let Some(v) = self.business_card_style_id.as_ref() {
            struct_ser.serialize_field("BusinessCardStyleId", v)?;
        }
        if let Some(v) = self.avatar_frame_id.as_ref() {
            struct_ser.serialize_field("AvatarFrameId", v)?;
        }
        if let Some(v) = self.action_info.as_ref() {
            struct_ser.serialize_field("ActionInfo", v)?;
        }
        if !self.ui_position.is_empty() {
            struct_ser.serialize_field("UiPosition", &self.ui_position)?;
        }
        if let Some(v) = self.title_id.as_ref() {
            struct_ser.serialize_field("TitleId", v)?;
        }
        if let Some(v) = self.fashion_refresh_flag.as_ref() {
            struct_ser.serialize_field("FashionRefreshFlag", v)?;
        }
        if let Some(v) = self.fashion_collect_point.as_ref() {
            struct_ser.serialize_field("FashionCollectPoint", v)?;
        }
        if !self.fashion_collect_quality_count.is_empty() {
            struct_ser.serialize_field("FashionCollectQualityCount", &self.fashion_collect_quality_count)?;
        }
        if !self.photos.is_empty() {
            struct_ser.serialize_field("Photos", &self.photos)?;
        }
        if !self.unlock_target_record.is_empty() {
            struct_ser.serialize_field("UnlockTargetRecord", &self.unlock_target_record)?;
        }
        if !self.unlock_get_reward_record.is_empty() {
            struct_ser.serialize_field("UnlockGetRewardRecord", &self.unlock_get_reward_record)?;
        }
        if let Some(v) = self.ride_collect_point.as_ref() {
            struct_ser.serialize_field("RideCollectPoint", v)?;
        }
        if !self.ride_collect_quality_count.is_empty() {
            struct_ser.serialize_field("RideCollectQualityCount", &self.ride_collect_quality_count)?;
        }
        if let Some(v) = self.weapon_skin_collect_point.as_ref() {
            struct_ser.serialize_field("WeaponSkinCollectPoint", v)?;
        }
        if !self.photos_wall.is_empty() {
            struct_ser.serialize_field("PhotosWall", &self.photos_wall)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersonalZone {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OnlinePeriods",
            "Tags",
            "Medals",
            "ThemeId",
            "BusinessCardStyleId",
            "AvatarFrameId",
            "ActionInfo",
            "UiPosition",
            "TitleId",
            "FashionRefreshFlag",
            "FashionCollectPoint",
            "FashionCollectQualityCount",
            "Photos",
            "UnlockTargetRecord",
            "UnlockGetRewardRecord",
            "RideCollectPoint",
            "RideCollectQualityCount",
            "WeaponSkinCollectPoint",
            "PhotosWall",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OnlinePeriods,
            Tags,
            Medals,
            ThemeId,
            BusinessCardStyleId,
            AvatarFrameId,
            ActionInfo,
            UiPosition,
            TitleId,
            FashionRefreshFlag,
            FashionCollectPoint,
            FashionCollectQualityCount,
            Photos,
            UnlockTargetRecord,
            UnlockGetRewardRecord,
            RideCollectPoint,
            RideCollectQualityCount,
            WeaponSkinCollectPoint,
            PhotosWall,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "OnlinePeriods" => Ok(GeneratedField::OnlinePeriods),
                            "Tags" => Ok(GeneratedField::Tags),
                            "Medals" => Ok(GeneratedField::Medals),
                            "ThemeId" => Ok(GeneratedField::ThemeId),
                            "BusinessCardStyleId" => Ok(GeneratedField::BusinessCardStyleId),
                            "AvatarFrameId" => Ok(GeneratedField::AvatarFrameId),
                            "ActionInfo" => Ok(GeneratedField::ActionInfo),
                            "UiPosition" => Ok(GeneratedField::UiPosition),
                            "TitleId" => Ok(GeneratedField::TitleId),
                            "FashionRefreshFlag" => Ok(GeneratedField::FashionRefreshFlag),
                            "FashionCollectPoint" => Ok(GeneratedField::FashionCollectPoint),
                            "FashionCollectQualityCount" => Ok(GeneratedField::FashionCollectQualityCount),
                            "Photos" => Ok(GeneratedField::Photos),
                            "UnlockTargetRecord" => Ok(GeneratedField::UnlockTargetRecord),
                            "UnlockGetRewardRecord" => Ok(GeneratedField::UnlockGetRewardRecord),
                            "RideCollectPoint" => Ok(GeneratedField::RideCollectPoint),
                            "RideCollectQualityCount" => Ok(GeneratedField::RideCollectQualityCount),
                            "WeaponSkinCollectPoint" => Ok(GeneratedField::WeaponSkinCollectPoint),
                            "PhotosWall" => Ok(GeneratedField::PhotosWall),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersonalZone;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PersonalZone")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PersonalZone, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut online_periods__ = None;
                let mut tags__ = None;
                let mut medals__ = None;
                let mut theme_id__ = None;
                let mut business_card_style_id__ = None;
                let mut avatar_frame_id__ = None;
                let mut action_info__ = None;
                let mut ui_position__ = None;
                let mut title_id__ = None;
                let mut fashion_refresh_flag__ = None;
                let mut fashion_collect_point__ = None;
                let mut fashion_collect_quality_count__ = None;
                let mut photos__ = None;
                let mut unlock_target_record__ = None;
                let mut unlock_get_reward_record__ = None;
                let mut ride_collect_point__ = None;
                let mut ride_collect_quality_count__ = None;
                let mut weapon_skin_collect_point__ = None;
                let mut photos_wall__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OnlinePeriods => {
                            if online_periods__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OnlinePeriods"));
                            }
                            online_periods__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::Tags => {
                            if tags__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Tags"));
                            }
                            tags__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::Medals => {
                            if medals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Medals"));
                            }
                            medals__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::ThemeId => {
                            if theme_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ThemeId"));
                            }
                            theme_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BusinessCardStyleId => {
                            if business_card_style_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BusinessCardStyleId"));
                            }
                            business_card_style_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AvatarFrameId => {
                            if avatar_frame_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AvatarFrameId"));
                            }
                            avatar_frame_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ActionInfo => {
                            if action_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActionInfo"));
                            }
                            action_info__ = map_.next_value()?;
                        }
                        GeneratedField::UiPosition => {
                            if ui_position__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UiPosition"));
                            }
                            ui_position__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TitleId => {
                            if title_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TitleId"));
                            }
                            title_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FashionRefreshFlag => {
                            if fashion_refresh_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionRefreshFlag"));
                            }
                            fashion_refresh_flag__ = map_.next_value()?;
                        }
                        GeneratedField::FashionCollectPoint => {
                            if fashion_collect_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionCollectPoint"));
                            }
                            fashion_collect_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FashionCollectQualityCount => {
                            if fashion_collect_quality_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionCollectQualityCount"));
                            }
                            fashion_collect_quality_count__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::Photos => {
                            if photos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Photos"));
                            }
                            photos__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::UnlockTargetRecord => {
                            if unlock_target_record__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockTargetRecord"));
                            }
                            unlock_target_record__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::UnlockGetRewardRecord => {
                            if unlock_get_reward_record__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockGetRewardRecord"));
                            }
                            unlock_get_reward_record__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::RideCollectPoint => {
                            if ride_collect_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RideCollectPoint"));
                            }
                            ride_collect_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RideCollectQualityCount => {
                            if ride_collect_quality_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RideCollectQualityCount"));
                            }
                            ride_collect_quality_count__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::WeaponSkinCollectPoint => {
                            if weapon_skin_collect_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WeaponSkinCollectPoint"));
                            }
                            weapon_skin_collect_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PhotosWall => {
                            if photos_wall__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PhotosWall"));
                            }
                            photos_wall__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(PersonalZone {
                    online_periods: online_periods__.unwrap_or_default(),
                    tags: tags__.unwrap_or_default(),
                    medals: medals__.unwrap_or_default(),
                    theme_id: theme_id__,
                    business_card_style_id: business_card_style_id__,
                    avatar_frame_id: avatar_frame_id__,
                    action_info: action_info__,
                    ui_position: ui_position__.unwrap_or_default(),
                    title_id: title_id__,
                    fashion_refresh_flag: fashion_refresh_flag__,
                    fashion_collect_point: fashion_collect_point__,
                    fashion_collect_quality_count: fashion_collect_quality_count__.unwrap_or_default(),
                    photos: photos__.unwrap_or_default(),
                    unlock_target_record: unlock_target_record__.unwrap_or_default(),
                    unlock_get_reward_record: unlock_get_reward_record__.unwrap_or_default(),
                    ride_collect_point: ride_collect_point__,
                    ride_collect_quality_count: ride_collect_quality_count__.unwrap_or_default(),
                    weapon_skin_collect_point: weapon_skin_collect_point__,
                    photos_wall: photos_wall__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PersonalZone", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PersonalZoneShow {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.medals.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PersonalZoneShow", len)?;
        if !self.medals.is_empty() {
            struct_ser.serialize_field("Medals", &self.medals)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PersonalZoneShow {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Medals",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Medals,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Medals" => Ok(GeneratedField::Medals),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PersonalZoneShow;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PersonalZoneShow")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PersonalZoneShow, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut medals__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Medals => {
                            if medals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Medals"));
                            }
                            medals__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(PersonalZoneShow {
                    medals: medals__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PersonalZoneShow", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhotoGraphShow {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.photo_id.is_some() {
            len += 1;
        }
        if !self.images.is_empty() {
            len += 1;
        }
        if self.render_info.is_some() {
            len += 1;
        }
        if self.photo_desc.is_some() {
            len += 1;
        }
        if self.owner_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PhotoGraphShow", len)?;
        if let Some(v) = self.photo_id.as_ref() {
            struct_ser.serialize_field("PhotoId", v)?;
        }
        if !self.images.is_empty() {
            struct_ser.serialize_field("Images", &self.images)?;
        }
        if let Some(v) = self.render_info.as_ref() {
            struct_ser.serialize_field("RenderInfo", v)?;
        }
        if let Some(v) = self.photo_desc.as_ref() {
            struct_ser.serialize_field("PhotoDesc", v)?;
        }
        if let Some(v) = self.owner_info.as_ref() {
            struct_ser.serialize_field("OwnerInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhotoGraphShow {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PhotoId",
            "Images",
            "RenderInfo",
            "PhotoDesc",
            "OwnerInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PhotoId,
            Images,
            RenderInfo,
            PhotoDesc,
            OwnerInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PhotoId" => Ok(GeneratedField::PhotoId),
                            "Images" => Ok(GeneratedField::Images),
                            "RenderInfo" => Ok(GeneratedField::RenderInfo),
                            "PhotoDesc" => Ok(GeneratedField::PhotoDesc),
                            "OwnerInfo" => Ok(GeneratedField::OwnerInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhotoGraphShow;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PhotoGraphShow")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhotoGraphShow, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut photo_id__ = None;
                let mut images__ = None;
                let mut render_info__ = None;
                let mut photo_desc__ = None;
                let mut owner_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PhotoId => {
                            if photo_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PhotoId"));
                            }
                            photo_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Images => {
                            if images__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Images"));
                            }
                            images__ = Some(map_.next_value()?);
                        }
                        GeneratedField::RenderInfo => {
                            if render_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RenderInfo"));
                            }
                            render_info__ = map_.next_value()?;
                        }
                        GeneratedField::PhotoDesc => {
                            if photo_desc__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PhotoDesc"));
                            }
                            photo_desc__ = map_.next_value()?;
                        }
                        GeneratedField::OwnerInfo => {
                            if owner_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OwnerInfo"));
                            }
                            owner_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PhotoGraphShow {
                    photo_id: photo_id__,
                    images: images__.unwrap_or_default(),
                    render_info: render_info__,
                    photo_desc: photo_desc__,
                    owner_info: owner_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PhotoGraphShow", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhotoOwnerData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.upload_char_id.is_some() {
            len += 1;
        }
        if self.expire_time.is_some() {
            len += 1;
        }
        if self.show_id.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PhotoOwnerData", len)?;
        if let Some(v) = self.upload_char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("UploadCharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.expire_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ExpireTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.show_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ShowId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("Name", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhotoOwnerData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UploadCharId",
            "ExpireTime",
            "ShowId",
            "Name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UploadCharId,
            ExpireTime,
            ShowId,
            Name,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UploadCharId" => Ok(GeneratedField::UploadCharId),
                            "ExpireTime" => Ok(GeneratedField::ExpireTime),
                            "ShowId" => Ok(GeneratedField::ShowId),
                            "Name" => Ok(GeneratedField::Name),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhotoOwnerData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PhotoOwnerData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhotoOwnerData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut upload_char_id__ = None;
                let mut expire_time__ = None;
                let mut show_id__ = None;
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UploadCharId => {
                            if upload_char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UploadCharId"));
                            }
                            upload_char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExpireTime => {
                            if expire_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExpireTime"));
                            }
                            expire_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ShowId => {
                            if show_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShowId"));
                            }
                            show_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Name"));
                            }
                            name__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PhotoOwnerData {
                    upload_char_id: upload_char_id__,
                    expire_time: expire_time__,
                    show_id: show_id__,
                    name: name__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PhotoOwnerData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PictureInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.url.is_some() {
            len += 1;
        }
        if self.verify.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PictureInfo", len)?;
        if let Some(v) = self.url.as_ref() {
            struct_ser.serialize_field("Url", v)?;
        }
        if let Some(v) = self.verify.as_ref() {
            struct_ser.serialize_field("Verify", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PictureInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Url",
            "Verify",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Url,
            Verify,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Url" => Ok(GeneratedField::Url),
                            "Verify" => Ok(GeneratedField::Verify),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PictureInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PictureInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PictureInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut url__ = None;
                let mut verify__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Url => {
                            if url__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Url"));
                            }
                            url__ = map_.next_value()?;
                        }
                        GeneratedField::Verify => {
                            if verify__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Verify"));
                            }
                            verify__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PictureInfo {
                    url: url__,
                    verify: verify__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PictureInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PictureVerify {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.size.is_some() {
            len += 1;
        }
        if self.review_start_time.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PictureVerify", len)?;
        if let Some(v) = self.size.as_ref() {
            struct_ser.serialize_field("Size", v)?;
        }
        if let Some(v) = self.review_start_time.as_ref() {
            struct_ser.serialize_field("ReviewStartTime", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Version", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PictureVerify {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Size",
            "ReviewStartTime",
            "Version",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Size,
            ReviewStartTime,
            Version,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Size" => Ok(GeneratedField::Size),
                            "ReviewStartTime" => Ok(GeneratedField::ReviewStartTime),
                            "Version" => Ok(GeneratedField::Version),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PictureVerify;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PictureVerify")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PictureVerify, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut size__ = None;
                let mut review_start_time__ = None;
                let mut version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Size"));
                            }
                            size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReviewStartTime => {
                            if review_start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReviewStartTime"));
                            }
                            review_start_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PictureVerify {
                    size: size__,
                    review_start_time: review_start_time__,
                    version: version__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PictureVerify", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PioneerData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.info_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PioneerData", len)?;
        if !self.info_map.is_empty() {
            struct_ser.serialize_field("InfoMap", &self.info_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PioneerData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "InfoMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            InfoMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "InfoMap" => Ok(GeneratedField::InfoMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PioneerData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PioneerData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PioneerData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut info_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::InfoMap => {
                            if info_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("InfoMap"));
                            }
                            info_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(PioneerData {
                    info_map: info_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PioneerData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PioneerInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.current_total.is_some() {
            len += 1;
        }
        if !self.targets.is_empty() {
            len += 1;
        }
        if !self.awards.is_empty() {
            len += 1;
        }
        if !self.entered_zones.is_empty() {
            len += 1;
        }
        if self.id.is_some() {
            len += 1;
        }
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PioneerInfo", len)?;
        if let Some(v) = self.current_total.as_ref() {
            struct_ser.serialize_field("CurrentTotal", v)?;
        }
        if !self.targets.is_empty() {
            struct_ser.serialize_field("Targets", &self.targets)?;
        }
        if !self.awards.is_empty() {
            struct_ser.serialize_field("Awards", &self.awards)?;
        }
        if !self.entered_zones.is_empty() {
            struct_ser.serialize_field("EnteredZones", &self.entered_zones)?;
        }
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PioneerInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CurrentTotal",
            "Targets",
            "Awards",
            "EnteredZones",
            "Id",
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CurrentTotal,
            Targets,
            Awards,
            EnteredZones,
            Id,
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CurrentTotal" => Ok(GeneratedField::CurrentTotal),
                            "Targets" => Ok(GeneratedField::Targets),
                            "Awards" => Ok(GeneratedField::Awards),
                            "EnteredZones" => Ok(GeneratedField::EnteredZones),
                            "Id" => Ok(GeneratedField::Id),
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PioneerInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PioneerInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PioneerInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut current_total__ = None;
                let mut targets__ = None;
                let mut awards__ = None;
                let mut entered_zones__ = None;
                let mut id__ = None;
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CurrentTotal => {
                            if current_total__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurrentTotal"));
                            }
                            current_total__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Targets => {
                            if targets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Targets"));
                            }
                            targets__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<u32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::Awards => {
                            if awards__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Awards"));
                            }
                            awards__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::EnteredZones => {
                            if entered_zones__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnteredZones"));
                            }
                            entered_zones__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(PioneerInfo {
                    current_total: current_total__,
                    targets: targets__.unwrap_or_default(),
                    awards: awards__.unwrap_or_default(),
                    entered_zones: entered_zones__.unwrap_or_default(),
                    id: id__,
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PioneerInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Pivot {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.pivots.is_empty() {
            len += 1;
        }
        if !self.map_pivots.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Pivot", len)?;
        if !self.pivots.is_empty() {
            struct_ser.serialize_field("Pivots", &self.pivots)?;
        }
        if !self.map_pivots.is_empty() {
            struct_ser.serialize_field("MapPivots", &self.map_pivots)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Pivot {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Pivots",
            "MapPivots",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Pivots,
            MapPivots,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Pivots" => Ok(GeneratedField::Pivots),
                            "MapPivots" => Ok(GeneratedField::MapPivots),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Pivot;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Pivot")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Pivot, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pivots__ = None;
                let mut map_pivots__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Pivots => {
                            if pivots__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Pivots"));
                            }
                            pivots__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::MapPivots => {
                            if map_pivots__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MapPivots"));
                            }
                            map_pivots__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(Pivot {
                    pivots: pivots__.unwrap_or_default(),
                    map_pivots: map_pivots__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Pivot", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PivotInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if !self.break_point.is_empty() {
            len += 1;
        }
        if !self.reward_stage.is_empty() {
            len += 1;
        }
        if self.reward_full_state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PivotInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if !self.break_point.is_empty() {
            struct_ser.serialize_field("BreakPoint", &self.break_point)?;
        }
        if !self.reward_stage.is_empty() {
            struct_ser.serialize_field("RewardStage", &self.reward_stage)?;
        }
        if let Some(v) = self.reward_full_state.as_ref() {
            struct_ser.serialize_field("RewardFullState", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PivotInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "BreakPoint",
            "RewardStage",
            "RewardFullState",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            BreakPoint,
            RewardStage,
            RewardFullState,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "BreakPoint" => Ok(GeneratedField::BreakPoint),
                            "RewardStage" => Ok(GeneratedField::RewardStage),
                            "RewardFullState" => Ok(GeneratedField::RewardFullState),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PivotInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PivotInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PivotInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut break_point__ = None;
                let mut reward_stage__ = None;
                let mut reward_full_state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BreakPoint => {
                            if break_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BreakPoint"));
                            }
                            break_point__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::RewardStage => {
                            if reward_stage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RewardStage"));
                            }
                            reward_stage__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::RewardFullState => {
                            if reward_full_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RewardFullState"));
                            }
                            reward_full_state__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PivotInfo {
                    id: id__,
                    break_point: break_point__.unwrap_or_default(),
                    reward_stage: reward_stage__.unwrap_or_default(),
                    reward_full_state: reward_full_state__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PivotInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlaceHolderBuff {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.buff_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlaceHolderBuff", len)?;
        if let Some(v) = self.buff_id.as_ref() {
            struct_ser.serialize_field("BuffId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlaceHolderBuff {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BuffId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BuffId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BuffId" => Ok(GeneratedField::BuffId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlaceHolderBuff;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlaceHolderBuff")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlaceHolderBuff, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut buff_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BuffId => {
                            if buff_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuffId"));
                            }
                            buff_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlaceHolderBuff {
                    buff_id: buff_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlaceHolderBuff", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlaceHolderFishItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.fish_id.is_some() {
            len += 1;
        }
        if self.size.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlaceHolderFishItem", len)?;
        if let Some(v) = self.fish_id.as_ref() {
            struct_ser.serialize_field("FishId", v)?;
        }
        if let Some(v) = self.size.as_ref() {
            struct_ser.serialize_field("Size", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlaceHolderFishItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FishId",
            "Size",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FishId,
            Size,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FishId" => Ok(GeneratedField::FishId),
                            "Size" => Ok(GeneratedField::Size),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlaceHolderFishItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlaceHolderFishItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlaceHolderFishItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fish_id__ = None;
                let mut size__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FishId => {
                            if fish_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FishId"));
                            }
                            fish_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Size"));
                            }
                            size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlaceHolderFishItem {
                    fish_id: fish_id__,
                    size: size__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlaceHolderFishItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlaceHolderFishPersonalTotal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.total.is_some() {
            len += 1;
        }
        if self.myth_total.is_some() {
            len += 1;
        }
        if self.sum_fish_type.is_some() {
            len += 1;
        }
        if self.sum_sea_life_type.is_some() {
            len += 1;
        }
        if self.sum_trash_type.is_some() {
            len += 1;
        }
        if self.most_fish_id.is_some() {
            len += 1;
        }
        if self.favour_zero.is_some() {
            len += 1;
        }
        if self.user_name.is_some() {
            len += 1;
        }
        if self.union_name.is_some() {
            len += 1;
        }
        if self.is_newbie.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlaceHolderFishPersonalTotal", len)?;
        if let Some(v) = self.total.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Total", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.myth_total.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("MythTotal", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.sum_fish_type.as_ref() {
            struct_ser.serialize_field("SumFishType", v)?;
        }
        if let Some(v) = self.sum_sea_life_type.as_ref() {
            struct_ser.serialize_field("SumSeaLifeType", v)?;
        }
        if let Some(v) = self.sum_trash_type.as_ref() {
            struct_ser.serialize_field("SumTrashType", v)?;
        }
        if let Some(v) = self.most_fish_id.as_ref() {
            struct_ser.serialize_field("MostFishId", v)?;
        }
        if let Some(v) = self.favour_zero.as_ref() {
            struct_ser.serialize_field("FavourZero", v)?;
        }
        if let Some(v) = self.user_name.as_ref() {
            struct_ser.serialize_field("UserName", v)?;
        }
        if let Some(v) = self.union_name.as_ref() {
            struct_ser.serialize_field("UnionName", v)?;
        }
        if let Some(v) = self.is_newbie.as_ref() {
            struct_ser.serialize_field("IsNewbie", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlaceHolderFishPersonalTotal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Total",
            "MythTotal",
            "SumFishType",
            "SumSeaLifeType",
            "SumTrashType",
            "MostFishId",
            "FavourZero",
            "UserName",
            "UnionName",
            "IsNewbie",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Total,
            MythTotal,
            SumFishType,
            SumSeaLifeType,
            SumTrashType,
            MostFishId,
            FavourZero,
            UserName,
            UnionName,
            IsNewbie,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Total" => Ok(GeneratedField::Total),
                            "MythTotal" => Ok(GeneratedField::MythTotal),
                            "SumFishType" => Ok(GeneratedField::SumFishType),
                            "SumSeaLifeType" => Ok(GeneratedField::SumSeaLifeType),
                            "SumTrashType" => Ok(GeneratedField::SumTrashType),
                            "MostFishId" => Ok(GeneratedField::MostFishId),
                            "FavourZero" => Ok(GeneratedField::FavourZero),
                            "UserName" => Ok(GeneratedField::UserName),
                            "UnionName" => Ok(GeneratedField::UnionName),
                            "IsNewbie" => Ok(GeneratedField::IsNewbie),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlaceHolderFishPersonalTotal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlaceHolderFishPersonalTotal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlaceHolderFishPersonalTotal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut total__ = None;
                let mut myth_total__ = None;
                let mut sum_fish_type__ = None;
                let mut sum_sea_life_type__ = None;
                let mut sum_trash_type__ = None;
                let mut most_fish_id__ = None;
                let mut favour_zero__ = None;
                let mut user_name__ = None;
                let mut union_name__ = None;
                let mut is_newbie__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Total => {
                            if total__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Total"));
                            }
                            total__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MythTotal => {
                            if myth_total__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MythTotal"));
                            }
                            myth_total__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SumFishType => {
                            if sum_fish_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SumFishType"));
                            }
                            sum_fish_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SumSeaLifeType => {
                            if sum_sea_life_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SumSeaLifeType"));
                            }
                            sum_sea_life_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SumTrashType => {
                            if sum_trash_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SumTrashType"));
                            }
                            sum_trash_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MostFishId => {
                            if most_fish_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MostFishId"));
                            }
                            most_fish_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FavourZero => {
                            if favour_zero__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FavourZero"));
                            }
                            favour_zero__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::UserName => {
                            if user_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UserName"));
                            }
                            user_name__ = map_.next_value()?;
                        }
                        GeneratedField::UnionName => {
                            if union_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnionName"));
                            }
                            union_name__ = map_.next_value()?;
                        }
                        GeneratedField::IsNewbie => {
                            if is_newbie__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsNewbie"));
                            }
                            is_newbie__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PlaceHolderFishPersonalTotal {
                    total: total__,
                    myth_total: myth_total__,
                    sum_fish_type: sum_fish_type__,
                    sum_sea_life_type: sum_sea_life_type__,
                    sum_trash_type: sum_trash_type__,
                    most_fish_id: most_fish_id__,
                    favour_zero: favour_zero__,
                    user_name: user_name__,
                    union_name: union_name__,
                    is_newbie: is_newbie__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlaceHolderFishPersonalTotal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlaceHolderFishRank {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.fish_id.is_some() {
            len += 1;
        }
        if self.size.is_some() {
            len += 1;
        }
        if self.rank.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlaceHolderFishRank", len)?;
        if let Some(v) = self.fish_id.as_ref() {
            struct_ser.serialize_field("FishId", v)?;
        }
        if let Some(v) = self.size.as_ref() {
            struct_ser.serialize_field("Size", v)?;
        }
        if let Some(v) = self.rank.as_ref() {
            struct_ser.serialize_field("Rank", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlaceHolderFishRank {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FishId",
            "Size",
            "Rank",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FishId,
            Size,
            Rank,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FishId" => Ok(GeneratedField::FishId),
                            "Size" => Ok(GeneratedField::Size),
                            "Rank" => Ok(GeneratedField::Rank),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlaceHolderFishRank;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlaceHolderFishRank")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlaceHolderFishRank, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut fish_id__ = None;
                let mut size__ = None;
                let mut rank__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FishId => {
                            if fish_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FishId"));
                            }
                            fish_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Size"));
                            }
                            size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Rank => {
                            if rank__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Rank"));
                            }
                            rank__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlaceHolderFishRank {
                    fish_id: fish_id__,
                    size: size__,
                    rank: rank__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlaceHolderFishRank", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlaceHolderItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.config_id.is_some() {
            len += 1;
        }
        if self.item_detail.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlaceHolderItem", len)?;
        if let Some(v) = self.config_id.as_ref() {
            struct_ser.serialize_field("ConfigId", v)?;
        }
        if let Some(v) = self.item_detail.as_ref() {
            struct_ser.serialize_field("ItemDetail", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlaceHolderItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ConfigId",
            "ItemDetail",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ConfigId,
            ItemDetail,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ConfigId" => Ok(GeneratedField::ConfigId),
                            "ItemDetail" => Ok(GeneratedField::ItemDetail),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlaceHolderItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlaceHolderItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlaceHolderItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut config_id__ = None;
                let mut item_detail__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ConfigId => {
                            if config_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConfigId"));
                            }
                            config_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ItemDetail => {
                            if item_detail__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ItemDetail"));
                            }
                            item_detail__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PlaceHolderItem {
                    config_id: config_id__,
                    item_detail: item_detail__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlaceHolderItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlaceHolderMasterMode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.master_mode_info.is_empty() {
            len += 1;
        }
        if self.user_name.is_some() {
            len += 1;
        }
        if self.season_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlaceHolderMasterMode", len)?;
        if !self.master_mode_info.is_empty() {
            struct_ser.serialize_field("MasterModeInfo", &self.master_mode_info)?;
        }
        if let Some(v) = self.user_name.as_ref() {
            struct_ser.serialize_field("UserName", v)?;
        }
        if let Some(v) = self.season_id.as_ref() {
            struct_ser.serialize_field("SeasonId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlaceHolderMasterMode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MasterModeInfo",
            "UserName",
            "SeasonId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MasterModeInfo,
            UserName,
            SeasonId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MasterModeInfo" => Ok(GeneratedField::MasterModeInfo),
                            "UserName" => Ok(GeneratedField::UserName),
                            "SeasonId" => Ok(GeneratedField::SeasonId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlaceHolderMasterMode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlaceHolderMasterMode")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlaceHolderMasterMode, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut master_mode_info__ = None;
                let mut user_name__ = None;
                let mut season_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MasterModeInfo => {
                            if master_mode_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MasterModeInfo"));
                            }
                            master_mode_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::UserName => {
                            if user_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UserName"));
                            }
                            user_name__ = map_.next_value()?;
                        }
                        GeneratedField::SeasonId => {
                            if season_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonId"));
                            }
                            season_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlaceHolderMasterMode {
                    master_mode_info: master_mode_info__.unwrap_or_default(),
                    user_name: user_name__,
                    season_id: season_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlaceHolderMasterMode", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlaceHolderPlayer {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.char_id.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlaceHolderPlayer", len)?;
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("Name", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlaceHolderPlayer {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CharId",
            "Name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CharId,
            Name,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CharId" => Ok(GeneratedField::CharId),
                            "Name" => Ok(GeneratedField::Name),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlaceHolderPlayer;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlaceHolderPlayer")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlaceHolderPlayer, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut char_id__ = None;
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Name"));
                            }
                            name__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PlaceHolderPlayer {
                    char_id: char_id__,
                    name: name__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlaceHolderPlayer", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlaceHolderStr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.text.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlaceHolderStr", len)?;
        if let Some(v) = self.text.as_ref() {
            struct_ser.serialize_field("Text", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlaceHolderStr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Text",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Text,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Text" => Ok(GeneratedField::Text),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlaceHolderStr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlaceHolderStr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlaceHolderStr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut text__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Text => {
                            if text__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Text"));
                            }
                            text__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PlaceHolderStr {
                    text: text__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlaceHolderStr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlaceHolderTimestamp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.timestamp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlaceHolderTimestamp", len)?;
        if let Some(v) = self.timestamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Timestamp", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlaceHolderTimestamp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Timestamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Timestamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Timestamp" => Ok(GeneratedField::Timestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlaceHolderTimestamp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlaceHolderTimestamp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlaceHolderTimestamp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Timestamp"));
                            }
                            timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlaceHolderTimestamp {
                    timestamp: timestamp__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlaceHolderTimestamp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlaceHolderUnion {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.build.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlaceHolderUnion", len)?;
        if let Some(v) = self.build.as_ref() {
            struct_ser.serialize_field("Build", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlaceHolderUnion {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Build",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Build,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Build" => Ok(GeneratedField::Build),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlaceHolderUnion;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlaceHolderUnion")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlaceHolderUnion, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut build__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Build => {
                            if build__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Build"));
                            }
                            build__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlaceHolderUnion {
                    build: build__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlaceHolderUnion", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlaceHolderVal {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlaceHolderVal", len)?;
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("Value", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlaceHolderVal {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlaceHolderVal;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlaceHolderVal")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlaceHolderVal, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Value"));
                            }
                            value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlaceHolderVal {
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlaceHolderVal", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlanetMemory {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.pass_room.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlanetMemory", len)?;
        if !self.pass_room.is_empty() {
            struct_ser.serialize_field("PassRoom", &self.pass_room)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlanetMemory {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PassRoom",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PassRoom,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PassRoom" => Ok(GeneratedField::PassRoom),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlanetMemory;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlanetMemory")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlanetMemory, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pass_room__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PassRoom => {
                            if pass_room__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PassRoom"));
                            }
                            pass_room__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(PlanetMemory {
                    pass_room: pass_room__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlanetMemory", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.play_action_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlayAction", len)?;
        if let Some(v) = self.play_action_param.as_ref() {
            struct_ser.serialize_field("PlayActionParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PlayActionParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PlayActionParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PlayActionParam" => Ok(GeneratedField::PlayActionParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlayAction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayAction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut play_action_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PlayActionParam => {
                            if play_action_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayActionParam"));
                            }
                            play_action_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PlayAction {
                    play_action_param: play_action_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlayAction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayActionParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.action_id.is_some() {
            len += 1;
        }
        if self.is_upper.is_some() {
            len += 1;
        }
        if self.is_dance_together.is_some() {
            len += 1;
        }
        if self.mount_id.is_some() {
            len += 1;
        }
        if self.mount_size.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlayActionParam", len)?;
        if let Some(v) = self.action_id.as_ref() {
            struct_ser.serialize_field("ActionId", v)?;
        }
        if let Some(v) = self.is_upper.as_ref() {
            struct_ser.serialize_field("IsUpper", v)?;
        }
        if let Some(v) = self.is_dance_together.as_ref() {
            struct_ser.serialize_field("IsDanceTogether", v)?;
        }
        if let Some(v) = self.mount_id.as_ref() {
            struct_ser.serialize_field("MountId", v)?;
        }
        if let Some(v) = self.mount_size.as_ref() {
            struct_ser.serialize_field("MountSize", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayActionParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ActionId",
            "IsUpper",
            "IsDanceTogether",
            "MountId",
            "MountSize",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ActionId,
            IsUpper,
            IsDanceTogether,
            MountId,
            MountSize,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ActionId" => Ok(GeneratedField::ActionId),
                            "IsUpper" => Ok(GeneratedField::IsUpper),
                            "IsDanceTogether" => Ok(GeneratedField::IsDanceTogether),
                            "MountId" => Ok(GeneratedField::MountId),
                            "MountSize" => Ok(GeneratedField::MountSize),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayActionParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlayActionParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayActionParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut action_id__ = None;
                let mut is_upper__ = None;
                let mut is_dance_together__ = None;
                let mut mount_id__ = None;
                let mut mount_size__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ActionId => {
                            if action_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActionId"));
                            }
                            action_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsUpper => {
                            if is_upper__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsUpper"));
                            }
                            is_upper__ = map_.next_value()?;
                        }
                        GeneratedField::IsDanceTogether => {
                            if is_dance_together__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsDanceTogether"));
                            }
                            is_dance_together__ = map_.next_value()?;
                        }
                        GeneratedField::MountId => {
                            if mount_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MountId"));
                            }
                            mount_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MountSize => {
                            if mount_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MountSize"));
                            }
                            mount_size__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlayActionParam {
                    action_id: action_id__,
                    is_upper: is_upper__,
                    is_dance_together: is_dance_together__,
                    mount_id: mount_id__,
                    mount_size: mount_size__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlayActionParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayEmote {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.emote_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlayEmote", len)?;
        if let Some(v) = self.emote_id.as_ref() {
            struct_ser.serialize_field("EmoteId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayEmote {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EmoteId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EmoteId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EmoteId" => Ok(GeneratedField::EmoteId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayEmote;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlayEmote")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayEmote, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut emote_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EmoteId => {
                            if emote_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EmoteId"));
                            }
                            emote_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlayEmote {
                    emote_id: emote_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlayEmote", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayHelper {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.displayed_helper_list.is_empty() {
            len += 1;
        }
        if !self.completed_guide.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlayHelper", len)?;
        if !self.displayed_helper_list.is_empty() {
            struct_ser.serialize_field("DisplayedHelperList", &self.displayed_helper_list)?;
        }
        if !self.completed_guide.is_empty() {
            struct_ser.serialize_field("CompletedGuide", &self.completed_guide)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayHelper {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DisplayedHelperList",
            "CompletedGuide",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DisplayedHelperList,
            CompletedGuide,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DisplayedHelperList" => Ok(GeneratedField::DisplayedHelperList),
                            "CompletedGuide" => Ok(GeneratedField::CompletedGuide),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayHelper;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlayHelper")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayHelper, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut displayed_helper_list__ = None;
                let mut completed_guide__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DisplayedHelperList => {
                            if displayed_helper_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DisplayedHelperList"));
                            }
                            displayed_helper_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::CompletedGuide => {
                            if completed_guide__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CompletedGuide"));
                            }
                            completed_guide__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(PlayHelper {
                    displayed_helper_list: displayed_helper_list__.unwrap_or_default(),
                    completed_guide: completed_guide__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlayHelper", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayerBox {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.scenes.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlayerBox", len)?;
        if !self.scenes.is_empty() {
            struct_ser.serialize_field("Scenes", &self.scenes)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayerBox {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Scenes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Scenes,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Scenes" => Ok(GeneratedField::Scenes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayerBox;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlayerBox")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayerBox, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scenes__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Scenes => {
                            if scenes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Scenes"));
                            }
                            scenes__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(PlayerBox {
                    scenes: scenes__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlayerBox", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayerBoxData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scene_uuid.is_some() {
            len += 1;
        }
        if !self.boxs.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlayerBoxData", len)?;
        if let Some(v) = self.scene_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SceneUUID", ToString::to_string(&v).as_str())?;
        }
        if !self.boxs.is_empty() {
            let v: std::collections::HashMap<_, _> = self.boxs.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("Boxs", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayerBoxData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SceneUUID",
            "Boxs",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SceneUuid,
            Boxs,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SceneUUID" => Ok(GeneratedField::SceneUuid),
                            "Boxs" => Ok(GeneratedField::Boxs),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayerBoxData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlayerBoxData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayerBoxData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_uuid__ = None;
                let mut boxs__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SceneUuid => {
                            if scene_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneUUID"));
                            }
                            scene_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Boxs => {
                            if boxs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Boxs"));
                            }
                            boxs__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(PlayerBoxData {
                    scene_uuid: scene_uuid__,
                    boxs: boxs__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlayerBoxData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayerBuyRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.count.is_some() {
            len += 1;
        }
        if self.buy_timestamp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlayerBuyRecord", len)?;
        if let Some(v) = self.count.as_ref() {
            struct_ser.serialize_field("Count", v)?;
        }
        if let Some(v) = self.buy_timestamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BuyTimestamp", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayerBuyRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Count",
            "BuyTimestamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Count,
            BuyTimestamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Count" => Ok(GeneratedField::Count),
                            "BuyTimestamp" => Ok(GeneratedField::BuyTimestamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayerBuyRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlayerBuyRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayerBuyRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut count__ = None;
                let mut buy_timestamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Count => {
                            if count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Count"));
                            }
                            count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BuyTimestamp => {
                            if buy_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuyTimestamp"));
                            }
                            buy_timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlayerBuyRecord {
                    count: count__,
                    buy_timestamp: buy_timestamp__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlayerBuyRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayerOrderComtainerInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.index.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlayerOrderComtainerInfo", len)?;
        if let Some(v) = self.index.as_ref() {
            struct_ser.serialize_field("Index", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayerOrderComtainerInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Index",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Index,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Index" => Ok(GeneratedField::Index),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayerOrderComtainerInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlayerOrderComtainerInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayerOrderComtainerInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut index__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Index => {
                            if index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Index"));
                            }
                            index__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlayerOrderComtainerInfo {
                    index: index__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlayerOrderComtainerInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayerRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.player_record_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlayerRecord", len)?;
        if !self.player_record_infos.is_empty() {
            struct_ser.serialize_field("PlayerRecordInfos", &self.player_record_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayerRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PlayerRecordInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PlayerRecordInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PlayerRecordInfos" => Ok(GeneratedField::PlayerRecordInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayerRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlayerRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayerRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut player_record_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PlayerRecordInfos => {
                            if player_record_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayerRecordInfos"));
                            }
                            player_record_infos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(PlayerRecord {
                    player_record_infos: player_record_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlayerRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayerRecordInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.player_records.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlayerRecordInfo", len)?;
        if !self.player_records.is_empty() {
            struct_ser.serialize_field("PlayerRecords", &self.player_records)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayerRecordInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PlayerRecords",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PlayerRecords,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PlayerRecords" => Ok(GeneratedField::PlayerRecords),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayerRecordInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlayerRecordInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayerRecordInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut player_records__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PlayerRecords => {
                            if player_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayerRecords"));
                            }
                            player_records__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(PlayerRecordInfo {
                    player_records: player_records__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlayerRecordInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayerRecordSingle {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.total_count.is_some() {
            len += 1;
        }
        if self.cycle_count.is_some() {
            len += 1;
        }
        if self.cycle_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlayerRecordSingle", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.total_count.as_ref() {
            struct_ser.serialize_field("TotalCount", v)?;
        }
        if let Some(v) = self.cycle_count.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CycleCount", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.cycle_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CycleTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayerRecordSingle {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "TotalCount",
            "CycleCount",
            "CycleTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            TotalCount,
            CycleCount,
            CycleTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "TotalCount" => Ok(GeneratedField::TotalCount),
                            "CycleCount" => Ok(GeneratedField::CycleCount),
                            "CycleTime" => Ok(GeneratedField::CycleTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayerRecordSingle;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlayerRecordSingle")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayerRecordSingle, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut total_count__ = None;
                let mut cycle_count__ = None;
                let mut cycle_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TotalCount => {
                            if total_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TotalCount"));
                            }
                            total_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CycleCount => {
                            if cycle_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CycleCount"));
                            }
                            cycle_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CycleTime => {
                            if cycle_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CycleTime"));
                            }
                            cycle_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PlayerRecordSingle {
                    id: id__,
                    total_count: total_count__,
                    cycle_count: cycle_count__,
                    cycle_time: cycle_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlayerRecordSingle", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PlayerRefreshShopRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PlayerRefreshShopRecord", len)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("Items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PlayerRefreshShopRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Items" => Ok(GeneratedField::Items),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PlayerRefreshShopRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PlayerRefreshShopRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PlayerRefreshShopRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Items"));
                            }
                            items__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(PlayerRefreshShopRecord {
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PlayerRefreshShopRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Position {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.x.is_some() {
            len += 1;
        }
        if self.y.is_some() {
            len += 1;
        }
        if self.z.is_some() {
            len += 1;
        }
        if self.dir.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Position", len)?;
        if let Some(v) = self.x.as_ref() {
            struct_ser.serialize_field("X", v)?;
        }
        if let Some(v) = self.y.as_ref() {
            struct_ser.serialize_field("Y", v)?;
        }
        if let Some(v) = self.z.as_ref() {
            struct_ser.serialize_field("Z", v)?;
        }
        if let Some(v) = self.dir.as_ref() {
            struct_ser.serialize_field("Dir", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Position {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "X",
            "Y",
            "Z",
            "Dir",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            X,
            Y,
            Z,
            Dir,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "X" => Ok(GeneratedField::X),
                            "Y" => Ok(GeneratedField::Y),
                            "Z" => Ok(GeneratedField::Z),
                            "Dir" => Ok(GeneratedField::Dir),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Position;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Position")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Position, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut x__ = None;
                let mut y__ = None;
                let mut z__ = None;
                let mut dir__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::X => {
                            if x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("X"));
                            }
                            x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Y => {
                            if y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Y"));
                            }
                            y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Z => {
                            if z__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Z"));
                            }
                            z__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Dir => {
                            if dir__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Dir"));
                            }
                            dir__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Position {
                    x: x__,
                    y: y__,
                    z: z__,
                    dir: dir__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Position", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PositionParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scene_point_info.is_some() {
            len += 1;
        }
        if self.scene_pos_info.is_some() {
            len += 1;
        }
        if self.cut_scene_point_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PositionParam", len)?;
        if let Some(v) = self.scene_point_info.as_ref() {
            struct_ser.serialize_field("ScenePointInfo", v)?;
        }
        if let Some(v) = self.scene_pos_info.as_ref() {
            struct_ser.serialize_field("ScenePosInfo", v)?;
        }
        if let Some(v) = self.cut_scene_point_info.as_ref() {
            struct_ser.serialize_field("CutScenePointInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PositionParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ScenePointInfo",
            "ScenePosInfo",
            "CutScenePointInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ScenePointInfo,
            ScenePosInfo,
            CutScenePointInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ScenePointInfo" => Ok(GeneratedField::ScenePointInfo),
                            "ScenePosInfo" => Ok(GeneratedField::ScenePosInfo),
                            "CutScenePointInfo" => Ok(GeneratedField::CutScenePointInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PositionParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PositionParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PositionParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_point_info__ = None;
                let mut scene_pos_info__ = None;
                let mut cut_scene_point_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ScenePointInfo => {
                            if scene_point_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ScenePointInfo"));
                            }
                            scene_point_info__ = map_.next_value()?;
                        }
                        GeneratedField::ScenePosInfo => {
                            if scene_pos_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ScenePosInfo"));
                            }
                            scene_pos_info__ = map_.next_value()?;
                        }
                        GeneratedField::CutScenePointInfo => {
                            if cut_scene_point_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CutScenePointInfo"));
                            }
                            cut_scene_point_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(PositionParam {
                    scene_point_info: scene_point_info__,
                    scene_pos_info: scene_pos_info__,
                    cut_scene_point_info: cut_scene_point_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PositionParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PrivilegeData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.launch_platform.is_some() {
            len += 1;
        }
        if self.is_privilege.is_some() {
            len += 1;
        }
        if self.last_update_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PrivilegeData", len)?;
        if let Some(v) = self.launch_platform.as_ref() {
            let v = LaunchPlatform::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("LaunchPlatform", &v)?;
        }
        if let Some(v) = self.is_privilege.as_ref() {
            struct_ser.serialize_field("IsPrivilege", v)?;
        }
        if let Some(v) = self.last_update_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastUpdateTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PrivilegeData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LaunchPlatform",
            "IsPrivilege",
            "LastUpdateTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LaunchPlatform,
            IsPrivilege,
            LastUpdateTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LaunchPlatform" => Ok(GeneratedField::LaunchPlatform),
                            "IsPrivilege" => Ok(GeneratedField::IsPrivilege),
                            "LastUpdateTime" => Ok(GeneratedField::LastUpdateTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PrivilegeData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PrivilegeData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PrivilegeData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut launch_platform__ = None;
                let mut is_privilege__ = None;
                let mut last_update_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LaunchPlatform => {
                            if launch_platform__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LaunchPlatform"));
                            }
                            launch_platform__ = map_.next_value::<::std::option::Option<LaunchPlatform>>()?.map(|x| x as i32);
                        }
                        GeneratedField::IsPrivilege => {
                            if is_privilege__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsPrivilege"));
                            }
                            is_privilege__ = map_.next_value()?;
                        }
                        GeneratedField::LastUpdateTime => {
                            if last_update_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastUpdateTime"));
                            }
                            last_update_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(PrivilegeData {
                    launch_platform: launch_platform__,
                    is_privilege: is_privilege__,
                    last_update_time: last_update_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PrivilegeData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PrivilegeEffectData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.normal_pass_id.is_some() {
            len += 1;
        }
        if self.prime_pass_id.is_some() {
            len += 1;
        }
        if !self.normal_pass_id_map.is_empty() {
            len += 1;
        }
        if !self.prime_pass_id_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.PrivilegeEffectData", len)?;
        if let Some(v) = self.normal_pass_id.as_ref() {
            struct_ser.serialize_field("NormalPassId", v)?;
        }
        if let Some(v) = self.prime_pass_id.as_ref() {
            struct_ser.serialize_field("PrimePassId", v)?;
        }
        if !self.normal_pass_id_map.is_empty() {
            struct_ser.serialize_field("NormalPassIdMap", &self.normal_pass_id_map)?;
        }
        if !self.prime_pass_id_map.is_empty() {
            struct_ser.serialize_field("PrimePassIdMap", &self.prime_pass_id_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PrivilegeEffectData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "NormalPassId",
            "PrimePassId",
            "NormalPassIdMap",
            "PrimePassIdMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            NormalPassId,
            PrimePassId,
            NormalPassIdMap,
            PrimePassIdMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "NormalPassId" => Ok(GeneratedField::NormalPassId),
                            "PrimePassId" => Ok(GeneratedField::PrimePassId),
                            "NormalPassIdMap" => Ok(GeneratedField::NormalPassIdMap),
                            "PrimePassIdMap" => Ok(GeneratedField::PrimePassIdMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PrivilegeEffectData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.PrivilegeEffectData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PrivilegeEffectData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut normal_pass_id__ = None;
                let mut prime_pass_id__ = None;
                let mut normal_pass_id_map__ = None;
                let mut prime_pass_id_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::NormalPassId => {
                            if normal_pass_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NormalPassId"));
                            }
                            normal_pass_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PrimePassId => {
                            if prime_pass_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PrimePassId"));
                            }
                            prime_pass_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NormalPassIdMap => {
                            if normal_pass_id_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NormalPassIdMap"));
                            }
                            normal_pass_id_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::PrimePassIdMap => {
                            if prime_pass_id_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PrimePassIdMap"));
                            }
                            prime_pass_id_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(PrivilegeEffectData {
                    normal_pass_id: normal_pass_id__,
                    prime_pass_id: prime_pass_id__,
                    normal_pass_id_map: normal_pass_id_map__.unwrap_or_default(),
                    prime_pass_id_map: prime_pass_id_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.PrivilegeEffectData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProfessionData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.profession_id.is_some() {
            len += 1;
        }
        if self.weapon_skin.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ProfessionData", len)?;
        if let Some(v) = self.profession_id.as_ref() {
            struct_ser.serialize_field("ProfessionId", v)?;
        }
        if let Some(v) = self.weapon_skin.as_ref() {
            struct_ser.serialize_field("WeaponSkin", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProfessionData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ProfessionId",
            "WeaponSkin",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ProfessionId,
            WeaponSkin,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ProfessionId" => Ok(GeneratedField::ProfessionId),
                            "WeaponSkin" => Ok(GeneratedField::WeaponSkin),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProfessionData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ProfessionData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProfessionData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut profession_id__ = None;
                let mut weapon_skin__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ProfessionId => {
                            if profession_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfessionId"));
                            }
                            profession_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WeaponSkin => {
                            if weapon_skin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WeaponSkin"));
                            }
                            weapon_skin__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ProfessionData {
                    profession_id: profession_id__,
                    weapon_skin: weapon_skin__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ProfessionData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProfessionInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.profession_id.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        if self.experience.is_some() {
            len += 1;
        }
        if !self.skill_info_map.is_empty() {
            len += 1;
        }
        if !self.active_skill_ids.is_empty() {
            len += 1;
        }
        if !self.slot_skill_info_map.is_empty() {
            len += 1;
        }
        if self.use_skin_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ProfessionInfo", len)?;
        if let Some(v) = self.profession_id.as_ref() {
            struct_ser.serialize_field("ProfessionId", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if let Some(v) = self.experience.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Experience", ToString::to_string(&v).as_str())?;
        }
        if !self.skill_info_map.is_empty() {
            struct_ser.serialize_field("SkillInfoMap", &self.skill_info_map)?;
        }
        if !self.active_skill_ids.is_empty() {
            struct_ser.serialize_field("ActiveSkillIds", &self.active_skill_ids)?;
        }
        if !self.slot_skill_info_map.is_empty() {
            struct_ser.serialize_field("SlotSkillInfoMap", &self.slot_skill_info_map)?;
        }
        if let Some(v) = self.use_skin_id.as_ref() {
            struct_ser.serialize_field("UseSkinId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProfessionInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ProfessionId",
            "Level",
            "Experience",
            "SkillInfoMap",
            "ActiveSkillIds",
            "SlotSkillInfoMap",
            "UseSkinId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ProfessionId,
            Level,
            Experience,
            SkillInfoMap,
            ActiveSkillIds,
            SlotSkillInfoMap,
            UseSkinId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ProfessionId" => Ok(GeneratedField::ProfessionId),
                            "Level" => Ok(GeneratedField::Level),
                            "Experience" => Ok(GeneratedField::Experience),
                            "SkillInfoMap" => Ok(GeneratedField::SkillInfoMap),
                            "ActiveSkillIds" => Ok(GeneratedField::ActiveSkillIds),
                            "SlotSkillInfoMap" => Ok(GeneratedField::SlotSkillInfoMap),
                            "UseSkinId" => Ok(GeneratedField::UseSkinId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProfessionInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ProfessionInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProfessionInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut profession_id__ = None;
                let mut level__ = None;
                let mut experience__ = None;
                let mut skill_info_map__ = None;
                let mut active_skill_ids__ = None;
                let mut slot_skill_info_map__ = None;
                let mut use_skin_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ProfessionId => {
                            if profession_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfessionId"));
                            }
                            profession_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Experience => {
                            if experience__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Experience"));
                            }
                            experience__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillInfoMap => {
                            if skill_info_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillInfoMap"));
                            }
                            skill_info_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::ActiveSkillIds => {
                            if active_skill_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActiveSkillIds"));
                            }
                            active_skill_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::SlotSkillInfoMap => {
                            if slot_skill_info_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SlotSkillInfoMap"));
                            }
                            slot_skill_info_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::UseSkinId => {
                            if use_skin_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UseSkinId"));
                            }
                            use_skin_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ProfessionInfo {
                    profession_id: profession_id__,
                    level: level__,
                    experience: experience__,
                    skill_info_map: skill_info_map__.unwrap_or_default(),
                    active_skill_ids: active_skill_ids__.unwrap_or_default(),
                    slot_skill_info_map: slot_skill_info_map__.unwrap_or_default(),
                    use_skin_id: use_skin_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ProfessionInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProfessionList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cur_profession_id.is_some() {
            len += 1;
        }
        if !self.cur_assist_professions.is_empty() {
            len += 1;
        }
        if !self.profession_list.is_empty() {
            len += 1;
        }
        if !self.aoyi_skill_info_map.is_empty() {
            len += 1;
        }
        if self.total_talent_points.is_some() {
            len += 1;
        }
        if self.total_talent_reset_count.is_some() {
            len += 1;
        }
        if !self.talent_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ProfessionList", len)?;
        if let Some(v) = self.cur_profession_id.as_ref() {
            struct_ser.serialize_field("CurProfessionId", v)?;
        }
        if !self.cur_assist_professions.is_empty() {
            struct_ser.serialize_field("CurAssistProfessions", &self.cur_assist_professions)?;
        }
        if !self.profession_list.is_empty() {
            struct_ser.serialize_field("ProfessionList", &self.profession_list)?;
        }
        if !self.aoyi_skill_info_map.is_empty() {
            struct_ser.serialize_field("AoyiSkillInfoMap", &self.aoyi_skill_info_map)?;
        }
        if let Some(v) = self.total_talent_points.as_ref() {
            struct_ser.serialize_field("TotalTalentPoints", v)?;
        }
        if let Some(v) = self.total_talent_reset_count.as_ref() {
            struct_ser.serialize_field("TotalTalentResetCount", v)?;
        }
        if !self.talent_list.is_empty() {
            struct_ser.serialize_field("TalentList", &self.talent_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProfessionList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CurProfessionId",
            "CurAssistProfessions",
            "ProfessionList_",
            "ProfessionList",
            "AoyiSkillInfoMap",
            "TotalTalentPoints",
            "TotalTalentResetCount",
            "TalentList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CurProfessionId,
            CurAssistProfessions,
            ProfessionList,
            AoyiSkillInfoMap,
            TotalTalentPoints,
            TotalTalentResetCount,
            TalentList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CurProfessionId" => Ok(GeneratedField::CurProfessionId),
                            "CurAssistProfessions" => Ok(GeneratedField::CurAssistProfessions),
                            "ProfessionList" | "ProfessionList_" => Ok(GeneratedField::ProfessionList),
                            "AoyiSkillInfoMap" => Ok(GeneratedField::AoyiSkillInfoMap),
                            "TotalTalentPoints" => Ok(GeneratedField::TotalTalentPoints),
                            "TotalTalentResetCount" => Ok(GeneratedField::TotalTalentResetCount),
                            "TalentList" => Ok(GeneratedField::TalentList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProfessionList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ProfessionList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProfessionList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cur_profession_id__ = None;
                let mut cur_assist_professions__ = None;
                let mut profession_list__ = None;
                let mut aoyi_skill_info_map__ = None;
                let mut total_talent_points__ = None;
                let mut total_talent_reset_count__ = None;
                let mut talent_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CurProfessionId => {
                            if cur_profession_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurProfessionId"));
                            }
                            cur_profession_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurAssistProfessions => {
                            if cur_assist_professions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurAssistProfessions"));
                            }
                            cur_assist_professions__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::ProfessionList => {
                            if profession_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfessionList"));
                            }
                            profession_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::AoyiSkillInfoMap => {
                            if aoyi_skill_info_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AoyiSkillInfoMap"));
                            }
                            aoyi_skill_info_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::TotalTalentPoints => {
                            if total_talent_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TotalTalentPoints"));
                            }
                            total_talent_points__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TotalTalentResetCount => {
                            if total_talent_reset_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TotalTalentResetCount"));
                            }
                            total_talent_reset_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TalentList => {
                            if talent_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TalentList"));
                            }
                            talent_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ProfessionList {
                    cur_profession_id: cur_profession_id__,
                    cur_assist_professions: cur_assist_professions__.unwrap_or_default(),
                    profession_list: profession_list__.unwrap_or_default(),
                    aoyi_skill_info_map: aoyi_skill_info_map__.unwrap_or_default(),
                    total_talent_points: total_talent_points__,
                    total_talent_reset_count: total_talent_reset_count__,
                    talent_list: talent_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ProfessionList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProfessionSkillInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_id.is_some() {
            len += 1;
        }
        if self.level.is_some() {
            len += 1;
        }
        if !self.replace_skill_ids.is_empty() {
            len += 1;
        }
        if self.remodel_level.is_some() {
            len += 1;
        }
        if self.cur_skill_skin.is_some() {
            len += 1;
        }
        if !self.active_skill_skins.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ProfessionSkillInfo", len)?;
        if let Some(v) = self.skill_id.as_ref() {
            struct_ser.serialize_field("SkillId", v)?;
        }
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if !self.replace_skill_ids.is_empty() {
            struct_ser.serialize_field("ReplaceSkillIds", &self.replace_skill_ids)?;
        }
        if let Some(v) = self.remodel_level.as_ref() {
            struct_ser.serialize_field("RemodelLevel", v)?;
        }
        if let Some(v) = self.cur_skill_skin.as_ref() {
            struct_ser.serialize_field("CurSkillSkin", v)?;
        }
        if !self.active_skill_skins.is_empty() {
            struct_ser.serialize_field("ActiveSkillSkins", &self.active_skill_skins)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProfessionSkillInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillId",
            "Level",
            "ReplaceSkillIds",
            "RemodelLevel",
            "CurSkillSkin",
            "ActiveSkillSkins",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillId,
            Level,
            ReplaceSkillIds,
            RemodelLevel,
            CurSkillSkin,
            ActiveSkillSkins,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillId" => Ok(GeneratedField::SkillId),
                            "Level" => Ok(GeneratedField::Level),
                            "ReplaceSkillIds" => Ok(GeneratedField::ReplaceSkillIds),
                            "RemodelLevel" => Ok(GeneratedField::RemodelLevel),
                            "CurSkillSkin" => Ok(GeneratedField::CurSkillSkin),
                            "ActiveSkillSkins" => Ok(GeneratedField::ActiveSkillSkins),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProfessionSkillInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ProfessionSkillInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProfessionSkillInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_id__ = None;
                let mut level__ = None;
                let mut replace_skill_ids__ = None;
                let mut remodel_level__ = None;
                let mut cur_skill_skin__ = None;
                let mut active_skill_skins__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillId => {
                            if skill_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillId"));
                            }
                            skill_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReplaceSkillIds => {
                            if replace_skill_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReplaceSkillIds"));
                            }
                            replace_skill_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::RemodelLevel => {
                            if remodel_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RemodelLevel"));
                            }
                            remodel_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurSkillSkin => {
                            if cur_skill_skin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurSkillSkin"));
                            }
                            cur_skill_skin__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ActiveSkillSkins => {
                            if active_skill_skins__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActiveSkillSkins"));
                            }
                            active_skill_skins__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ProfessionSkillInfo {
                    skill_id: skill_id__,
                    level: level__,
                    replace_skill_ids: replace_skill_ids__.unwrap_or_default(),
                    remodel_level: remodel_level__,
                    cur_skill_skin: cur_skill_skin__,
                    active_skill_skins: active_skill_skins__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ProfessionSkillInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProfessionTalentInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.used_talent_points.is_some() {
            len += 1;
        }
        if !self.talent_node_ids.is_empty() {
            len += 1;
        }
        if self.talent_stage_cfg_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ProfessionTalentInfo", len)?;
        if let Some(v) = self.used_talent_points.as_ref() {
            struct_ser.serialize_field("UsedTalentPoints", v)?;
        }
        if !self.talent_node_ids.is_empty() {
            struct_ser.serialize_field("TalentNodeIds", &self.talent_node_ids)?;
        }
        if let Some(v) = self.talent_stage_cfg_id.as_ref() {
            struct_ser.serialize_field("TalentStageCfgId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProfessionTalentInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UsedTalentPoints",
            "TalentNodeIds",
            "TalentStageCfgId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UsedTalentPoints,
            TalentNodeIds,
            TalentStageCfgId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UsedTalentPoints" => Ok(GeneratedField::UsedTalentPoints),
                            "TalentNodeIds" => Ok(GeneratedField::TalentNodeIds),
                            "TalentStageCfgId" => Ok(GeneratedField::TalentStageCfgId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProfessionTalentInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ProfessionTalentInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProfessionTalentInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut used_talent_points__ = None;
                let mut talent_node_ids__ = None;
                let mut talent_stage_cfg_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UsedTalentPoints => {
                            if used_talent_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UsedTalentPoints"));
                            }
                            used_talent_points__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TalentNodeIds => {
                            if talent_node_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TalentNodeIds"));
                            }
                            talent_node_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::TalentStageCfgId => {
                            if talent_stage_cfg_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TalentStageCfgId"));
                            }
                            talent_stage_cfg_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ProfessionTalentInfo {
                    used_talent_points: used_talent_points__,
                    talent_node_ids: talent_node_ids__.unwrap_or_default(),
                    talent_stage_cfg_id: talent_stage_cfg_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ProfessionTalentInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProfileInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.profile_id.is_some() {
            len += 1;
        }
        if self.profile_url.is_some() {
            len += 1;
        }
        if self.half_body_url.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ProfileInfo", len)?;
        if let Some(v) = self.profile_id.as_ref() {
            struct_ser.serialize_field("ProfileId", v)?;
        }
        if let Some(v) = self.profile_url.as_ref() {
            struct_ser.serialize_field("ProfileUrl", v)?;
        }
        if let Some(v) = self.half_body_url.as_ref() {
            struct_ser.serialize_field("HalfBodyUrl", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProfileInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ProfileId",
            "ProfileUrl",
            "HalfBodyUrl",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ProfileId,
            ProfileUrl,
            HalfBodyUrl,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ProfileId" => Ok(GeneratedField::ProfileId),
                            "ProfileUrl" => Ok(GeneratedField::ProfileUrl),
                            "HalfBodyUrl" => Ok(GeneratedField::HalfBodyUrl),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProfileInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ProfileInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProfileInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut profile_id__ = None;
                let mut profile_url__ = None;
                let mut half_body_url__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ProfileId => {
                            if profile_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfileId"));
                            }
                            profile_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ProfileUrl => {
                            if profile_url__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfileUrl"));
                            }
                            profile_url__ = map_.next_value()?;
                        }
                        GeneratedField::HalfBodyUrl => {
                            if half_body_url__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HalfBodyUrl"));
                            }
                            half_body_url__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ProfileInfo {
                    profile_id: profile_id__,
                    profile_url: profile_url__,
                    half_body_url: half_body_url__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ProfileInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProfileList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.unlock_profile_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ProfileList", len)?;
        if !self.unlock_profile_list.is_empty() {
            struct_ser.serialize_field("UnlockProfileList", &self.unlock_profile_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProfileList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UnlockProfileList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UnlockProfileList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UnlockProfileList" => Ok(GeneratedField::UnlockProfileList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProfileList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ProfileList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProfileList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut unlock_profile_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UnlockProfileList => {
                            if unlock_profile_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockProfileList"));
                            }
                            unlock_profile_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ProfileList {
                    unlock_profile_list: unlock_profile_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ProfileList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for QuestData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.step_id.is_some() {
            len += 1;
        }
        if self.state.is_some() {
            len += 1;
        }
        if !self.target_num.is_empty() {
            len += 1;
        }
        if !self.target_max_num.is_empty() {
            len += 1;
        }
        if self.step_limit_time.is_some() {
            len += 1;
        }
        if self.step_status.is_some() {
            len += 1;
        }
        if self.add_limit_time.is_some() {
            len += 1;
        }
        if !self.target_type.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.QuestData", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.step_id.as_ref() {
            struct_ser.serialize_field("StepId", v)?;
        }
        if let Some(v) = self.state.as_ref() {
            struct_ser.serialize_field("State", v)?;
        }
        if !self.target_num.is_empty() {
            struct_ser.serialize_field("TargetNum", &self.target_num)?;
        }
        if !self.target_max_num.is_empty() {
            struct_ser.serialize_field("TargetMaxNum", &self.target_max_num)?;
        }
        if let Some(v) = self.step_limit_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("StepLimitTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.step_status.as_ref() {
            let v = EQuestStepStatus::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("StepStatus", &v)?;
        }
        if let Some(v) = self.add_limit_time.as_ref() {
            struct_ser.serialize_field("AddLimitTime", v)?;
        }
        if !self.target_type.is_empty() {
            struct_ser.serialize_field("TargetType", &self.target_type)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for QuestData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "StepId",
            "State",
            "TargetNum",
            "TargetMaxNum",
            "StepLimitTime",
            "StepStatus",
            "AddLimitTime",
            "TargetType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            StepId,
            State,
            TargetNum,
            TargetMaxNum,
            StepLimitTime,
            StepStatus,
            AddLimitTime,
            TargetType,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "StepId" => Ok(GeneratedField::StepId),
                            "State" => Ok(GeneratedField::State),
                            "TargetNum" => Ok(GeneratedField::TargetNum),
                            "TargetMaxNum" => Ok(GeneratedField::TargetMaxNum),
                            "StepLimitTime" => Ok(GeneratedField::StepLimitTime),
                            "StepStatus" => Ok(GeneratedField::StepStatus),
                            "AddLimitTime" => Ok(GeneratedField::AddLimitTime),
                            "TargetType" => Ok(GeneratedField::TargetType),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuestData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.QuestData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<QuestData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut step_id__ = None;
                let mut state__ = None;
                let mut target_num__ = None;
                let mut target_max_num__ = None;
                let mut step_limit_time__ = None;
                let mut step_status__ = None;
                let mut add_limit_time__ = None;
                let mut target_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StepId => {
                            if step_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StepId"));
                            }
                            step_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("State"));
                            }
                            state__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetNum => {
                            if target_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetNum"));
                            }
                            target_num__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::TargetMaxNum => {
                            if target_max_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetMaxNum"));
                            }
                            target_max_num__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::StepLimitTime => {
                            if step_limit_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StepLimitTime"));
                            }
                            step_limit_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StepStatus => {
                            if step_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StepStatus"));
                            }
                            step_status__ = map_.next_value::<::std::option::Option<EQuestStepStatus>>()?.map(|x| x as i32);
                        }
                        GeneratedField::AddLimitTime => {
                            if add_limit_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AddLimitTime"));
                            }
                            add_limit_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetType => {
                            if target_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetType"));
                            }
                            target_type__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(QuestData {
                    id: id__,
                    step_id: step_id__,
                    state: state__,
                    target_num: target_num__.unwrap_or_default(),
                    target_max_num: target_max_num__.unwrap_or_default(),
                    step_limit_time: step_limit_time__,
                    step_status: step_status__,
                    add_limit_time: add_limit_time__,
                    target_type: target_type__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.QuestData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for QuestDataList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.quest_map.is_empty() {
            len += 1;
        }
        if !self.finish_quest.is_empty() {
            len += 1;
        }
        if self.tracking_id.is_some() {
            len += 1;
        }
        if !self.finish_reset_quest.is_empty() {
            len += 1;
        }
        if !self.history_map.is_empty() {
            len += 1;
        }
        if self.world_quest_time_stamp.is_some() {
            len += 1;
        }
        if !self.world_quest_info.is_empty() {
            len += 1;
        }
        if !self.all_world_quest_list.is_empty() {
            len += 1;
        }
        if !self.blue_world_quest_map.is_empty() {
            len += 1;
        }
        if !self.filter_event_id.is_empty() {
            len += 1;
        }
        if !self.accept_quest_list.is_empty() {
            len += 1;
        }
        if !self.follow_world_quest_list.is_empty() {
            len += 1;
        }
        if !self.track_optional_quest.is_empty() {
            len += 1;
        }
        if !self.finish_reset_quest_count.is_empty() {
            len += 1;
        }
        if !self.accept_quest_map.is_empty() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.QuestDataList", len)?;
        if !self.quest_map.is_empty() {
            struct_ser.serialize_field("QuestMap", &self.quest_map)?;
        }
        if !self.finish_quest.is_empty() {
            struct_ser.serialize_field("FinishQuest", &self.finish_quest)?;
        }
        if let Some(v) = self.tracking_id.as_ref() {
            struct_ser.serialize_field("TrackingId", v)?;
        }
        if !self.finish_reset_quest.is_empty() {
            struct_ser.serialize_field("FinishResetQuest", &self.finish_reset_quest)?;
        }
        if !self.history_map.is_empty() {
            struct_ser.serialize_field("HistoryMap", &self.history_map)?;
        }
        if let Some(v) = self.world_quest_time_stamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("WorldQuestTimeStamp", ToString::to_string(&v).as_str())?;
        }
        if !self.world_quest_info.is_empty() {
            struct_ser.serialize_field("WorldQuestInfo", &self.world_quest_info)?;
        }
        if !self.all_world_quest_list.is_empty() {
            struct_ser.serialize_field("AllWorldQuestList", &self.all_world_quest_list)?;
        }
        if !self.blue_world_quest_map.is_empty() {
            struct_ser.serialize_field("BlueWorldQuestMap", &self.blue_world_quest_map)?;
        }
        if !self.filter_event_id.is_empty() {
            struct_ser.serialize_field("FilterEventId", &self.filter_event_id)?;
        }
        if !self.accept_quest_list.is_empty() {
            struct_ser.serialize_field("AcceptQuestList", &self.accept_quest_list)?;
        }
        if !self.follow_world_quest_list.is_empty() {
            struct_ser.serialize_field("FollowWorldQuestList", &self.follow_world_quest_list)?;
        }
        if !self.track_optional_quest.is_empty() {
            struct_ser.serialize_field("TrackOptionalQuest", &self.track_optional_quest)?;
        }
        if !self.finish_reset_quest_count.is_empty() {
            struct_ser.serialize_field("FinishResetQuestCount", &self.finish_reset_quest_count)?;
        }
        if !self.accept_quest_map.is_empty() {
            struct_ser.serialize_field("AcceptQuestMap", &self.accept_quest_map)?;
        }
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Version", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for QuestDataList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "QuestMap",
            "FinishQuest",
            "TrackingId",
            "FinishResetQuest",
            "HistoryMap",
            "WorldQuestTimeStamp",
            "WorldQuestInfo",
            "AllWorldQuestList",
            "BlueWorldQuestMap",
            "FilterEventId",
            "AcceptQuestList",
            "FollowWorldQuestList",
            "TrackOptionalQuest",
            "FinishResetQuestCount",
            "AcceptQuestMap",
            "Version",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            QuestMap,
            FinishQuest,
            TrackingId,
            FinishResetQuest,
            HistoryMap,
            WorldQuestTimeStamp,
            WorldQuestInfo,
            AllWorldQuestList,
            BlueWorldQuestMap,
            FilterEventId,
            AcceptQuestList,
            FollowWorldQuestList,
            TrackOptionalQuest,
            FinishResetQuestCount,
            AcceptQuestMap,
            Version,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "QuestMap" => Ok(GeneratedField::QuestMap),
                            "FinishQuest" => Ok(GeneratedField::FinishQuest),
                            "TrackingId" => Ok(GeneratedField::TrackingId),
                            "FinishResetQuest" => Ok(GeneratedField::FinishResetQuest),
                            "HistoryMap" => Ok(GeneratedField::HistoryMap),
                            "WorldQuestTimeStamp" => Ok(GeneratedField::WorldQuestTimeStamp),
                            "WorldQuestInfo" => Ok(GeneratedField::WorldQuestInfo),
                            "AllWorldQuestList" => Ok(GeneratedField::AllWorldQuestList),
                            "BlueWorldQuestMap" => Ok(GeneratedField::BlueWorldQuestMap),
                            "FilterEventId" => Ok(GeneratedField::FilterEventId),
                            "AcceptQuestList" => Ok(GeneratedField::AcceptQuestList),
                            "FollowWorldQuestList" => Ok(GeneratedField::FollowWorldQuestList),
                            "TrackOptionalQuest" => Ok(GeneratedField::TrackOptionalQuest),
                            "FinishResetQuestCount" => Ok(GeneratedField::FinishResetQuestCount),
                            "AcceptQuestMap" => Ok(GeneratedField::AcceptQuestMap),
                            "Version" => Ok(GeneratedField::Version),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuestDataList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.QuestDataList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<QuestDataList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut quest_map__ = None;
                let mut finish_quest__ = None;
                let mut tracking_id__ = None;
                let mut finish_reset_quest__ = None;
                let mut history_map__ = None;
                let mut world_quest_time_stamp__ = None;
                let mut world_quest_info__ = None;
                let mut all_world_quest_list__ = None;
                let mut blue_world_quest_map__ = None;
                let mut filter_event_id__ = None;
                let mut accept_quest_list__ = None;
                let mut follow_world_quest_list__ = None;
                let mut track_optional_quest__ = None;
                let mut finish_reset_quest_count__ = None;
                let mut accept_quest_map__ = None;
                let mut version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::QuestMap => {
                            if quest_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("QuestMap"));
                            }
                            quest_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::FinishQuest => {
                            if finish_quest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FinishQuest"));
                            }
                            finish_quest__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::TrackingId => {
                            if tracking_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TrackingId"));
                            }
                            tracking_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FinishResetQuest => {
                            if finish_reset_quest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FinishResetQuest"));
                            }
                            finish_reset_quest__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<u32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::HistoryMap => {
                            if history_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HistoryMap"));
                            }
                            history_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::WorldQuestTimeStamp => {
                            if world_quest_time_stamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WorldQuestTimeStamp"));
                            }
                            world_quest_time_stamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WorldQuestInfo => {
                            if world_quest_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WorldQuestInfo"));
                            }
                            world_quest_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::AllWorldQuestList => {
                            if all_world_quest_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AllWorldQuestList"));
                            }
                            all_world_quest_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<u32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::BlueWorldQuestMap => {
                            if blue_world_quest_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BlueWorldQuestMap"));
                            }
                            blue_world_quest_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<u32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::FilterEventId => {
                            if filter_event_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FilterEventId"));
                            }
                            filter_event_id__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::AcceptQuestList => {
                            if accept_quest_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AcceptQuestList"));
                            }
                            accept_quest_list__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::FollowWorldQuestList => {
                            if follow_world_quest_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FollowWorldQuestList"));
                            }
                            follow_world_quest_list__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::TrackOptionalQuest => {
                            if track_optional_quest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TrackOptionalQuest"));
                            }
                            track_optional_quest__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<u32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::FinishResetQuestCount => {
                            if finish_reset_quest_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FinishResetQuestCount"));
                            }
                            finish_reset_quest_count__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<u32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::AcceptQuestMap => {
                            if accept_quest_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AcceptQuestMap"));
                            }
                            accept_quest_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(QuestDataList {
                    quest_map: quest_map__.unwrap_or_default(),
                    finish_quest: finish_quest__.unwrap_or_default(),
                    tracking_id: tracking_id__,
                    finish_reset_quest: finish_reset_quest__.unwrap_or_default(),
                    history_map: history_map__.unwrap_or_default(),
                    world_quest_time_stamp: world_quest_time_stamp__,
                    world_quest_info: world_quest_info__.unwrap_or_default(),
                    all_world_quest_list: all_world_quest_list__.unwrap_or_default(),
                    blue_world_quest_map: blue_world_quest_map__.unwrap_or_default(),
                    filter_event_id: filter_event_id__.unwrap_or_default(),
                    accept_quest_list: accept_quest_list__.unwrap_or_default(),
                    follow_world_quest_list: follow_world_quest_list__.unwrap_or_default(),
                    track_optional_quest: track_optional_quest__.unwrap_or_default(),
                    finish_reset_quest_count: finish_reset_quest_count__.unwrap_or_default(),
                    accept_quest_map: accept_quest_map__.unwrap_or_default(),
                    version: version__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.QuestDataList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for QuestHistory {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.step_history.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.QuestHistory", len)?;
        if !self.step_history.is_empty() {
            struct_ser.serialize_field("StepHistory", &self.step_history)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for QuestHistory {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "StepHistory",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StepHistory,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "StepHistory" => Ok(GeneratedField::StepHistory),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = QuestHistory;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.QuestHistory")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<QuestHistory, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut step_history__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StepHistory => {
                            if step_history__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StepHistory"));
                            }
                            step_history__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<u32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(QuestHistory {
                    step_history: step_history__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.QuestHistory", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RaidRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.boss_progress.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RaidRecord", len)?;
        if !self.boss_progress.is_empty() {
            struct_ser.serialize_field("BossProgress", &self.boss_progress)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RaidRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BossProgress",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BossProgress,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BossProgress" => Ok(GeneratedField::BossProgress),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RaidRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RaidRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RaidRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut boss_progress__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BossProgress => {
                            if boss_progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BossProgress"));
                            }
                            boss_progress__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(RaidRecord {
                    boss_progress: boss_progress__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RaidRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RankData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.rank.is_some() {
            len += 1;
        }
        if self.char_id.is_some() {
            len += 1;
        }
        if self.score.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RankData", len)?;
        if let Some(v) = self.rank.as_ref() {
            struct_ser.serialize_field("Rank", v)?;
        }
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.score.as_ref() {
            struct_ser.serialize_field("Score", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RankData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Rank",
            "CharId",
            "Score",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Rank,
            CharId,
            Score,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Rank" => Ok(GeneratedField::Rank),
                            "CharId" => Ok(GeneratedField::CharId),
                            "Score" => Ok(GeneratedField::Score),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RankData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RankData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RankData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut rank__ = None;
                let mut char_id__ = None;
                let mut score__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Rank => {
                            if rank__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Rank"));
                            }
                            rank__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Score => {
                            if score__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Score"));
                            }
                            score__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(RankData {
                    rank: rank__,
                    char_id: char_id__,
                    score: score__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RankData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RechargeData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.accumulate_amount.is_some() {
            len += 1;
        }
        if self.last_recharge_time.is_some() {
            len += 1;
        }
        if self.last_recharge_amount.is_some() {
            len += 1;
        }
        if self.last_diamond_amount.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RechargeData", len)?;
        if let Some(v) = self.accumulate_amount.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("AccumulateAmount", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.last_recharge_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastRechargeTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.last_recharge_amount.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastRechargeAmount", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.last_diamond_amount.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastDiamondAmount", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RechargeData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AccumulateAmount",
            "LastRechargeTime",
            "LastRechargeAmount",
            "LastDiamondAmount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AccumulateAmount,
            LastRechargeTime,
            LastRechargeAmount,
            LastDiamondAmount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AccumulateAmount" => Ok(GeneratedField::AccumulateAmount),
                            "LastRechargeTime" => Ok(GeneratedField::LastRechargeTime),
                            "LastRechargeAmount" => Ok(GeneratedField::LastRechargeAmount),
                            "LastDiamondAmount" => Ok(GeneratedField::LastDiamondAmount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RechargeData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RechargeData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RechargeData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut accumulate_amount__ = None;
                let mut last_recharge_time__ = None;
                let mut last_recharge_amount__ = None;
                let mut last_diamond_amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AccumulateAmount => {
                            if accumulate_amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccumulateAmount"));
                            }
                            accumulate_amount__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastRechargeTime => {
                            if last_recharge_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastRechargeTime"));
                            }
                            last_recharge_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastRechargeAmount => {
                            if last_recharge_amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastRechargeAmount"));
                            }
                            last_recharge_amount__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastDiamondAmount => {
                            if last_diamond_amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastDiamondAmount"));
                            }
                            last_diamond_amount__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(RechargeData {
                    accumulate_amount: accumulate_amount__,
                    last_recharge_time: last_recharge_time__,
                    last_recharge_amount: last_recharge_amount__,
                    last_diamond_amount: last_diamond_amount__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RechargeData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RecvAntiData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RecvAntiData", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RecvAntiData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RecvAntiData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RecvAntiData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RecvAntiData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(RecvAntiData {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RecvAntiData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RecvAntiDataRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.tss_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RecvAntiDataRequest", len)?;
        if let Some(v) = self.tss_info.as_ref() {
            struct_ser.serialize_field("TssInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RecvAntiDataRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TssInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TssInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TssInfo" => Ok(GeneratedField::TssInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RecvAntiDataRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RecvAntiDataRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RecvAntiDataRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut tss_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TssInfo => {
                            if tss_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TssInfo"));
                            }
                            tss_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(RecvAntiDataRequest {
                    tss_info: tss_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RecvAntiDataRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RedDotData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.permanent_closed_red_dot.is_empty() {
            len += 1;
        }
        if !self.red_dot_count.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RedDotData", len)?;
        if !self.permanent_closed_red_dot.is_empty() {
            struct_ser.serialize_field("PermanentClosedRedDot", &self.permanent_closed_red_dot)?;
        }
        if !self.red_dot_count.is_empty() {
            struct_ser.serialize_field("RedDotCount", &self.red_dot_count)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RedDotData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PermanentClosedRedDot",
            "RedDotCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PermanentClosedRedDot,
            RedDotCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PermanentClosedRedDot" => Ok(GeneratedField::PermanentClosedRedDot),
                            "RedDotCount" => Ok(GeneratedField::RedDotCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RedDotData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RedDotData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RedDotData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut permanent_closed_red_dot__ = None;
                let mut red_dot_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PermanentClosedRedDot => {
                            if permanent_closed_red_dot__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PermanentClosedRedDot"));
                            }
                            permanent_closed_red_dot__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::RedDotCount => {
                            if red_dot_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RedDotCount"));
                            }
                            red_dot_count__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(RedDotData {
                    permanent_closed_red_dot: permanent_closed_red_dot__.unwrap_or_default(),
                    red_dot_count: red_dot_count__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RedDotData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReqServerTime {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.client_milliseconds.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ReqServerTime", len)?;
        if let Some(v) = self.client_milliseconds.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ClientMilliseconds", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReqServerTime {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ClientMilliseconds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ClientMilliseconds,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ClientMilliseconds" => Ok(GeneratedField::ClientMilliseconds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReqServerTime;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ReqServerTime")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReqServerTime, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut client_milliseconds__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ClientMilliseconds => {
                            if client_milliseconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ClientMilliseconds"));
                            }
                            client_milliseconds__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ReqServerTime {
                    client_milliseconds: client_milliseconds__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ReqServerTime", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReqSwitchScene {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.resp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ReqSwitchScene", len)?;
        if let Some(v) = self.resp.as_ref() {
            struct_ser.serialize_field("Resp", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReqSwitchScene {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Resp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Resp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Resp" => Ok(GeneratedField::Resp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReqSwitchScene;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ReqSwitchScene")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReqSwitchScene, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut resp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Resp => {
                            if resp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Resp"));
                            }
                            resp__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ReqSwitchScene {
                    resp: resp__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ReqSwitchScene", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RequestConnectWorld {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.account_id.is_some() {
            len += 1;
        }
        if self.char_id.is_some() {
            len += 1;
        }
        if self.token.is_some() {
            len += 1;
        }
        if self.ack_server_sequence.is_some() {
            len += 1;
        }
        if self.session_token.is_some() {
            len += 1;
        }
        if self.is_ai_bot.is_some() {
            len += 1;
        }
        if self.client_version.is_some() {
            len += 1;
        }
        if self.client_resource_version.is_some() {
            len += 1;
        }
        if self.os.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RequestConnectWorld", len)?;
        if let Some(v) = self.account_id.as_ref() {
            struct_ser.serialize_field("AccountId", v)?;
        }
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.token.as_ref() {
            struct_ser.serialize_field("Token", v)?;
        }
        if let Some(v) = self.ack_server_sequence.as_ref() {
            struct_ser.serialize_field("AckServerSequence", v)?;
        }
        if let Some(v) = self.session_token.as_ref() {
            struct_ser.serialize_field("SessionToken", v)?;
        }
        if let Some(v) = self.is_ai_bot.as_ref() {
            struct_ser.serialize_field("IsAiBot", v)?;
        }
        if let Some(v) = self.client_version.as_ref() {
            struct_ser.serialize_field("ClientVersion", v)?;
        }
        if let Some(v) = self.client_resource_version.as_ref() {
            struct_ser.serialize_field("ClientResourceVersion", v)?;
        }
        if let Some(v) = self.os.as_ref() {
            struct_ser.serialize_field("Os", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RequestConnectWorld {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AccountId",
            "CharId",
            "Token",
            "AckServerSequence",
            "SessionToken",
            "IsAiBot",
            "ClientVersion",
            "ClientResourceVersion",
            "Os",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AccountId,
            CharId,
            Token,
            AckServerSequence,
            SessionToken,
            IsAiBot,
            ClientVersion,
            ClientResourceVersion,
            Os,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AccountId" => Ok(GeneratedField::AccountId),
                            "CharId" => Ok(GeneratedField::CharId),
                            "Token" => Ok(GeneratedField::Token),
                            "AckServerSequence" => Ok(GeneratedField::AckServerSequence),
                            "SessionToken" => Ok(GeneratedField::SessionToken),
                            "IsAiBot" => Ok(GeneratedField::IsAiBot),
                            "ClientVersion" => Ok(GeneratedField::ClientVersion),
                            "ClientResourceVersion" => Ok(GeneratedField::ClientResourceVersion),
                            "Os" => Ok(GeneratedField::Os),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RequestConnectWorld;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RequestConnectWorld")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RequestConnectWorld, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut account_id__ = None;
                let mut char_id__ = None;
                let mut token__ = None;
                let mut ack_server_sequence__ = None;
                let mut session_token__ = None;
                let mut is_ai_bot__ = None;
                let mut client_version__ = None;
                let mut client_resource_version__ = None;
                let mut os__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AccountId => {
                            if account_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccountId"));
                            }
                            account_id__ = map_.next_value()?;
                        }
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Token => {
                            if token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Token"));
                            }
                            token__ = map_.next_value()?;
                        }
                        GeneratedField::AckServerSequence => {
                            if ack_server_sequence__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AckServerSequence"));
                            }
                            ack_server_sequence__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SessionToken => {
                            if session_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SessionToken"));
                            }
                            session_token__ = map_.next_value()?;
                        }
                        GeneratedField::IsAiBot => {
                            if is_ai_bot__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsAiBot"));
                            }
                            is_ai_bot__ = map_.next_value()?;
                        }
                        GeneratedField::ClientVersion => {
                            if client_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ClientVersion"));
                            }
                            client_version__ = map_.next_value()?;
                        }
                        GeneratedField::ClientResourceVersion => {
                            if client_resource_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ClientResourceVersion"));
                            }
                            client_resource_version__ = map_.next_value()?;
                        }
                        GeneratedField::Os => {
                            if os__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Os"));
                            }
                            os__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(RequestConnectWorld {
                    account_id: account_id__,
                    char_id: char_id__,
                    token: token__,
                    ack_server_sequence: ack_server_sequence__,
                    session_token: session_token__,
                    is_ai_bot: is_ai_bot__,
                    client_version: client_version__,
                    client_resource_version: client_resource_version__,
                    os: os__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RequestConnectWorld", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ResetAttachVelocity {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.attach_source.is_some() {
            len += 1;
        }
        if self.source_ent_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ResetAttachVelocity", len)?;
        if let Some(v) = self.attach_source.as_ref() {
            struct_ser.serialize_field("AttachSource", v)?;
        }
        if let Some(v) = self.source_ent_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SourceEntUuid", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ResetAttachVelocity {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "AttachSource",
            "SourceEntUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AttachSource,
            SourceEntUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "AttachSource" => Ok(GeneratedField::AttachSource),
                            "SourceEntUuid" => Ok(GeneratedField::SourceEntUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ResetAttachVelocity;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ResetAttachVelocity")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ResetAttachVelocity, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut attach_source__ = None;
                let mut source_ent_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AttachSource => {
                            if attach_source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AttachSource"));
                            }
                            attach_source__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SourceEntUuid => {
                            if source_ent_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SourceEntUuid"));
                            }
                            source_ent_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ResetAttachVelocity {
                    attach_source: attach_source__,
                    source_ent_uuid: source_ent_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ResetAttachVelocity", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Resonance {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.resonances.is_empty() {
            len += 1;
        }
        if !self.installed.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Resonance", len)?;
        if !self.resonances.is_empty() {
            let v: std::collections::HashMap<_, _> = self.resonances.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("Resonances", &v)?;
        }
        if !self.installed.is_empty() {
            struct_ser.serialize_field("Installed", &self.installed)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Resonance {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Resonances",
            "Installed",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Resonances,
            Installed,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Resonances" => Ok(GeneratedField::Resonances),
                            "Installed" => Ok(GeneratedField::Installed),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Resonance;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Resonance")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Resonance, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut resonances__ = None;
                let mut installed__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Resonances => {
                            if resonances__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Resonances"));
                            }
                            resonances__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::Installed => {
                            if installed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Installed"));
                            }
                            installed__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(Resonance {
                    resonances: resonances__.unwrap_or_default(),
                    installed: installed__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Resonance", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReviveInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.revive_count.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ReviveInfo", len)?;
        if !self.revive_count.is_empty() {
            struct_ser.serialize_field("ReviveCount", &self.revive_count)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReviveInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ReviveCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ReviveCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ReviveCount" => Ok(GeneratedField::ReviveCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReviveInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ReviveInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReviveInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut revive_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ReviveCount => {
                            if revive_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReviveCount"));
                            }
                            revive_count__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(ReviveInfo {
                    revive_count: revive_count__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ReviveInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RideData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.ride_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RideData", len)?;
        if let Some(v) = self.ride_id.as_ref() {
            struct_ser.serialize_field("RideId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RideData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RideId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RideId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RideId" => Ok(GeneratedField::RideId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RideData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RideData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RideData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ride_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RideId => {
                            if ride_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RideId"));
                            }
                            ride_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(RideData {
                    ride_id: ride_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RideData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RideList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.rides.is_empty() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        if !self.skin_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RideList", len)?;
        if !self.rides.is_empty() {
            struct_ser.serialize_field("Rides", &self.rides)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            let v = ERidePropertyType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Type", &v)?;
        }
        if !self.skin_data.is_empty() {
            struct_ser.serialize_field("SkinData", &self.skin_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RideList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Rides",
            "Type",
            "SkinData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Rides,
            Type,
            SkinData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Rides" => Ok(GeneratedField::Rides),
                            "Type" => Ok(GeneratedField::Type),
                            "SkinData" => Ok(GeneratedField::SkinData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RideList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RideList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RideList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut rides__ = None;
                let mut r#type__ = None;
                let mut skin_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Rides => {
                            if rides__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Rides"));
                            }
                            rides__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<ERidePropertyType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::SkinData => {
                            if skin_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkinData"));
                            }
                            skin_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(RideList {
                    rides: rides__.unwrap_or_default(),
                    r#type: r#type__,
                    skin_data: skin_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RideList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RideMagneticAttachTo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RideMagneticAttachTo", len)?;
        if let Some(v) = self.target_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetUuid", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RideMagneticAttachTo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RideMagneticAttachTo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RideMagneticAttachTo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RideMagneticAttachTo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(RideMagneticAttachTo {
                    target_uuid: target_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RideMagneticAttachTo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RideQualityCollectInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.quality_count.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RideQualityCollectInfo", len)?;
        if !self.quality_count.is_empty() {
            struct_ser.serialize_field("QualityCount", &self.quality_count)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RideQualityCollectInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "QualityCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            QualityCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "QualityCount" => Ok(GeneratedField::QualityCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RideQualityCollectInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RideQualityCollectInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RideQualityCollectInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut quality_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::QualityCount => {
                            if quality_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("QualityCount"));
                            }
                            quality_count__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(RideQualityCollectInfo {
                    quality_count: quality_count__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RideQualityCollectInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RideSkinContainer {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.ride_skin_id.is_some() {
            len += 1;
        }
        if !self.sinks.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RideSkinContainer", len)?;
        if let Some(v) = self.ride_skin_id.as_ref() {
            struct_ser.serialize_field("RideSkinId", v)?;
        }
        if !self.sinks.is_empty() {
            struct_ser.serialize_field("Sinks", &self.sinks)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RideSkinContainer {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RideSkinId",
            "Sinks",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RideSkinId,
            Sinks,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RideSkinId" => Ok(GeneratedField::RideSkinId),
                            "Sinks" => Ok(GeneratedField::Sinks),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RideSkinContainer;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RideSkinContainer")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RideSkinContainer, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut ride_skin_id__ = None;
                let mut sinks__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RideSkinId => {
                            if ride_skin_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RideSkinId"));
                            }
                            ride_skin_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Sinks => {
                            if sinks__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Sinks"));
                            }
                            sinks__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(RideSkinContainer {
                    ride_skin_id: ride_skin_id__,
                    sinks: sinks__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RideSkinContainer", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RideSkinData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.activate_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RideSkinData", len)?;
        if let Some(v) = self.activate_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ActivateTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RideSkinData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ActivateTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ActivateTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ActivateTime" => Ok(GeneratedField::ActivateTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RideSkinData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RideSkinData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RideSkinData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut activate_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ActivateTime => {
                            if activate_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActivateTime"));
                            }
                            activate_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(RideSkinData {
                    activate_time: activate_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RideSkinData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RoleFace {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.unlock_item_map.is_empty() {
            len += 1;
        }
        if self.save_need_consume.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RoleFace", len)?;
        if !self.unlock_item_map.is_empty() {
            struct_ser.serialize_field("UnlockItemMap", &self.unlock_item_map)?;
        }
        if let Some(v) = self.save_need_consume.as_ref() {
            struct_ser.serialize_field("SaveNeedConsume", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RoleFace {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UnlockItemMap",
            "SaveNeedConsume",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UnlockItemMap,
            SaveNeedConsume,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UnlockItemMap" => Ok(GeneratedField::UnlockItemMap),
                            "SaveNeedConsume" => Ok(GeneratedField::SaveNeedConsume),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RoleFace;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RoleFace")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RoleFace, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut unlock_item_map__ = None;
                let mut save_need_consume__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UnlockItemMap => {
                            if unlock_item_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockItemMap"));
                            }
                            unlock_item_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::SaveNeedConsume => {
                            if save_need_consume__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SaveNeedConsume"));
                            }
                            save_need_consume__ = map_.next_value()?;
                        }
                    }
                }
                Ok(RoleFace {
                    unlock_item_map: unlock_item_map__.unwrap_or_default(),
                    save_need_consume: save_need_consume__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RoleFace", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RoleLevel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.level.is_some() {
            len += 1;
        }
        if self.cur_level_exp.is_some() {
            len += 1;
        }
        if !self.received_level_list.is_empty() {
            len += 1;
        }
        if self.proficiency_info.is_some() {
            len += 1;
        }
        if !self.active_exp_map.is_empty() {
            len += 1;
        }
        if self.last_season_day.is_some() {
            len += 1;
        }
        if self.bless_exp_pool.is_some() {
            len += 1;
        }
        if self.grant_bless_exp.is_some() {
            len += 1;
        }
        if self.accumulate_bless_exp.is_some() {
            len += 1;
        }
        if self.accumulate_exp.is_some() {
            len += 1;
        }
        if self.prev_season_max_lv.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.RoleLevel", len)?;
        if let Some(v) = self.level.as_ref() {
            struct_ser.serialize_field("Level", v)?;
        }
        if let Some(v) = self.cur_level_exp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CurLevelExp", ToString::to_string(&v).as_str())?;
        }
        if !self.received_level_list.is_empty() {
            struct_ser.serialize_field("ReceivedLevelList", &self.received_level_list)?;
        }
        if let Some(v) = self.proficiency_info.as_ref() {
            struct_ser.serialize_field("ProficiencyInfo", v)?;
        }
        if !self.active_exp_map.is_empty() {
            let v: std::collections::HashMap<_, _> = self.active_exp_map.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("ActiveExpMap", &v)?;
        }
        if let Some(v) = self.last_season_day.as_ref() {
            struct_ser.serialize_field("LastSeasonDay", v)?;
        }
        if let Some(v) = self.bless_exp_pool.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BlessExpPool", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.grant_bless_exp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("GrantBlessExp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.accumulate_bless_exp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("AccumulateBlessExp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.accumulate_exp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("AccumulateExp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.prev_season_max_lv.as_ref() {
            struct_ser.serialize_field("PrevSeasonMaxLv", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RoleLevel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Level",
            "CurLevelExp",
            "ReceivedLevelList",
            "ProficiencyInfo",
            "ActiveExpMap",
            "LastSeasonDay",
            "BlessExpPool",
            "GrantBlessExp",
            "AccumulateBlessExp",
            "AccumulateExp",
            "PrevSeasonMaxLv",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Level,
            CurLevelExp,
            ReceivedLevelList,
            ProficiencyInfo,
            ActiveExpMap,
            LastSeasonDay,
            BlessExpPool,
            GrantBlessExp,
            AccumulateBlessExp,
            AccumulateExp,
            PrevSeasonMaxLv,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Level" => Ok(GeneratedField::Level),
                            "CurLevelExp" => Ok(GeneratedField::CurLevelExp),
                            "ReceivedLevelList" => Ok(GeneratedField::ReceivedLevelList),
                            "ProficiencyInfo" => Ok(GeneratedField::ProficiencyInfo),
                            "ActiveExpMap" => Ok(GeneratedField::ActiveExpMap),
                            "LastSeasonDay" => Ok(GeneratedField::LastSeasonDay),
                            "BlessExpPool" => Ok(GeneratedField::BlessExpPool),
                            "GrantBlessExp" => Ok(GeneratedField::GrantBlessExp),
                            "AccumulateBlessExp" => Ok(GeneratedField::AccumulateBlessExp),
                            "AccumulateExp" => Ok(GeneratedField::AccumulateExp),
                            "PrevSeasonMaxLv" => Ok(GeneratedField::PrevSeasonMaxLv),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RoleLevel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.RoleLevel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RoleLevel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut level__ = None;
                let mut cur_level_exp__ = None;
                let mut received_level_list__ = None;
                let mut proficiency_info__ = None;
                let mut active_exp_map__ = None;
                let mut last_season_day__ = None;
                let mut bless_exp_pool__ = None;
                let mut grant_bless_exp__ = None;
                let mut accumulate_bless_exp__ = None;
                let mut accumulate_exp__ = None;
                let mut prev_season_max_lv__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Level => {
                            if level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Level"));
                            }
                            level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurLevelExp => {
                            if cur_level_exp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurLevelExp"));
                            }
                            cur_level_exp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReceivedLevelList => {
                            if received_level_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReceivedLevelList"));
                            }
                            received_level_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::ProficiencyInfo => {
                            if proficiency_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProficiencyInfo"));
                            }
                            proficiency_info__ = map_.next_value()?;
                        }
                        GeneratedField::ActiveExpMap => {
                            if active_exp_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActiveExpMap"));
                            }
                            active_exp_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::LastSeasonDay => {
                            if last_season_day__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastSeasonDay"));
                            }
                            last_season_day__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BlessExpPool => {
                            if bless_exp_pool__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BlessExpPool"));
                            }
                            bless_exp_pool__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GrantBlessExp => {
                            if grant_bless_exp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GrantBlessExp"));
                            }
                            grant_bless_exp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AccumulateBlessExp => {
                            if accumulate_bless_exp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccumulateBlessExp"));
                            }
                            accumulate_bless_exp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AccumulateExp => {
                            if accumulate_exp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccumulateExp"));
                            }
                            accumulate_exp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PrevSeasonMaxLv => {
                            if prev_season_max_lv__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PrevSeasonMaxLv"));
                            }
                            prev_season_max_lv__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(RoleLevel {
                    level: level__,
                    cur_level_exp: cur_level_exp__,
                    received_level_list: received_level_list__.unwrap_or_default(),
                    proficiency_info: proficiency_info__,
                    active_exp_map: active_exp_map__.unwrap_or_default(),
                    last_season_day: last_season_day__,
                    bless_exp_pool: bless_exp_pool__,
                    grant_bless_exp: grant_bless_exp__,
                    accumulate_bless_exp: accumulate_bless_exp__,
                    accumulate_exp: accumulate_exp__,
                    prev_season_max_lv: prev_season_max_lv__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.RoleLevel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SaveUserSingleSceneCutsState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cuts_key.is_some() {
            len += 1;
        }
        if self.cuts_value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SaveUserSingleSceneCutsState", len)?;
        if let Some(v) = self.cuts_key.as_ref() {
            struct_ser.serialize_field("CutsKey", v)?;
        }
        if let Some(v) = self.cuts_value.as_ref() {
            struct_ser.serialize_field("CutsValue", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SaveUserSingleSceneCutsState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CutsKey",
            "CutsValue",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CutsKey,
            CutsValue,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CutsKey" => Ok(GeneratedField::CutsKey),
                            "CutsValue" => Ok(GeneratedField::CutsValue),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SaveUserSingleSceneCutsState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SaveUserSingleSceneCutsState")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SaveUserSingleSceneCutsState, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cuts_key__ = None;
                let mut cuts_value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CutsKey => {
                            if cuts_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CutsKey"));
                            }
                            cuts_key__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CutsValue => {
                            if cuts_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CutsValue"));
                            }
                            cuts_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SaveUserSingleSceneCutsState {
                    cuts_key: cuts_key__,
                    cuts_value: cuts_value__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SaveUserSingleSceneCutsState", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SceneData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.map_id.is_some() {
            len += 1;
        }
        if self.channel_id.is_some() {
            len += 1;
        }
        if self.pos.is_some() {
            len += 1;
        }
        if self.level_uuid.is_some() {
            len += 1;
        }
        if self.level_pos.is_some() {
            len += 1;
        }
        if self.level_map_id.is_some() {
            len += 1;
        }
        if self.level_revive_id.is_some() {
            len += 1;
        }
        if !self.record_id.is_empty() {
            len += 1;
        }
        if self.plane_id.is_some() {
            len += 1;
        }
        if self.scene_layer.is_some() {
            len += 1;
        }
        if self.can_switch_layer.is_some() {
            len += 1;
        }
        if self.before_fall_pos.is_some() {
            len += 1;
        }
        if self.scene_guid.is_some() {
            len += 1;
        }
        if self.dungeon_guid.is_some() {
            len += 1;
        }
        if self.line_id.is_some() {
            len += 1;
        }
        if self.visual_layer_config_id.is_some() {
            len += 1;
        }
        if self.last_scene_data.is_some() {
            len += 1;
        }
        if self.scene_area_id.is_some() {
            len += 1;
        }
        if self.level_area_id.is_some() {
            len += 1;
        }
        if self.before_fall_scene_area_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SceneData", len)?;
        if let Some(v) = self.map_id.as_ref() {
            struct_ser.serialize_field("MapId", v)?;
        }
        if let Some(v) = self.channel_id.as_ref() {
            struct_ser.serialize_field("ChannelId", v)?;
        }
        if let Some(v) = self.pos.as_ref() {
            struct_ser.serialize_field("Pos", v)?;
        }
        if let Some(v) = self.level_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LevelUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.level_pos.as_ref() {
            struct_ser.serialize_field("LevelPos", v)?;
        }
        if let Some(v) = self.level_map_id.as_ref() {
            struct_ser.serialize_field("LevelMapId", v)?;
        }
        if let Some(v) = self.level_revive_id.as_ref() {
            struct_ser.serialize_field("LevelReviveId", v)?;
        }
        if !self.record_id.is_empty() {
            struct_ser.serialize_field("RecordId", &self.record_id)?;
        }
        if let Some(v) = self.plane_id.as_ref() {
            struct_ser.serialize_field("PlaneId", v)?;
        }
        if let Some(v) = self.scene_layer.as_ref() {
            struct_ser.serialize_field("SceneLayer", v)?;
        }
        if let Some(v) = self.can_switch_layer.as_ref() {
            struct_ser.serialize_field("CanSwitchLayer", v)?;
        }
        if let Some(v) = self.before_fall_pos.as_ref() {
            struct_ser.serialize_field("BeforeFallPos", v)?;
        }
        if let Some(v) = self.scene_guid.as_ref() {
            struct_ser.serialize_field("SceneGuid", v)?;
        }
        if let Some(v) = self.dungeon_guid.as_ref() {
            struct_ser.serialize_field("DungeonGuid", v)?;
        }
        if let Some(v) = self.line_id.as_ref() {
            struct_ser.serialize_field("LineId", v)?;
        }
        if let Some(v) = self.visual_layer_config_id.as_ref() {
            struct_ser.serialize_field("VisualLayerConfigId", v)?;
        }
        if let Some(v) = self.last_scene_data.as_ref() {
            struct_ser.serialize_field("LastSceneData", v)?;
        }
        if let Some(v) = self.scene_area_id.as_ref() {
            struct_ser.serialize_field("SceneAreaId", v)?;
        }
        if let Some(v) = self.level_area_id.as_ref() {
            struct_ser.serialize_field("LevelAreaId", v)?;
        }
        if let Some(v) = self.before_fall_scene_area_id.as_ref() {
            struct_ser.serialize_field("BeforeFallSceneAreaId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SceneData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MapId",
            "ChannelId",
            "Pos",
            "LevelUuid",
            "LevelPos",
            "LevelMapId",
            "LevelReviveId",
            "RecordId",
            "PlaneId",
            "SceneLayer",
            "CanSwitchLayer",
            "BeforeFallPos",
            "SceneGuid",
            "DungeonGuid",
            "LineId",
            "VisualLayerConfigId",
            "LastSceneData",
            "SceneAreaId",
            "LevelAreaId",
            "BeforeFallSceneAreaId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MapId,
            ChannelId,
            Pos,
            LevelUuid,
            LevelPos,
            LevelMapId,
            LevelReviveId,
            RecordId,
            PlaneId,
            SceneLayer,
            CanSwitchLayer,
            BeforeFallPos,
            SceneGuid,
            DungeonGuid,
            LineId,
            VisualLayerConfigId,
            LastSceneData,
            SceneAreaId,
            LevelAreaId,
            BeforeFallSceneAreaId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MapId" => Ok(GeneratedField::MapId),
                            "ChannelId" => Ok(GeneratedField::ChannelId),
                            "Pos" => Ok(GeneratedField::Pos),
                            "LevelUuid" => Ok(GeneratedField::LevelUuid),
                            "LevelPos" => Ok(GeneratedField::LevelPos),
                            "LevelMapId" => Ok(GeneratedField::LevelMapId),
                            "LevelReviveId" => Ok(GeneratedField::LevelReviveId),
                            "RecordId" => Ok(GeneratedField::RecordId),
                            "PlaneId" => Ok(GeneratedField::PlaneId),
                            "SceneLayer" => Ok(GeneratedField::SceneLayer),
                            "CanSwitchLayer" => Ok(GeneratedField::CanSwitchLayer),
                            "BeforeFallPos" => Ok(GeneratedField::BeforeFallPos),
                            "SceneGuid" => Ok(GeneratedField::SceneGuid),
                            "DungeonGuid" => Ok(GeneratedField::DungeonGuid),
                            "LineId" => Ok(GeneratedField::LineId),
                            "VisualLayerConfigId" => Ok(GeneratedField::VisualLayerConfigId),
                            "LastSceneData" => Ok(GeneratedField::LastSceneData),
                            "SceneAreaId" => Ok(GeneratedField::SceneAreaId),
                            "LevelAreaId" => Ok(GeneratedField::LevelAreaId),
                            "BeforeFallSceneAreaId" => Ok(GeneratedField::BeforeFallSceneAreaId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SceneData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SceneData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SceneData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut map_id__ = None;
                let mut channel_id__ = None;
                let mut pos__ = None;
                let mut level_uuid__ = None;
                let mut level_pos__ = None;
                let mut level_map_id__ = None;
                let mut level_revive_id__ = None;
                let mut record_id__ = None;
                let mut plane_id__ = None;
                let mut scene_layer__ = None;
                let mut can_switch_layer__ = None;
                let mut before_fall_pos__ = None;
                let mut scene_guid__ = None;
                let mut dungeon_guid__ = None;
                let mut line_id__ = None;
                let mut visual_layer_config_id__ = None;
                let mut last_scene_data__ = None;
                let mut scene_area_id__ = None;
                let mut level_area_id__ = None;
                let mut before_fall_scene_area_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MapId => {
                            if map_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MapId"));
                            }
                            map_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ChannelId => {
                            if channel_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ChannelId"));
                            }
                            channel_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Pos => {
                            if pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Pos"));
                            }
                            pos__ = map_.next_value()?;
                        }
                        GeneratedField::LevelUuid => {
                            if level_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LevelUuid"));
                            }
                            level_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LevelPos => {
                            if level_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LevelPos"));
                            }
                            level_pos__ = map_.next_value()?;
                        }
                        GeneratedField::LevelMapId => {
                            if level_map_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LevelMapId"));
                            }
                            level_map_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LevelReviveId => {
                            if level_revive_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LevelReviveId"));
                            }
                            level_revive_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RecordId => {
                            if record_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RecordId"));
                            }
                            record_id__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<u32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::PlaneId => {
                            if plane_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlaneId"));
                            }
                            plane_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SceneLayer => {
                            if scene_layer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneLayer"));
                            }
                            scene_layer__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CanSwitchLayer => {
                            if can_switch_layer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CanSwitchLayer"));
                            }
                            can_switch_layer__ = map_.next_value()?;
                        }
                        GeneratedField::BeforeFallPos => {
                            if before_fall_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeforeFallPos"));
                            }
                            before_fall_pos__ = map_.next_value()?;
                        }
                        GeneratedField::SceneGuid => {
                            if scene_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneGuid"));
                            }
                            scene_guid__ = map_.next_value()?;
                        }
                        GeneratedField::DungeonGuid => {
                            if dungeon_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonGuid"));
                            }
                            dungeon_guid__ = map_.next_value()?;
                        }
                        GeneratedField::LineId => {
                            if line_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LineId"));
                            }
                            line_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VisualLayerConfigId => {
                            if visual_layer_config_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VisualLayerConfigId"));
                            }
                            visual_layer_config_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastSceneData => {
                            if last_scene_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastSceneData"));
                            }
                            last_scene_data__ = map_.next_value()?;
                        }
                        GeneratedField::SceneAreaId => {
                            if scene_area_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneAreaId"));
                            }
                            scene_area_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LevelAreaId => {
                            if level_area_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LevelAreaId"));
                            }
                            level_area_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BeforeFallSceneAreaId => {
                            if before_fall_scene_area_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeforeFallSceneAreaId"));
                            }
                            before_fall_scene_area_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SceneData {
                    map_id: map_id__,
                    channel_id: channel_id__,
                    pos: pos__,
                    level_uuid: level_uuid__,
                    level_pos: level_pos__,
                    level_map_id: level_map_id__,
                    level_revive_id: level_revive_id__,
                    record_id: record_id__.unwrap_or_default(),
                    plane_id: plane_id__,
                    scene_layer: scene_layer__,
                    can_switch_layer: can_switch_layer__,
                    before_fall_pos: before_fall_pos__,
                    scene_guid: scene_guid__,
                    dungeon_guid: dungeon_guid__,
                    line_id: line_id__,
                    visual_layer_config_id: visual_layer_config_id__,
                    last_scene_data: last_scene_data__,
                    scene_area_id: scene_area_id__,
                    level_area_id: level_area_id__,
                    before_fall_scene_area_id: before_fall_scene_area_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SceneData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SceneInteractionInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.obj_id.is_some() {
            len += 1;
        }
        if self.pos_id.is_some() {
            len += 1;
        }
        if self.pos.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SceneInteractionInfo", len)?;
        if let Some(v) = self.obj_id.as_ref() {
            struct_ser.serialize_field("ObjId", v)?;
        }
        if let Some(v) = self.pos_id.as_ref() {
            struct_ser.serialize_field("PosId", v)?;
        }
        if let Some(v) = self.pos.as_ref() {
            struct_ser.serialize_field("Pos", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SceneInteractionInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ObjId",
            "PosId",
            "Pos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ObjId,
            PosId,
            Pos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ObjId" => Ok(GeneratedField::ObjId),
                            "PosId" => Ok(GeneratedField::PosId),
                            "Pos" => Ok(GeneratedField::Pos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SceneInteractionInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SceneInteractionInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SceneInteractionInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut obj_id__ = None;
                let mut pos_id__ = None;
                let mut pos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ObjId => {
                            if obj_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ObjId"));
                            }
                            obj_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PosId => {
                            if pos_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PosId"));
                            }
                            pos_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Pos => {
                            if pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Pos"));
                            }
                            pos__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SceneInteractionInfo {
                    obj_id: obj_id__,
                    pos_id: pos_id__,
                    pos: pos__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SceneInteractionInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SceneLineData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.line_id.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        if self.scene_guid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SceneLineData", len)?;
        if let Some(v) = self.line_id.as_ref() {
            struct_ser.serialize_field("LineId", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            let v = ESceneLineStatus::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Status", &v)?;
        }
        if let Some(v) = self.scene_guid.as_ref() {
            struct_ser.serialize_field("SceneGuid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SceneLineData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LineId",
            "Status",
            "SceneGuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LineId,
            Status,
            SceneGuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LineId" => Ok(GeneratedField::LineId),
                            "Status" => Ok(GeneratedField::Status),
                            "SceneGuid" => Ok(GeneratedField::SceneGuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SceneLineData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SceneLineData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SceneLineData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut line_id__ = None;
                let mut status__ = None;
                let mut scene_guid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LineId => {
                            if line_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LineId"));
                            }
                            line_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Status"));
                            }
                            status__ = map_.next_value::<::std::option::Option<ESceneLineStatus>>()?.map(|x| x as i32);
                        }
                        GeneratedField::SceneGuid => {
                            if scene_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneGuid"));
                            }
                            scene_guid__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SceneLineData {
                    line_id: line_id__,
                    status: status__,
                    scene_guid: scene_guid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SceneLineData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SceneLuaData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.scene_lua_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SceneLuaData", len)?;
        if !self.scene_lua_info.is_empty() {
            struct_ser.serialize_field("SceneLuaInfo", &self.scene_lua_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SceneLuaData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SceneLuaInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SceneLuaInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SceneLuaInfo" => Ok(GeneratedField::SceneLuaInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SceneLuaData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SceneLuaData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SceneLuaData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_lua_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SceneLuaInfo => {
                            if scene_lua_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneLuaInfo"));
                            }
                            scene_lua_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(SceneLuaData {
                    scene_lua_info: scene_lua_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SceneLuaData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ScenePersonalObject {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.personal_obj_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ScenePersonalObject", len)?;
        if !self.personal_obj_data.is_empty() {
            struct_ser.serialize_field("PersonalObjData", &self.personal_obj_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ScenePersonalObject {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PersonalObjData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PersonalObjData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PersonalObjData" => Ok(GeneratedField::PersonalObjData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ScenePersonalObject;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ScenePersonalObject")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ScenePersonalObject, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut personal_obj_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PersonalObjData => {
                            if personal_obj_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PersonalObjData"));
                            }
                            personal_obj_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ScenePersonalObject {
                    personal_obj_data: personal_obj_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ScenePersonalObject", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ScenePointInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.position.is_some() {
            len += 1;
        }
        if self.camera_id.is_some() {
            len += 1;
        }
        if self.scene_area_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ScenePointInfo", len)?;
        if let Some(v) = self.position.as_ref() {
            struct_ser.serialize_field("Position", v)?;
        }
        if let Some(v) = self.camera_id.as_ref() {
            struct_ser.serialize_field("CameraId", v)?;
        }
        if let Some(v) = self.scene_area_id.as_ref() {
            struct_ser.serialize_field("SceneAreaId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ScenePointInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Position",
            "CameraId",
            "SceneAreaId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Position,
            CameraId,
            SceneAreaId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Position" => Ok(GeneratedField::Position),
                            "CameraId" => Ok(GeneratedField::CameraId),
                            "SceneAreaId" => Ok(GeneratedField::SceneAreaId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ScenePointInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ScenePointInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ScenePointInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut position__ = None;
                let mut camera_id__ = None;
                let mut scene_area_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Position => {
                            if position__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Position"));
                            }
                            position__ = map_.next_value()?;
                        }
                        GeneratedField::CameraId => {
                            if camera_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CameraId"));
                            }
                            camera_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SceneAreaId => {
                            if scene_area_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneAreaId"));
                            }
                            scene_area_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ScenePointInfo {
                    position: position__,
                    camera_id: camera_id__,
                    scene_area_id: scene_area_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ScenePointInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ScenePosIdInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scene_pos_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ScenePosIdInfo", len)?;
        if let Some(v) = self.scene_pos_id.as_ref() {
            struct_ser.serialize_field("ScenePosId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ScenePosIdInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ScenePosId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ScenePosId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ScenePosId" => Ok(GeneratedField::ScenePosId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ScenePosIdInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ScenePosIdInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ScenePosIdInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_pos_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ScenePosId => {
                            if scene_pos_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ScenePosId"));
                            }
                            scene_pos_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ScenePosIdInfo {
                    scene_pos_id: scene_pos_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ScenePosIdInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SceneRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cnt.is_some() {
            len += 1;
        }
        if !self.group_cnts.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SceneRecord", len)?;
        if let Some(v) = self.cnt.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Cnt", ToString::to_string(&v).as_str())?;
        }
        if !self.group_cnts.is_empty() {
            let v: std::collections::HashMap<_, _> = self.group_cnts.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("GroupCnts", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SceneRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Cnt",
            "GroupCnts",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Cnt,
            GroupCnts,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Cnt" => Ok(GeneratedField::Cnt),
                            "GroupCnts" => Ok(GeneratedField::GroupCnts),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SceneRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SceneRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SceneRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cnt__ = None;
                let mut group_cnts__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Cnt => {
                            if cnt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Cnt"));
                            }
                            cnt__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GroupCnts => {
                            if group_cnts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GroupCnts"));
                            }
                            group_cnts__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<u64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(SceneRecord {
                    cnt: cnt__,
                    group_cnts: group_cnts__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SceneRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonAchievement {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.season_achievement.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonAchievement", len)?;
        if !self.season_achievement.is_empty() {
            struct_ser.serialize_field("SeasonAchievement", &self.season_achievement)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonAchievement {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SeasonAchievement_",
            "SeasonAchievement",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SeasonAchievement,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SeasonAchievement" | "SeasonAchievement_" => Ok(GeneratedField::SeasonAchievement),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonAchievement;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonAchievement")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonAchievement, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut season_achievement__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SeasonAchievement => {
                            if season_achievement__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonAchievement"));
                            }
                            season_achievement__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(SeasonAchievement {
                    season_achievement: season_achievement__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonAchievement", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonAchievementList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.season_achievement_list.is_empty() {
            len += 1;
        }
        if !self.has_init_dones.is_empty() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonAchievementList", len)?;
        if !self.season_achievement_list.is_empty() {
            struct_ser.serialize_field("SeasonAchievementList", &self.season_achievement_list)?;
        }
        if !self.has_init_dones.is_empty() {
            struct_ser.serialize_field("HasInitDones", &self.has_init_dones)?;
        }
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Version", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonAchievementList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SeasonAchievementList_",
            "SeasonAchievementList",
            "HasInitDones",
            "Version",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SeasonAchievementList,
            HasInitDones,
            Version,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SeasonAchievementList" | "SeasonAchievementList_" => Ok(GeneratedField::SeasonAchievementList),
                            "HasInitDones" => Ok(GeneratedField::HasInitDones),
                            "Version" => Ok(GeneratedField::Version),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonAchievementList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonAchievementList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonAchievementList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut season_achievement_list__ = None;
                let mut has_init_dones__ = None;
                let mut version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SeasonAchievementList => {
                            if season_achievement_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonAchievementList"));
                            }
                            season_achievement_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::HasInitDones => {
                            if has_init_dones__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HasInitDones"));
                            }
                            has_init_dones__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SeasonAchievementList {
                    season_achievement_list: season_achievement_list__.unwrap_or_default(),
                    has_init_dones: has_init_dones__.unwrap_or_default(),
                    version: version__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonAchievementList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonActivation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.season_id.is_some() {
            len += 1;
        }
        if self.activation_point.is_some() {
            len += 1;
        }
        if self.refresh_time.is_some() {
            len += 1;
        }
        if !self.activation_targets.is_empty() {
            len += 1;
        }
        if !self.stage_reward_status.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonActivation", len)?;
        if let Some(v) = self.season_id.as_ref() {
            struct_ser.serialize_field("SeasonId", v)?;
        }
        if let Some(v) = self.activation_point.as_ref() {
            struct_ser.serialize_field("ActivationPoint", v)?;
        }
        if let Some(v) = self.refresh_time.as_ref() {
            struct_ser.serialize_field("RefreshTime", v)?;
        }
        if !self.activation_targets.is_empty() {
            struct_ser.serialize_field("ActivationTargets", &self.activation_targets)?;
        }
        if !self.stage_reward_status.is_empty() {
            struct_ser.serialize_field("StageRewardStatus", &self.stage_reward_status)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonActivation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SeasonId",
            "ActivationPoint",
            "RefreshTime",
            "ActivationTargets",
            "StageRewardStatus",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SeasonId,
            ActivationPoint,
            RefreshTime,
            ActivationTargets,
            StageRewardStatus,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SeasonId" => Ok(GeneratedField::SeasonId),
                            "ActivationPoint" => Ok(GeneratedField::ActivationPoint),
                            "RefreshTime" => Ok(GeneratedField::RefreshTime),
                            "ActivationTargets" => Ok(GeneratedField::ActivationTargets),
                            "StageRewardStatus" => Ok(GeneratedField::StageRewardStatus),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonActivation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonActivation")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonActivation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut season_id__ = None;
                let mut activation_point__ = None;
                let mut refresh_time__ = None;
                let mut activation_targets__ = None;
                let mut stage_reward_status__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SeasonId => {
                            if season_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonId"));
                            }
                            season_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ActivationPoint => {
                            if activation_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActivationPoint"));
                            }
                            activation_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RefreshTime => {
                            if refresh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshTime"));
                            }
                            refresh_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ActivationTargets => {
                            if activation_targets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActivationTargets"));
                            }
                            activation_targets__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::StageRewardStatus => {
                            if stage_reward_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StageRewardStatus"));
                            }
                            stage_reward_status__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(SeasonActivation {
                    season_id: season_id__,
                    activation_point: activation_point__,
                    refresh_time: refresh_time__,
                    activation_targets: activation_targets__.unwrap_or_default(),
                    stage_reward_status: stage_reward_status__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonActivation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonActivationTarget {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.target_type.is_some() {
            len += 1;
        }
        if self.target_uuid.is_some() {
            len += 1;
        }
        if self.reward_rate.is_some() {
            len += 1;
        }
        if self.progress.is_some() {
            len += 1;
        }
        if self.completed_times.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonActivationTarget", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.target_type.as_ref() {
            struct_ser.serialize_field("TargetType", v)?;
        }
        if let Some(v) = self.target_uuid.as_ref() {
            struct_ser.serialize_field("TargetUuid", v)?;
        }
        if let Some(v) = self.reward_rate.as_ref() {
            struct_ser.serialize_field("RewardRate", v)?;
        }
        if let Some(v) = self.progress.as_ref() {
            struct_ser.serialize_field("Progress", v)?;
        }
        if let Some(v) = self.completed_times.as_ref() {
            struct_ser.serialize_field("CompletedTimes", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonActivationTarget {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "TargetType",
            "TargetUuid",
            "RewardRate",
            "Progress",
            "CompletedTimes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            TargetType,
            TargetUuid,
            RewardRate,
            Progress,
            CompletedTimes,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "TargetType" => Ok(GeneratedField::TargetType),
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            "RewardRate" => Ok(GeneratedField::RewardRate),
                            "Progress" => Ok(GeneratedField::Progress),
                            "CompletedTimes" => Ok(GeneratedField::CompletedTimes),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonActivationTarget;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonActivationTarget")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonActivationTarget, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut target_type__ = None;
                let mut target_uuid__ = None;
                let mut reward_rate__ = None;
                let mut progress__ = None;
                let mut completed_times__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetType => {
                            if target_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetType"));
                            }
                            target_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RewardRate => {
                            if reward_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RewardRate"));
                            }
                            reward_rate__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Progress => {
                            if progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Progress"));
                            }
                            progress__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CompletedTimes => {
                            if completed_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CompletedTimes"));
                            }
                            completed_times__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SeasonActivationTarget {
                    id: id__,
                    target_type: target_type__,
                    target_uuid: target_uuid__,
                    reward_rate: reward_rate__,
                    progress: progress__,
                    completed_times: completed_times__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonActivationTarget", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonBpQuestData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.target_num.is_some() {
            len += 1;
        }
        if self.award.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonBpQuestData", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.target_num.as_ref() {
            struct_ser.serialize_field("TargetNum", v)?;
        }
        if let Some(v) = self.award.as_ref() {
            struct_ser.serialize_field("Award", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonBpQuestData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "TargetNum",
            "Award",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            TargetNum,
            Award,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "TargetNum" => Ok(GeneratedField::TargetNum),
                            "Award" => Ok(GeneratedField::Award),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonBpQuestData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonBpQuestData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonBpQuestData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut target_num__ = None;
                let mut award__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetNum => {
                            if target_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetNum"));
                            }
                            target_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Award => {
                            if award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Award"));
                            }
                            award__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SeasonBpQuestData {
                    id: id__,
                    target_num: target_num__,
                    award: award__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonBpQuestData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonBpQuestList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.season_map.is_empty() {
            len += 1;
        }
        if !self.random_map.is_empty() {
            len += 1;
        }
        if self.refresh_time_stamp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonBpQuestList", len)?;
        if !self.season_map.is_empty() {
            struct_ser.serialize_field("SeasonMap", &self.season_map)?;
        }
        if !self.random_map.is_empty() {
            struct_ser.serialize_field("RandomMap", &self.random_map)?;
        }
        if let Some(v) = self.refresh_time_stamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RefreshTimeStamp", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonBpQuestList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SeasonMap",
            "RandomMap",
            "RefreshTimeStamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SeasonMap,
            RandomMap,
            RefreshTimeStamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SeasonMap" => Ok(GeneratedField::SeasonMap),
                            "RandomMap" => Ok(GeneratedField::RandomMap),
                            "RefreshTimeStamp" => Ok(GeneratedField::RefreshTimeStamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonBpQuestList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonBpQuestList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonBpQuestList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut season_map__ = None;
                let mut random_map__ = None;
                let mut refresh_time_stamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SeasonMap => {
                            if season_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonMap"));
                            }
                            season_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::RandomMap => {
                            if random_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RandomMap"));
                            }
                            random_map__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::RefreshTimeStamp => {
                            if refresh_time_stamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshTimeStamp"));
                            }
                            refresh_time_stamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SeasonBpQuestList {
                    season_map: season_map__.unwrap_or_default(),
                    random_map: random_map__.unwrap_or_default(),
                    refresh_time_stamp: refresh_time_stamp__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonBpQuestList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonCenter {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.season_id.is_some() {
            len += 1;
        }
        if self.battle_pass.is_some() {
            len += 1;
        }
        if self.bp_quest_list.is_some() {
            len += 1;
        }
        if !self.season_history.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonCenter", len)?;
        if let Some(v) = self.season_id.as_ref() {
            struct_ser.serialize_field("SeasonId", v)?;
        }
        if let Some(v) = self.battle_pass.as_ref() {
            struct_ser.serialize_field("BattlePass", v)?;
        }
        if let Some(v) = self.bp_quest_list.as_ref() {
            struct_ser.serialize_field("BpQuestList", v)?;
        }
        if !self.season_history.is_empty() {
            struct_ser.serialize_field("SeasonHistory", &self.season_history)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonCenter {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SeasonId",
            "BattlePass",
            "BpQuestList",
            "SeasonHistory",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SeasonId,
            BattlePass,
            BpQuestList,
            SeasonHistory,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SeasonId" => Ok(GeneratedField::SeasonId),
                            "BattlePass" => Ok(GeneratedField::BattlePass),
                            "BpQuestList" => Ok(GeneratedField::BpQuestList),
                            "SeasonHistory" => Ok(GeneratedField::SeasonHistory),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonCenter;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonCenter")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonCenter, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut season_id__ = None;
                let mut battle_pass__ = None;
                let mut bp_quest_list__ = None;
                let mut season_history__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SeasonId => {
                            if season_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonId"));
                            }
                            season_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BattlePass => {
                            if battle_pass__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BattlePass"));
                            }
                            battle_pass__ = map_.next_value()?;
                        }
                        GeneratedField::BpQuestList => {
                            if bp_quest_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BpQuestList"));
                            }
                            bp_quest_list__ = map_.next_value()?;
                        }
                        GeneratedField::SeasonHistory => {
                            if season_history__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonHistory"));
                            }
                            season_history__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(SeasonCenter {
                    season_id: season_id__,
                    battle_pass: battle_pass__,
                    bp_quest_list: bp_quest_list__,
                    season_history: season_history__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonCenter", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonCenterHistory {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.battle_pass.is_some() {
            len += 1;
        }
        if self.bp_quest_list.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonCenterHistory", len)?;
        if let Some(v) = self.battle_pass.as_ref() {
            struct_ser.serialize_field("BattlePass", v)?;
        }
        if let Some(v) = self.bp_quest_list.as_ref() {
            struct_ser.serialize_field("BpQuestList", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonCenterHistory {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BattlePass",
            "BpQuestList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BattlePass,
            BpQuestList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BattlePass" => Ok(GeneratedField::BattlePass),
                            "BpQuestList" => Ok(GeneratedField::BpQuestList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonCenterHistory;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonCenterHistory")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonCenterHistory, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut battle_pass__ = None;
                let mut bp_quest_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BattlePass => {
                            if battle_pass__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BattlePass"));
                            }
                            battle_pass__ = map_.next_value()?;
                        }
                        GeneratedField::BpQuestList => {
                            if bp_quest_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BpQuestList"));
                            }
                            bp_quest_list__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SeasonCenterHistory {
                    battle_pass: battle_pass__,
                    bp_quest_list: bp_quest_list__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonCenterHistory", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonMasterModeDungeonInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.master_mode_diff_info.is_empty() {
            len += 1;
        }
        if self.dungeon_info_update_time.is_some() {
            len += 1;
        }
        if !self.season_awards.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonMasterModeDungeonInfo", len)?;
        if !self.master_mode_diff_info.is_empty() {
            struct_ser.serialize_field("MasterModeDiffInfo", &self.master_mode_diff_info)?;
        }
        if let Some(v) = self.dungeon_info_update_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("DungeonInfoUpdateTime", ToString::to_string(&v).as_str())?;
        }
        if !self.season_awards.is_empty() {
            struct_ser.serialize_field("SeasonAwards", &self.season_awards)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonMasterModeDungeonInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MasterModeDiffInfo",
            "DungeonInfoUpdateTime",
            "SeasonAwards",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MasterModeDiffInfo,
            DungeonInfoUpdateTime,
            SeasonAwards,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MasterModeDiffInfo" => Ok(GeneratedField::MasterModeDiffInfo),
                            "DungeonInfoUpdateTime" => Ok(GeneratedField::DungeonInfoUpdateTime),
                            "SeasonAwards" => Ok(GeneratedField::SeasonAwards),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonMasterModeDungeonInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonMasterModeDungeonInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonMasterModeDungeonInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut master_mode_diff_info__ = None;
                let mut dungeon_info_update_time__ = None;
                let mut season_awards__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MasterModeDiffInfo => {
                            if master_mode_diff_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MasterModeDiffInfo"));
                            }
                            master_mode_diff_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::DungeonInfoUpdateTime => {
                            if dungeon_info_update_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DungeonInfoUpdateTime"));
                            }
                            dungeon_info_update_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SeasonAwards => {
                            if season_awards__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonAwards"));
                            }
                            season_awards__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(SeasonMasterModeDungeonInfo {
                    master_mode_diff_info: master_mode_diff_info__.unwrap_or_default(),
                    dungeon_info_update_time: dungeon_info_update_time__,
                    season_awards: season_awards__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonMasterModeDungeonInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonMedalInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.season_id.is_some() {
            len += 1;
        }
        if !self.normal_hole_infos.is_empty() {
            len += 1;
        }
        if self.core_hole_info.is_some() {
            len += 1;
        }
        if !self.core_hole_node_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonMedalInfo", len)?;
        if let Some(v) = self.season_id.as_ref() {
            struct_ser.serialize_field("SeasonId", v)?;
        }
        if !self.normal_hole_infos.is_empty() {
            struct_ser.serialize_field("NormalHoleInfos", &self.normal_hole_infos)?;
        }
        if let Some(v) = self.core_hole_info.as_ref() {
            struct_ser.serialize_field("CoreHoleInfo", v)?;
        }
        if !self.core_hole_node_infos.is_empty() {
            struct_ser.serialize_field("CoreHoleNodeInfos", &self.core_hole_node_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonMedalInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SeasonId",
            "NormalHoleInfos",
            "CoreHoleInfo",
            "CoreHoleNodeInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SeasonId,
            NormalHoleInfos,
            CoreHoleInfo,
            CoreHoleNodeInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SeasonId" => Ok(GeneratedField::SeasonId),
                            "NormalHoleInfos" => Ok(GeneratedField::NormalHoleInfos),
                            "CoreHoleInfo" => Ok(GeneratedField::CoreHoleInfo),
                            "CoreHoleNodeInfos" => Ok(GeneratedField::CoreHoleNodeInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonMedalInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonMedalInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonMedalInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut season_id__ = None;
                let mut normal_hole_infos__ = None;
                let mut core_hole_info__ = None;
                let mut core_hole_node_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SeasonId => {
                            if season_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonId"));
                            }
                            season_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NormalHoleInfos => {
                            if normal_hole_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NormalHoleInfos"));
                            }
                            normal_hole_infos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::CoreHoleInfo => {
                            if core_hole_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CoreHoleInfo"));
                            }
                            core_hole_info__ = map_.next_value()?;
                        }
                        GeneratedField::CoreHoleNodeInfos => {
                            if core_hole_node_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CoreHoleNodeInfos"));
                            }
                            core_hole_node_infos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(SeasonMedalInfo {
                    season_id: season_id__,
                    normal_hole_infos: normal_hole_infos__.unwrap_or_default(),
                    core_hole_info: core_hole_info__,
                    core_hole_node_infos: core_hole_node_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonMedalInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonQuestData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.target_num.is_some() {
            len += 1;
        }
        if self.award.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonQuestData", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.target_num.as_ref() {
            struct_ser.serialize_field("TargetNum", v)?;
        }
        if let Some(v) = self.award.as_ref() {
            struct_ser.serialize_field("Award", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonQuestData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "TargetNum",
            "Award",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            TargetNum,
            Award,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "TargetNum" => Ok(GeneratedField::TargetNum),
                            "Award" => Ok(GeneratedField::Award),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonQuestData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonQuestData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonQuestData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut target_num__ = None;
                let mut award__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetNum => {
                            if target_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetNum"));
                            }
                            target_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Award => {
                            if award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Award"));
                            }
                            award__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SeasonQuestData {
                    id: id__,
                    target_num: target_num__,
                    award: award__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonQuestData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonQuestList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.season_map.is_empty() {
            len += 1;
        }
        if self.refresh_week.is_some() {
            len += 1;
        }
        if self.refresh_time_stamp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonQuestList", len)?;
        if !self.season_map.is_empty() {
            struct_ser.serialize_field("SeasonMap", &self.season_map)?;
        }
        if let Some(v) = self.refresh_week.as_ref() {
            struct_ser.serialize_field("RefreshWeek", v)?;
        }
        if let Some(v) = self.refresh_time_stamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RefreshTimeStamp", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonQuestList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SeasonMap",
            "RefreshWeek",
            "RefreshTimeStamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SeasonMap,
            RefreshWeek,
            RefreshTimeStamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SeasonMap" => Ok(GeneratedField::SeasonMap),
                            "RefreshWeek" => Ok(GeneratedField::RefreshWeek),
                            "RefreshTimeStamp" => Ok(GeneratedField::RefreshTimeStamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonQuestList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonQuestList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonQuestList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut season_map__ = None;
                let mut refresh_week__ = None;
                let mut refresh_time_stamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SeasonMap => {
                            if season_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonMap"));
                            }
                            season_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::RefreshWeek => {
                            if refresh_week__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshWeek"));
                            }
                            refresh_week__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RefreshTimeStamp => {
                            if refresh_time_stamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshTimeStamp"));
                            }
                            refresh_time_stamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SeasonQuestList {
                    season_map: season_map__.unwrap_or_default(),
                    refresh_week: refresh_week__,
                    refresh_time_stamp: refresh_time_stamp__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonQuestList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonRankData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.season_ranks.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonRankData", len)?;
        if !self.season_ranks.is_empty() {
            struct_ser.serialize_field("SeasonRanks", &self.season_ranks)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonRankData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SeasonRanks",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SeasonRanks,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SeasonRanks" => Ok(GeneratedField::SeasonRanks),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonRankData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonRankData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonRankData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut season_ranks__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SeasonRanks => {
                            if season_ranks__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonRanks"));
                            }
                            season_ranks__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, ::pbjson::private::NumberDeserialize<u32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(SeasonRankData {
                    season_ranks: season_ranks__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonRankData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonRankInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cur_ran_k_star.is_some() {
            len += 1;
        }
        if !self.received_rank_star.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonRankInfo", len)?;
        if let Some(v) = self.cur_ran_k_star.as_ref() {
            struct_ser.serialize_field("CurRanKStar", v)?;
        }
        if !self.received_rank_star.is_empty() {
            struct_ser.serialize_field("ReceivedRankStar", &self.received_rank_star)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonRankInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CurRanKStar",
            "ReceivedRankStar",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CurRanKStar,
            ReceivedRankStar,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CurRanKStar" => Ok(GeneratedField::CurRanKStar),
                            "ReceivedRankStar" => Ok(GeneratedField::ReceivedRankStar),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonRankInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonRankInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonRankInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cur_ran_k_star__ = None;
                let mut received_rank_star__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CurRanKStar => {
                            if cur_ran_k_star__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurRanKStar"));
                            }
                            cur_ran_k_star__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReceivedRankStar => {
                            if received_rank_star__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReceivedRankStar"));
                            }
                            received_rank_star__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(SeasonRankInfo {
                    cur_ran_k_star: cur_ran_k_star__,
                    received_rank_star: received_rank_star__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonRankInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonRankList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.season_rank_list.is_empty() {
            len += 1;
        }
        if self.show_armband_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonRankList", len)?;
        if !self.season_rank_list.is_empty() {
            struct_ser.serialize_field("SeasonRankList", &self.season_rank_list)?;
        }
        if let Some(v) = self.show_armband_id.as_ref() {
            struct_ser.serialize_field("ShowArmbandId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonRankList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SeasonRankList_",
            "SeasonRankList",
            "ShowArmbandId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SeasonRankList,
            ShowArmbandId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SeasonRankList" | "SeasonRankList_" => Ok(GeneratedField::SeasonRankList),
                            "ShowArmbandId" => Ok(GeneratedField::ShowArmbandId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonRankList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonRankList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonRankList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut season_rank_list__ = None;
                let mut show_armband_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SeasonRankList => {
                            if season_rank_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonRankList"));
                            }
                            season_rank_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::ShowArmbandId => {
                            if show_armband_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShowArmbandId"));
                            }
                            show_armband_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SeasonRankList {
                    season_rank_list: season_rank_list__.unwrap_or_default(),
                    show_armband_id: show_armband_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonRankList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonTarget {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.target_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonTarget", len)?;
        if !self.target_info.is_empty() {
            struct_ser.serialize_field("TargetInfo", &self.target_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonTarget {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetInfo" => Ok(GeneratedField::TargetInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonTarget;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonTarget")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonTarget, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetInfo => {
                            if target_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetInfo"));
                            }
                            target_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(SeasonTarget {
                    target_info: target_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonTarget", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeasonTargetInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target_id.is_some() {
            len += 1;
        }
        if self.target_progress.is_some() {
            len += 1;
        }
        if self.award_state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeasonTargetInfo", len)?;
        if let Some(v) = self.target_id.as_ref() {
            struct_ser.serialize_field("TargetId", v)?;
        }
        if let Some(v) = self.target_progress.as_ref() {
            struct_ser.serialize_field("TargetProgress", v)?;
        }
        if let Some(v) = self.award_state.as_ref() {
            struct_ser.serialize_field("AwardState", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeasonTargetInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetId",
            "TargetProgress",
            "AwardState",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetId,
            TargetProgress,
            AwardState,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetId" => Ok(GeneratedField::TargetId),
                            "TargetProgress" => Ok(GeneratedField::TargetProgress),
                            "AwardState" => Ok(GeneratedField::AwardState),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeasonTargetInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeasonTargetInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeasonTargetInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_id__ = None;
                let mut target_progress__ = None;
                let mut award_state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetId => {
                            if target_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetId"));
                            }
                            target_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetProgress => {
                            if target_progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetProgress"));
                            }
                            target_progress__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AwardState => {
                            if award_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardState"));
                            }
                            award_state__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SeasonTargetInfo {
                    target_id: target_id__,
                    target_progress: target_progress__,
                    award_state: award_state__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeasonTargetInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeqPassiveSkillEndInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.actor_uuid.is_some() {
            len += 1;
        }
        if !self.uuids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeqPassiveSkillEndInfo", len)?;
        if let Some(v) = self.actor_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ActorUuid", ToString::to_string(&v).as_str())?;
        }
        if !self.uuids.is_empty() {
            struct_ser.serialize_field("Uuids", &self.uuids.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeqPassiveSkillEndInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ActorUuid",
            "Uuids",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ActorUuid,
            Uuids,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ActorUuid" => Ok(GeneratedField::ActorUuid),
                            "Uuids" => Ok(GeneratedField::Uuids),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeqPassiveSkillEndInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeqPassiveSkillEndInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeqPassiveSkillEndInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut actor_uuid__ = None;
                let mut uuids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ActorUuid => {
                            if actor_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActorUuid"));
                            }
                            actor_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Uuids => {
                            if uuids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuids"));
                            }
                            uuids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(SeqPassiveSkillEndInfo {
                    actor_uuid: actor_uuid__,
                    uuids: uuids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeqPassiveSkillEndInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SeqPassiveSkillInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.actor_uuid.is_some() {
            len += 1;
        }
        if !self.passive_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SeqPassiveSkillInfo", len)?;
        if let Some(v) = self.actor_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ActorUuid", ToString::to_string(&v).as_str())?;
        }
        if !self.passive_infos.is_empty() {
            struct_ser.serialize_field("PassiveInfos", &self.passive_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SeqPassiveSkillInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ActorUuid",
            "PassiveInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ActorUuid,
            PassiveInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ActorUuid" => Ok(GeneratedField::ActorUuid),
                            "PassiveInfos" => Ok(GeneratedField::PassiveInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SeqPassiveSkillInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SeqPassiveSkillInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SeqPassiveSkillInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut actor_uuid__ = None;
                let mut passive_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ActorUuid => {
                            if actor_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActorUuid"));
                            }
                            actor_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PassiveInfos => {
                            if passive_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PassiveInfos"));
                            }
                            passive_infos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SeqPassiveSkillInfo {
                    actor_uuid: actor_uuid__,
                    passive_infos: passive_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SeqPassiveSkillInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServerData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.open_server_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ServerData", len)?;
        if let Some(v) = self.open_server_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("OpenServerTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServerData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OpenServerTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OpenServerTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "OpenServerTime" => Ok(GeneratedField::OpenServerTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServerData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ServerData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ServerData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut open_server_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OpenServerTime => {
                            if open_server_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OpenServerTime"));
                            }
                            open_server_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ServerData {
                    open_server_time: open_server_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ServerData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServerSkillStageEnd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_uuid.is_some() {
            len += 1;
        }
        if self.stage_id.is_some() {
            len += 1;
        }
        if self.new_stage_id.is_some() {
            len += 1;
        }
        if self.condition_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ServerSkillStageEnd", len)?;
        if let Some(v) = self.skill_uuid.as_ref() {
            struct_ser.serialize_field("SkillUuid", v)?;
        }
        if let Some(v) = self.stage_id.as_ref() {
            struct_ser.serialize_field("StageId", v)?;
        }
        if let Some(v) = self.new_stage_id.as_ref() {
            struct_ser.serialize_field("NewStageId", v)?;
        }
        if let Some(v) = self.condition_id.as_ref() {
            struct_ser.serialize_field("ConditionId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServerSkillStageEnd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillUuid",
            "StageId",
            "NewStageId",
            "ConditionId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillUuid,
            StageId,
            NewStageId,
            ConditionId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillUuid" => Ok(GeneratedField::SkillUuid),
                            "StageId" => Ok(GeneratedField::StageId),
                            "NewStageId" => Ok(GeneratedField::NewStageId),
                            "ConditionId" => Ok(GeneratedField::ConditionId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServerSkillStageEnd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ServerSkillStageEnd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ServerSkillStageEnd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_uuid__ = None;
                let mut stage_id__ = None;
                let mut new_stage_id__ = None;
                let mut condition_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillUuid => {
                            if skill_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillUuid"));
                            }
                            skill_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StageId => {
                            if stage_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StageId"));
                            }
                            stage_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NewStageId => {
                            if new_stage_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NewStageId"));
                            }
                            new_stage_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ConditionId => {
                            if condition_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConditionId"));
                            }
                            condition_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ServerSkillStageEnd {
                    skill_uuid: skill_uuid__,
                    stage_id: stage_id__,
                    new_stage_id: new_stage_id__,
                    condition_id: condition_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ServerSkillStageEnd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServerStateObjectInteractionList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.personal_obj_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ServerStateObjectInteractionList", len)?;
        if !self.personal_obj_list.is_empty() {
            struct_ser.serialize_field("PersonalObjList", &self.personal_obj_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServerStateObjectInteractionList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PersonalObjList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PersonalObjList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PersonalObjList" => Ok(GeneratedField::PersonalObjList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServerStateObjectInteractionList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ServerStateObjectInteractionList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ServerStateObjectInteractionList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut personal_obj_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PersonalObjList => {
                            if personal_obj_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PersonalObjList"));
                            }
                            personal_obj_list__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ServerStateObjectInteractionList {
                    personal_obj_list: personal_obj_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ServerStateObjectInteractionList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServerStateObjectInteractionParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.obj_uuid.is_some() {
            len += 1;
        }
        if self.state_value.is_some() {
            len += 1;
        }
        if self.last_interaction_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ServerStateObjectInteractionParam", len)?;
        if let Some(v) = self.obj_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ObjUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.state_value.as_ref() {
            struct_ser.serialize_field("StateValue", v)?;
        }
        if let Some(v) = self.last_interaction_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastInteractionTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServerStateObjectInteractionParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ObjUuid",
            "StateValue",
            "LastInteractionTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ObjUuid,
            StateValue,
            LastInteractionTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ObjUuid" => Ok(GeneratedField::ObjUuid),
                            "StateValue" => Ok(GeneratedField::StateValue),
                            "LastInteractionTime" => Ok(GeneratedField::LastInteractionTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServerStateObjectInteractionParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ServerStateObjectInteractionParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ServerStateObjectInteractionParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut obj_uuid__ = None;
                let mut state_value__ = None;
                let mut last_interaction_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ObjUuid => {
                            if obj_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ObjUuid"));
                            }
                            obj_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StateValue => {
                            if state_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StateValue"));
                            }
                            state_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastInteractionTime => {
                            if last_interaction_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastInteractionTime"));
                            }
                            last_interaction_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ServerStateObjectInteractionParam {
                    obj_uuid: obj_uuid__,
                    state_value: state_value__,
                    last_interaction_time: last_interaction_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ServerStateObjectInteractionParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ServerStateObjectUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_object.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ServerStateObjectUpdate", len)?;
        if let Some(v) = self.v_object.as_ref() {
            struct_ser.serialize_field("VObject", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ServerStateObjectUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VObject",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VObject,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VObject" => Ok(GeneratedField::VObject),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ServerStateObjectUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ServerStateObjectUpdate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ServerStateObjectUpdate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_object__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VObject => {
                            if v_object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VObject"));
                            }
                            v_object__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ServerStateObjectUpdate {
                    v_object: v_object__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ServerStateObjectUpdate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SetAiming {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_aiming.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SetAiming", len)?;
        if let Some(v) = self.is_aiming.as_ref() {
            struct_ser.serialize_field("IsAiming", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SetAiming {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsAiming",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsAiming,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsAiming" => Ok(GeneratedField::IsAiming),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetAiming;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SetAiming")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SetAiming, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_aiming__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsAiming => {
                            if is_aiming__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsAiming"));
                            }
                            is_aiming__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SetAiming {
                    is_aiming: is_aiming__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SetAiming", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SetAoiSyncUserCount {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_count.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SetAoiSyncUserCount", len)?;
        if let Some(v) = self.v_count.as_ref() {
            struct_ser.serialize_field("VCount", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SetAoiSyncUserCount {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VCount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VCount,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VCount" => Ok(GeneratedField::VCount),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetAoiSyncUserCount;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SetAoiSyncUserCount")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SetAoiSyncUserCount, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_count__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VCount => {
                            if v_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VCount"));
                            }
                            v_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SetAoiSyncUserCount {
                    v_count: v_count__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SetAoiSyncUserCount", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SetInteractionPartnerPos {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_cur_pos.is_some() {
            len += 1;
        }
        if self.v_dest_pos.is_some() {
            len += 1;
        }
        if self.v_move_type.is_some() {
            len += 1;
        }
        if self.v_time_stamp.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SetInteractionPartnerPos", len)?;
        if let Some(v) = self.v_cur_pos.as_ref() {
            struct_ser.serialize_field("VCurPos", v)?;
        }
        if let Some(v) = self.v_dest_pos.as_ref() {
            struct_ser.serialize_field("VDestPos", v)?;
        }
        if let Some(v) = self.v_move_type.as_ref() {
            let v = EMoveType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("VMoveType", &v)?;
        }
        if let Some(v) = self.v_time_stamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("VTimeStamp", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SetInteractionPartnerPos {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VCurPos",
            "VDestPos",
            "VMoveType",
            "VTimeStamp",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VCurPos,
            VDestPos,
            VMoveType,
            VTimeStamp,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VCurPos" => Ok(GeneratedField::VCurPos),
                            "VDestPos" => Ok(GeneratedField::VDestPos),
                            "VMoveType" => Ok(GeneratedField::VMoveType),
                            "VTimeStamp" => Ok(GeneratedField::VTimeStamp),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetInteractionPartnerPos;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SetInteractionPartnerPos")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SetInteractionPartnerPos, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_cur_pos__ = None;
                let mut v_dest_pos__ = None;
                let mut v_move_type__ = None;
                let mut v_time_stamp__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VCurPos => {
                            if v_cur_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VCurPos"));
                            }
                            v_cur_pos__ = map_.next_value()?;
                        }
                        GeneratedField::VDestPos => {
                            if v_dest_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VDestPos"));
                            }
                            v_dest_pos__ = map_.next_value()?;
                        }
                        GeneratedField::VMoveType => {
                            if v_move_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VMoveType"));
                            }
                            v_move_type__ = map_.next_value::<::std::option::Option<EMoveType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::VTimeStamp => {
                            if v_time_stamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VTimeStamp"));
                            }
                            v_time_stamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SetInteractionPartnerPos {
                    v_cur_pos: v_cur_pos__,
                    v_dest_pos: v_dest_pos__,
                    v_move_type: v_move_type__,
                    v_time_stamp: v_time_stamp__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SetInteractionPartnerPos", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SetPersonalState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_personal_state.is_some() {
            len += 1;
        }
        if self.v_is_remove.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SetPersonalState", len)?;
        if let Some(v) = self.v_personal_state.as_ref() {
            struct_ser.serialize_field("VPersonalState", v)?;
        }
        if let Some(v) = self.v_is_remove.as_ref() {
            struct_ser.serialize_field("VIsRemove", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SetPersonalState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VPersonalState",
            "VIsRemove",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VPersonalState,
            VIsRemove,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VPersonalState" => Ok(GeneratedField::VPersonalState),
                            "VIsRemove" => Ok(GeneratedField::VIsRemove),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetPersonalState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SetPersonalState")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SetPersonalState, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_personal_state__ = None;
                let mut v_is_remove__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VPersonalState => {
                            if v_personal_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VPersonalState"));
                            }
                            v_personal_state__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VIsRemove => {
                            if v_is_remove__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VIsRemove"));
                            }
                            v_is_remove__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SetPersonalState {
                    v_personal_state: v_personal_state__,
                    v_is_remove: v_is_remove__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SetPersonalState", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SetSlotAutoBattle {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SetSlotAutoBattle", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SetSlotAutoBattle {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetSlotAutoBattle;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SetSlotAutoBattle")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SetSlotAutoBattle, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SetSlotAutoBattle {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SetSlotAutoBattle", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SetSlotAutoBattleRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.slots.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SetSlotAutoBattleRequest", len)?;
        if !self.slots.is_empty() {
            struct_ser.serialize_field("Slots", &self.slots)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SetSlotAutoBattleRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Slots",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Slots,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Slots" => Ok(GeneratedField::Slots),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetSlotAutoBattleRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SetSlotAutoBattleRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SetSlotAutoBattleRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut slots__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Slots => {
                            if slots__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Slots"));
                            }
                            slots__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(SetSlotAutoBattleRequest {
                    slots: slots__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SetSlotAutoBattleRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SetTunnel {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.tunnel_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SetTunnel", len)?;
        if let Some(v) = self.tunnel_id.as_ref() {
            struct_ser.serialize_field("TunnelId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SetTunnel {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TunnelId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TunnelId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TunnelId" => Ok(GeneratedField::TunnelId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SetTunnel;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SetTunnel")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SetTunnel, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut tunnel_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TunnelId => {
                            if tunnel_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TunnelId"));
                            }
                            tunnel_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SetTunnel {
                    tunnel_id: tunnel_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SetTunnel", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SettingData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.setting_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SettingData", len)?;
        if !self.setting_map.is_empty() {
            struct_ser.serialize_field("SettingMap", &self.setting_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SettingData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SettingMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SettingMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SettingMap" => Ok(GeneratedField::SettingMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SettingData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SettingData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SettingData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut setting_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SettingMap => {
                            if setting_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SettingMap"));
                            }
                            setting_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(SettingData {
                    setting_map: setting_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SettingData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SettlementPosition {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.pos.is_some() {
            len += 1;
        }
        if self.rotate.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SettlementPosition", len)?;
        if let Some(v) = self.pos.as_ref() {
            struct_ser.serialize_field("Pos", v)?;
        }
        if let Some(v) = self.rotate.as_ref() {
            struct_ser.serialize_field("Rotate", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SettlementPosition {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Pos",
            "Rotate",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Pos,
            Rotate,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Pos" => Ok(GeneratedField::Pos),
                            "Rotate" => Ok(GeneratedField::Rotate),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SettlementPosition;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SettlementPosition")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SettlementPosition, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pos__ = None;
                let mut rotate__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Pos => {
                            if pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Pos"));
                            }
                            pos__ = map_.next_value()?;
                        }
                        GeneratedField::Rotate => {
                            if rotate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Rotate"));
                            }
                            rotate__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SettlementPosition {
                    pos: pos__,
                    rotate: rotate__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SettlementPosition", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ShopCompensationData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.items.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ShopCompensationData", len)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("Items", &self.items)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ShopCompensationData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Items",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Items" => Ok(GeneratedField::Items),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ShopCompensationData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ShopCompensationData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ShopCompensationData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Items"));
                            }
                            items__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ShopCompensationData {
                    items: items__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ShopCompensationData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ShopCompensationInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.entor_store_num.is_some() {
            len += 1;
        }
        if self.buy_num.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ShopCompensationInfo", len)?;
        if let Some(v) = self.entor_store_num.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("EntorStoreNum", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.buy_num.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BuyNum", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ShopCompensationInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EntorStoreNum",
            "BuyNum",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EntorStoreNum,
            BuyNum,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EntorStoreNum" => Ok(GeneratedField::EntorStoreNum),
                            "BuyNum" => Ok(GeneratedField::BuyNum),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ShopCompensationInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ShopCompensationInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ShopCompensationInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut entor_store_num__ = None;
                let mut buy_num__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EntorStoreNum => {
                            if entor_store_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EntorStoreNum"));
                            }
                            entor_store_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BuyNum => {
                            if buy_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuyNum"));
                            }
                            buy_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ShopCompensationInfo {
                    entor_store_num: entor_store_num__,
                    buy_num: buy_num__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ShopCompensationInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ShopData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.refresh_list.is_empty() {
            len += 1;
        }
        if !self.normal_shop_records.is_empty() {
            len += 1;
        }
        if !self.season_shop_records.is_empty() {
            len += 1;
        }
        if self.compensation_item_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ShopData", len)?;
        if !self.refresh_list.is_empty() {
            struct_ser.serialize_field("RefreshList", &self.refresh_list)?;
        }
        if !self.normal_shop_records.is_empty() {
            struct_ser.serialize_field("NormalShopRecords", &self.normal_shop_records)?;
        }
        if !self.season_shop_records.is_empty() {
            struct_ser.serialize_field("SeasonShopRecords", &self.season_shop_records)?;
        }
        if let Some(v) = self.compensation_item_data.as_ref() {
            struct_ser.serialize_field("CompensationItemData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ShopData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RefreshList",
            "NormalShopRecords",
            "SeasonShopRecords",
            "CompensationItemData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RefreshList,
            NormalShopRecords,
            SeasonShopRecords,
            CompensationItemData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RefreshList" => Ok(GeneratedField::RefreshList),
                            "NormalShopRecords" => Ok(GeneratedField::NormalShopRecords),
                            "SeasonShopRecords" => Ok(GeneratedField::SeasonShopRecords),
                            "CompensationItemData" => Ok(GeneratedField::CompensationItemData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ShopData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ShopData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ShopData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut refresh_list__ = None;
                let mut normal_shop_records__ = None;
                let mut season_shop_records__ = None;
                let mut compensation_item_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RefreshList => {
                            if refresh_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshList"));
                            }
                            refresh_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::NormalShopRecords => {
                            if normal_shop_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NormalShopRecords"));
                            }
                            normal_shop_records__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::SeasonShopRecords => {
                            if season_shop_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonShopRecords"));
                            }
                            season_shop_records__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::CompensationItemData => {
                            if compensation_item_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CompensationItemData"));
                            }
                            compensation_item_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(ShopData {
                    refresh_list: refresh_list__.unwrap_or_default(),
                    normal_shop_records: normal_shop_records__.unwrap_or_default(),
                    season_shop_records: season_shop_records__.unwrap_or_default(),
                    compensation_item_data: compensation_item_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ShopData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ShopRefreshRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.refresh_timestamp.is_some() {
            len += 1;
        }
        if self.refresh_count.is_some() {
            len += 1;
        }
        if !self.shop_refresh_records.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ShopRefreshRecord", len)?;
        if let Some(v) = self.refresh_timestamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RefreshTimestamp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.refresh_count.as_ref() {
            struct_ser.serialize_field("RefreshCount", v)?;
        }
        if !self.shop_refresh_records.is_empty() {
            struct_ser.serialize_field("ShopRefreshRecords", &self.shop_refresh_records)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ShopRefreshRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RefreshTimestamp",
            "RefreshCount",
            "ShopRefreshRecords",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RefreshTimestamp,
            RefreshCount,
            ShopRefreshRecords,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RefreshTimestamp" => Ok(GeneratedField::RefreshTimestamp),
                            "RefreshCount" => Ok(GeneratedField::RefreshCount),
                            "ShopRefreshRecords" => Ok(GeneratedField::ShopRefreshRecords),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ShopRefreshRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ShopRefreshRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ShopRefreshRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut refresh_timestamp__ = None;
                let mut refresh_count__ = None;
                let mut shop_refresh_records__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RefreshTimestamp => {
                            if refresh_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshTimestamp"));
                            }
                            refresh_timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RefreshCount => {
                            if refresh_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshCount"));
                            }
                            refresh_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ShopRefreshRecords => {
                            if shop_refresh_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShopRefreshRecords"));
                            }
                            shop_refresh_records__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ShopRefreshRecord {
                    refresh_timestamp: refresh_timestamp__,
                    refresh_count: refresh_count__,
                    shop_refresh_records: shop_refresh_records__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ShopRefreshRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ShowPieceAttr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.piece_info.is_some() {
            len += 1;
        }
        if self.begin_time.is_some() {
            len += 1;
        }
        if self.end_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ShowPieceAttr", len)?;
        if let Some(v) = self.piece_info.as_ref() {
            struct_ser.serialize_field("PieceInfo", v)?;
        }
        if let Some(v) = self.begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.end_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("EndTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ShowPieceAttr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PieceInfo",
            "BeginTime",
            "EndTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PieceInfo,
            BeginTime,
            EndTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PieceInfo" => Ok(GeneratedField::PieceInfo),
                            "BeginTime" => Ok(GeneratedField::BeginTime),
                            "EndTime" => Ok(GeneratedField::EndTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ShowPieceAttr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ShowPieceAttr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ShowPieceAttr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut piece_info__ = None;
                let mut begin_time__ = None;
                let mut end_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PieceInfo => {
                            if piece_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PieceInfo"));
                            }
                            piece_info__ = map_.next_value()?;
                        }
                        GeneratedField::BeginTime => {
                            if begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeginTime"));
                            }
                            begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EndTime"));
                            }
                            end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ShowPieceAttr {
                    piece_info: piece_info__,
                    begin_time: begin_time__,
                    end_time: end_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ShowPieceAttr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ShowPieceAttrList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.show_piece_attrs.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ShowPieceAttrList", len)?;
        if !self.show_piece_attrs.is_empty() {
            struct_ser.serialize_field("ShowPieceAttrs", &self.show_piece_attrs)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ShowPieceAttrList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ShowPieceAttrs",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ShowPieceAttrs,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ShowPieceAttrs" => Ok(GeneratedField::ShowPieceAttrs),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ShowPieceAttrList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ShowPieceAttrList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ShowPieceAttrList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut show_piece_attrs__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ShowPieceAttrs => {
                            if show_piece_attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShowPieceAttrs"));
                            }
                            show_piece_attrs__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(ShowPieceAttrList {
                    show_piece_attrs: show_piece_attrs__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ShowPieceAttrList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ShowPieceData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.often_use_type_list.is_empty() {
            len += 1;
        }
        if !self.unlock_type_list.is_empty() {
            len += 1;
        }
        if !self.roulette_pos_piece_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ShowPieceData", len)?;
        if !self.often_use_type_list.is_empty() {
            struct_ser.serialize_field("OftenUseTypeList", &self.often_use_type_list)?;
        }
        if !self.unlock_type_list.is_empty() {
            struct_ser.serialize_field("UnlockTypeList", &self.unlock_type_list)?;
        }
        if !self.roulette_pos_piece_info.is_empty() {
            struct_ser.serialize_field("RoulettePosPieceInfo", &self.roulette_pos_piece_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ShowPieceData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OftenUseTypeList",
            "UnlockTypeList",
            "RoulettePosPieceInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OftenUseTypeList,
            UnlockTypeList,
            RoulettePosPieceInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "OftenUseTypeList" => Ok(GeneratedField::OftenUseTypeList),
                            "UnlockTypeList" => Ok(GeneratedField::UnlockTypeList),
                            "RoulettePosPieceInfo" => Ok(GeneratedField::RoulettePosPieceInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ShowPieceData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ShowPieceData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ShowPieceData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut often_use_type_list__ = None;
                let mut unlock_type_list__ = None;
                let mut roulette_pos_piece_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OftenUseTypeList => {
                            if often_use_type_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OftenUseTypeList"));
                            }
                            often_use_type_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::UnlockTypeList => {
                            if unlock_type_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockTypeList"));
                            }
                            unlock_type_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::RoulettePosPieceInfo => {
                            if roulette_pos_piece_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RoulettePosPieceInfo"));
                            }
                            roulette_pos_piece_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(ShowPieceData {
                    often_use_type_list: often_use_type_list__.unwrap_or_default(),
                    unlock_type_list: unlock_type_list__.unwrap_or_default(),
                    roulette_pos_piece_info: roulette_pos_piece_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ShowPieceData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ShowPieceIdList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.piece_ids.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ShowPieceIdList", len)?;
        if !self.piece_ids.is_empty() {
            struct_ser.serialize_field("PieceIds", &self.piece_ids)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ShowPieceIdList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PieceIds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PieceIds,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PieceIds" => Ok(GeneratedField::PieceIds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ShowPieceIdList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ShowPieceIdList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ShowPieceIdList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut piece_ids__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PieceIds => {
                            if piece_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PieceIds"));
                            }
                            piece_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(ShowPieceIdList {
                    piece_ids: piece_ids__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ShowPieceIdList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ShowPiecePair {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.piece_type.is_some() {
            len += 1;
        }
        if self.piece_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ShowPiecePair", len)?;
        if let Some(v) = self.piece_type.as_ref() {
            let v = EShowPieceType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("PieceType", &v)?;
        }
        if let Some(v) = self.piece_id.as_ref() {
            struct_ser.serialize_field("PieceId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ShowPiecePair {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PieceType",
            "PieceId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PieceType,
            PieceId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PieceType" => Ok(GeneratedField::PieceType),
                            "PieceId" => Ok(GeneratedField::PieceId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ShowPiecePair;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ShowPiecePair")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ShowPiecePair, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut piece_type__ = None;
                let mut piece_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PieceType => {
                            if piece_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PieceType"));
                            }
                            piece_type__ = map_.next_value::<::std::option::Option<EShowPieceType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::PieceId => {
                            if piece_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PieceId"));
                            }
                            piece_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ShowPiecePair {
                    piece_type: piece_type__,
                    piece_id: piece_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ShowPiecePair", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SignInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sign_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SignInfo", len)?;
        if !self.sign_info.is_empty() {
            struct_ser.serialize_field("SignInfo", &self.sign_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SignInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SignInfo_",
            "SignInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SignInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SignInfo" | "SignInfo_" => Ok(GeneratedField::SignInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SignInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SignInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SignInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sign_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SignInfo => {
                            if sign_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SignInfo"));
                            }
                            sign_info__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(SignInfo {
                    sign_info: sign_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SignInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SignStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_signed.is_some() {
            len += 1;
        }
        if self.is_rewarded.is_some() {
            len += 1;
        }
        if self.is_supplement.is_some() {
            len += 1;
        }
        if self.sign_time.is_some() {
            len += 1;
        }
        if self.reward_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SignStatus", len)?;
        if let Some(v) = self.is_signed.as_ref() {
            struct_ser.serialize_field("IsSigned", v)?;
        }
        if let Some(v) = self.is_rewarded.as_ref() {
            struct_ser.serialize_field("IsRewarded", v)?;
        }
        if let Some(v) = self.is_supplement.as_ref() {
            struct_ser.serialize_field("IsSupplement", v)?;
        }
        if let Some(v) = self.sign_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SignTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.reward_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RewardTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SignStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsSigned",
            "IsRewarded",
            "IsSupplement",
            "SignTime",
            "RewardTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsSigned,
            IsRewarded,
            IsSupplement,
            SignTime,
            RewardTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsSigned" => Ok(GeneratedField::IsSigned),
                            "IsRewarded" => Ok(GeneratedField::IsRewarded),
                            "IsSupplement" => Ok(GeneratedField::IsSupplement),
                            "SignTime" => Ok(GeneratedField::SignTime),
                            "RewardTime" => Ok(GeneratedField::RewardTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SignStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SignStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SignStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_signed__ = None;
                let mut is_rewarded__ = None;
                let mut is_supplement__ = None;
                let mut sign_time__ = None;
                let mut reward_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsSigned => {
                            if is_signed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsSigned"));
                            }
                            is_signed__ = map_.next_value()?;
                        }
                        GeneratedField::IsRewarded => {
                            if is_rewarded__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsRewarded"));
                            }
                            is_rewarded__ = map_.next_value()?;
                        }
                        GeneratedField::IsSupplement => {
                            if is_supplement__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsSupplement"));
                            }
                            is_supplement__ = map_.next_value()?;
                        }
                        GeneratedField::SignTime => {
                            if sign_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SignTime"));
                            }
                            sign_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RewardTime => {
                            if reward_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RewardTime"));
                            }
                            reward_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SignStatus {
                    is_signed: is_signed__,
                    is_rewarded: is_rewarded__,
                    is_supplement: is_supplement__,
                    sign_time: sign_time__,
                    reward_time: reward_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SignStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SignStatusList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.sign_status_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SignStatusList", len)?;
        if !self.sign_status_data.is_empty() {
            struct_ser.serialize_field("SignStatusData", &self.sign_status_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SignStatusList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SignStatusData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SignStatusData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SignStatusData" => Ok(GeneratedField::SignStatusData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SignStatusList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SignStatusList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SignStatusList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sign_status_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SignStatusData => {
                            if sign_status_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SignStatusData"));
                            }
                            sign_status_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(SignStatusList {
                    sign_status_data: sign_status_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SignStatusList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SkillCd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_level_id.is_some() {
            len += 1;
        }
        if self.begin_time.is_some() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        if self.skill_cd_type.is_some() {
            len += 1;
        }
        if self.valid_cd_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SkillCD", len)?;
        if let Some(v) = self.skill_level_id.as_ref() {
            struct_ser.serialize_field("SkillLevelId", v)?;
        }
        if let Some(v) = self.begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("Duration", v)?;
        }
        if let Some(v) = self.skill_cd_type.as_ref() {
            let v = ESkillCdType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("SkillCDType", &v)?;
        }
        if let Some(v) = self.valid_cd_time.as_ref() {
            struct_ser.serialize_field("ValidCDTime", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SkillCd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillLevelId",
            "BeginTime",
            "Duration",
            "SkillCDType",
            "ValidCDTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillLevelId,
            BeginTime,
            Duration,
            SkillCdType,
            ValidCdTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillLevelId" => Ok(GeneratedField::SkillLevelId),
                            "BeginTime" => Ok(GeneratedField::BeginTime),
                            "Duration" => Ok(GeneratedField::Duration),
                            "SkillCDType" => Ok(GeneratedField::SkillCdType),
                            "ValidCDTime" => Ok(GeneratedField::ValidCdTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SkillCd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SkillCD")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SkillCd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_level_id__ = None;
                let mut begin_time__ = None;
                let mut duration__ = None;
                let mut skill_cd_type__ = None;
                let mut valid_cd_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillLevelId => {
                            if skill_level_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillLevelId"));
                            }
                            skill_level_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BeginTime => {
                            if begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeginTime"));
                            }
                            begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillCdType => {
                            if skill_cd_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillCDType"));
                            }
                            skill_cd_type__ = map_.next_value::<::std::option::Option<ESkillCdType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ValidCdTime => {
                            if valid_cd_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ValidCDTime"));
                            }
                            valid_cd_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SkillCd {
                    skill_level_id: skill_level_id__,
                    begin_time: begin_time__,
                    duration: duration__,
                    skill_cd_type: skill_cd_type__,
                    valid_cd_time: valid_cd_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SkillCD", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SkillCdInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_level_id.is_some() {
            len += 1;
        }
        if self.skill_begin_time.is_some() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        if self.skill_cd_type.is_some() {
            len += 1;
        }
        if self.profession_hold_begin_time.is_some() {
            len += 1;
        }
        if self.charge_count.is_some() {
            len += 1;
        }
        if self.valid_cd_time.is_some() {
            len += 1;
        }
        if self.sub_cd_ratio.is_some() {
            len += 1;
        }
        if self.sub_cd_fixed.is_some() {
            len += 1;
        }
        if self.accelerate_cd_ratio.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SkillCDInfo", len)?;
        if let Some(v) = self.skill_level_id.as_ref() {
            struct_ser.serialize_field("SkillLevelId", v)?;
        }
        if let Some(v) = self.skill_begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SkillBeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("Duration", v)?;
        }
        if let Some(v) = self.skill_cd_type.as_ref() {
            struct_ser.serialize_field("SkillCDType", v)?;
        }
        if let Some(v) = self.profession_hold_begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ProfessionHoldBeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.charge_count.as_ref() {
            struct_ser.serialize_field("ChargeCount", v)?;
        }
        if let Some(v) = self.valid_cd_time.as_ref() {
            struct_ser.serialize_field("ValidCDTime", v)?;
        }
        if let Some(v) = self.sub_cd_ratio.as_ref() {
            struct_ser.serialize_field("SubCDRatio", v)?;
        }
        if let Some(v) = self.sub_cd_fixed.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SubCDFixed", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.accelerate_cd_ratio.as_ref() {
            struct_ser.serialize_field("AccelerateCDRatio", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SkillCdInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillLevelId",
            "SkillBeginTime",
            "Duration",
            "SkillCDType",
            "ProfessionHoldBeginTime",
            "ChargeCount",
            "ValidCDTime",
            "SubCDRatio",
            "SubCDFixed",
            "AccelerateCDRatio",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillLevelId,
            SkillBeginTime,
            Duration,
            SkillCdType,
            ProfessionHoldBeginTime,
            ChargeCount,
            ValidCdTime,
            SubCdRatio,
            SubCdFixed,
            AccelerateCdRatio,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillLevelId" => Ok(GeneratedField::SkillLevelId),
                            "SkillBeginTime" => Ok(GeneratedField::SkillBeginTime),
                            "Duration" => Ok(GeneratedField::Duration),
                            "SkillCDType" => Ok(GeneratedField::SkillCdType),
                            "ProfessionHoldBeginTime" => Ok(GeneratedField::ProfessionHoldBeginTime),
                            "ChargeCount" => Ok(GeneratedField::ChargeCount),
                            "ValidCDTime" => Ok(GeneratedField::ValidCdTime),
                            "SubCDRatio" => Ok(GeneratedField::SubCdRatio),
                            "SubCDFixed" => Ok(GeneratedField::SubCdFixed),
                            "AccelerateCDRatio" => Ok(GeneratedField::AccelerateCdRatio),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SkillCdInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SkillCDInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SkillCdInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_level_id__ = None;
                let mut skill_begin_time__ = None;
                let mut duration__ = None;
                let mut skill_cd_type__ = None;
                let mut profession_hold_begin_time__ = None;
                let mut charge_count__ = None;
                let mut valid_cd_time__ = None;
                let mut sub_cd_ratio__ = None;
                let mut sub_cd_fixed__ = None;
                let mut accelerate_cd_ratio__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillLevelId => {
                            if skill_level_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillLevelId"));
                            }
                            skill_level_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillBeginTime => {
                            if skill_begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillBeginTime"));
                            }
                            skill_begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillCdType => {
                            if skill_cd_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillCDType"));
                            }
                            skill_cd_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ProfessionHoldBeginTime => {
                            if profession_hold_begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfessionHoldBeginTime"));
                            }
                            profession_hold_begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ChargeCount => {
                            if charge_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ChargeCount"));
                            }
                            charge_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ValidCdTime => {
                            if valid_cd_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ValidCDTime"));
                            }
                            valid_cd_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SubCdRatio => {
                            if sub_cd_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SubCDRatio"));
                            }
                            sub_cd_ratio__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SubCdFixed => {
                            if sub_cd_fixed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SubCDFixed"));
                            }
                            sub_cd_fixed__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AccelerateCdRatio => {
                            if accelerate_cd_ratio__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccelerateCDRatio"));
                            }
                            accelerate_cd_ratio__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SkillCdInfo {
                    skill_level_id: skill_level_id__,
                    skill_begin_time: skill_begin_time__,
                    duration: duration__,
                    skill_cd_type: skill_cd_type__,
                    profession_hold_begin_time: profession_hold_begin_time__,
                    charge_count: charge_count__,
                    valid_cd_time: valid_cd_time__,
                    sub_cd_ratio: sub_cd_ratio__,
                    sub_cd_fixed: sub_cd_fixed__,
                    accelerate_cd_ratio: accelerate_cd_ratio__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SkillCDInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SkillEffect {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if !self.damages.is_empty() {
            len += 1;
        }
        if self.total_damage.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SkillEffect", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if !self.damages.is_empty() {
            struct_ser.serialize_field("Damages", &self.damages)?;
        }
        if let Some(v) = self.total_damage.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TotalDamage", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SkillEffect {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "Damages",
            "TotalDamage",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            Damages,
            TotalDamage,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "Damages" => Ok(GeneratedField::Damages),
                            "TotalDamage" => Ok(GeneratedField::TotalDamage),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SkillEffect;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SkillEffect")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SkillEffect, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut damages__ = None;
                let mut total_damage__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Damages => {
                            if damages__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Damages"));
                            }
                            damages__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TotalDamage => {
                            if total_damage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TotalDamage"));
                            }
                            total_damage__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SkillEffect {
                    uuid: uuid__,
                    damages: damages__.unwrap_or_default(),
                    total_damage: total_damage__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SkillEffect", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SkillSkin {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_id.is_some() {
            len += 1;
        }
        if self.skin_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SkillSkin", len)?;
        if let Some(v) = self.skill_id.as_ref() {
            struct_ser.serialize_field("SkillId", v)?;
        }
        if let Some(v) = self.skin_id.as_ref() {
            struct_ser.serialize_field("SkinId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SkillSkin {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillId",
            "SkinId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillId,
            SkinId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillId" => Ok(GeneratedField::SkillId),
                            "SkinId" => Ok(GeneratedField::SkinId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SkillSkin;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SkillSkin")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SkillSkin, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_id__ = None;
                let mut skin_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillId => {
                            if skill_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillId"));
                            }
                            skill_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkinId => {
                            if skin_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkinId"));
                            }
                            skin_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SkillSkin {
                    skill_id: skill_id__,
                    skin_id: skin_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SkillSkin", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Slot {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.slots.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Slot", len)?;
        if !self.slots.is_empty() {
            struct_ser.serialize_field("Slots", &self.slots)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Slot {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Slots",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Slots,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Slots" => Ok(GeneratedField::Slots),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Slot;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Slot")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Slot, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut slots__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Slots => {
                            if slots__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Slots"));
                            }
                            slots__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(Slot {
                    slots: slots__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Slot", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SlotData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.slots.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SlotData", len)?;
        if !self.slots.is_empty() {
            struct_ser.serialize_field("Slots", &self.slots)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SlotData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Slots",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Slots,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Slots" => Ok(GeneratedField::Slots),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SlotData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SlotData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SlotData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut slots__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Slots => {
                            if slots__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Slots"));
                            }
                            slots__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(SlotData {
                    slots: slots__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SlotData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SlotInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.skill_id.is_some() {
            len += 1;
        }
        if self.is_auto_battle_close.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SlotInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.skill_id.as_ref() {
            struct_ser.serialize_field("SkillId", v)?;
        }
        if let Some(v) = self.is_auto_battle_close.as_ref() {
            struct_ser.serialize_field("IsAutoBattleClose", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SlotInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "SkillId",
            "IsAutoBattleClose",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            SkillId,
            IsAutoBattleClose,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "SkillId" => Ok(GeneratedField::SkillId),
                            "IsAutoBattleClose" => Ok(GeneratedField::IsAutoBattleClose),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SlotInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SlotInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SlotInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut skill_id__ = None;
                let mut is_auto_battle_close__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillId => {
                            if skill_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillId"));
                            }
                            skill_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsAutoBattleClose => {
                            if is_auto_battle_close__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsAutoBattleClose"));
                            }
                            is_auto_battle_close__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SlotInfo {
                    id: id__,
                    skill_id: skill_id__,
                    is_auto_battle_close: is_auto_battle_close__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SlotInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SlotInfoData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.skill_id.is_some() {
            len += 1;
        }
        if self.is_replace.is_some() {
            len += 1;
        }
        if self.show_effect.is_some() {
            len += 1;
        }
        if self.cd.is_some() {
            len += 1;
        }
        if self.is_auto_battle_close.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SlotInfoData", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.skill_id.as_ref() {
            struct_ser.serialize_field("SkillId", v)?;
        }
        if let Some(v) = self.is_replace.as_ref() {
            struct_ser.serialize_field("IsReplace", v)?;
        }
        if let Some(v) = self.show_effect.as_ref() {
            struct_ser.serialize_field("ShowEffect", v)?;
        }
        if let Some(v) = self.cd.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Cd", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.is_auto_battle_close.as_ref() {
            struct_ser.serialize_field("IsAutoBattleClose", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SlotInfoData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "SkillId",
            "IsReplace",
            "ShowEffect",
            "Cd",
            "IsAutoBattleClose",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            SkillId,
            IsReplace,
            ShowEffect,
            Cd,
            IsAutoBattleClose,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "SkillId" => Ok(GeneratedField::SkillId),
                            "IsReplace" => Ok(GeneratedField::IsReplace),
                            "ShowEffect" => Ok(GeneratedField::ShowEffect),
                            "Cd" => Ok(GeneratedField::Cd),
                            "IsAutoBattleClose" => Ok(GeneratedField::IsAutoBattleClose),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SlotInfoData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SlotInfoData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SlotInfoData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut skill_id__ = None;
                let mut is_replace__ = None;
                let mut show_effect__ = None;
                let mut cd__ = None;
                let mut is_auto_battle_close__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillId => {
                            if skill_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillId"));
                            }
                            skill_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsReplace => {
                            if is_replace__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsReplace"));
                            }
                            is_replace__ = map_.next_value()?;
                        }
                        GeneratedField::ShowEffect => {
                            if show_effect__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShowEffect"));
                            }
                            show_effect__ = map_.next_value()?;
                        }
                        GeneratedField::Cd => {
                            if cd__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Cd"));
                            }
                            cd__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsAutoBattleClose => {
                            if is_auto_battle_close__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsAutoBattleClose"));
                            }
                            is_auto_battle_close__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SlotInfoData {
                    id: id__,
                    skill_id: skill_id__,
                    is_replace: is_replace__,
                    show_effect: show_effect__,
                    cd: cd__,
                    is_auto_battle_close: is_auto_battle_close__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SlotInfoData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SocialData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.char_id.is_some() {
            len += 1;
        }
        if self.account_id.is_some() {
            len += 1;
        }
        if self.basic_data.is_some() {
            len += 1;
        }
        if self.avatar_info.is_some() {
            len += 1;
        }
        if self.face_data.is_some() {
            len += 1;
        }
        if self.profession_data.is_some() {
            len += 1;
        }
        if self.equip_data.is_some() {
            len += 1;
        }
        if self.fashion_data.is_some() {
            len += 1;
        }
        if self.setting_data.is_some() {
            len += 1;
        }
        if self.scene_data.is_some() {
            len += 1;
        }
        if self.user_attr_data.is_some() {
            len += 1;
        }
        if self.team_data.is_some() {
            len += 1;
        }
        if self.union_data.is_some() {
            len += 1;
        }
        if self.account_data.is_some() {
            len += 1;
        }
        if self.function_data.is_some() {
            len += 1;
        }
        if self.personal_zone.is_some() {
            len += 1;
        }
        if self.warehouse.is_some() {
            len += 1;
        }
        if self.season_rank.is_some() {
            len += 1;
        }
        if self.fish_data.is_some() {
            len += 1;
        }
        if self.community_data.is_some() {
            len += 1;
        }
        if self.privilege_data.is_some() {
            len += 1;
        }
        if self.master_mode_dungeon_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SocialData", len)?;
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.account_id.as_ref() {
            struct_ser.serialize_field("AccountId", v)?;
        }
        if let Some(v) = self.basic_data.as_ref() {
            struct_ser.serialize_field("BasicData", v)?;
        }
        if let Some(v) = self.avatar_info.as_ref() {
            struct_ser.serialize_field("AvatarInfo", v)?;
        }
        if let Some(v) = self.face_data.as_ref() {
            struct_ser.serialize_field("FaceData", v)?;
        }
        if let Some(v) = self.profession_data.as_ref() {
            struct_ser.serialize_field("ProfessionData", v)?;
        }
        if let Some(v) = self.equip_data.as_ref() {
            struct_ser.serialize_field("EquipData", v)?;
        }
        if let Some(v) = self.fashion_data.as_ref() {
            struct_ser.serialize_field("FashionData", v)?;
        }
        if let Some(v) = self.setting_data.as_ref() {
            struct_ser.serialize_field("SettingData", v)?;
        }
        if let Some(v) = self.scene_data.as_ref() {
            struct_ser.serialize_field("SceneData", v)?;
        }
        if let Some(v) = self.user_attr_data.as_ref() {
            struct_ser.serialize_field("UserAttrData", v)?;
        }
        if let Some(v) = self.team_data.as_ref() {
            struct_ser.serialize_field("TeamData", v)?;
        }
        if let Some(v) = self.union_data.as_ref() {
            struct_ser.serialize_field("UnionData", v)?;
        }
        if let Some(v) = self.account_data.as_ref() {
            struct_ser.serialize_field("AccountData", v)?;
        }
        if let Some(v) = self.function_data.as_ref() {
            struct_ser.serialize_field("FunctionData", v)?;
        }
        if let Some(v) = self.personal_zone.as_ref() {
            struct_ser.serialize_field("PersonalZone", v)?;
        }
        if let Some(v) = self.warehouse.as_ref() {
            struct_ser.serialize_field("Warehouse", v)?;
        }
        if let Some(v) = self.season_rank.as_ref() {
            struct_ser.serialize_field("SeasonRank", v)?;
        }
        if let Some(v) = self.fish_data.as_ref() {
            struct_ser.serialize_field("FishData", v)?;
        }
        if let Some(v) = self.community_data.as_ref() {
            struct_ser.serialize_field("CommunityData", v)?;
        }
        if let Some(v) = self.privilege_data.as_ref() {
            struct_ser.serialize_field("PrivilegeData", v)?;
        }
        if let Some(v) = self.master_mode_dungeon_data.as_ref() {
            struct_ser.serialize_field("MasterModeDungeonData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SocialData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CharId",
            "AccountId",
            "BasicData",
            "AvatarInfo",
            "FaceData",
            "ProfessionData",
            "EquipData",
            "FashionData",
            "SettingData",
            "SceneData",
            "UserAttrData",
            "TeamData",
            "UnionData",
            "AccountData",
            "FunctionData",
            "PersonalZone",
            "Warehouse",
            "SeasonRank",
            "FishData",
            "CommunityData",
            "PrivilegeData",
            "MasterModeDungeonData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CharId,
            AccountId,
            BasicData,
            AvatarInfo,
            FaceData,
            ProfessionData,
            EquipData,
            FashionData,
            SettingData,
            SceneData,
            UserAttrData,
            TeamData,
            UnionData,
            AccountData,
            FunctionData,
            PersonalZone,
            Warehouse,
            SeasonRank,
            FishData,
            CommunityData,
            PrivilegeData,
            MasterModeDungeonData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CharId" => Ok(GeneratedField::CharId),
                            "AccountId" => Ok(GeneratedField::AccountId),
                            "BasicData" => Ok(GeneratedField::BasicData),
                            "AvatarInfo" => Ok(GeneratedField::AvatarInfo),
                            "FaceData" => Ok(GeneratedField::FaceData),
                            "ProfessionData" => Ok(GeneratedField::ProfessionData),
                            "EquipData" => Ok(GeneratedField::EquipData),
                            "FashionData" => Ok(GeneratedField::FashionData),
                            "SettingData" => Ok(GeneratedField::SettingData),
                            "SceneData" => Ok(GeneratedField::SceneData),
                            "UserAttrData" => Ok(GeneratedField::UserAttrData),
                            "TeamData" => Ok(GeneratedField::TeamData),
                            "UnionData" => Ok(GeneratedField::UnionData),
                            "AccountData" => Ok(GeneratedField::AccountData),
                            "FunctionData" => Ok(GeneratedField::FunctionData),
                            "PersonalZone" => Ok(GeneratedField::PersonalZone),
                            "Warehouse" => Ok(GeneratedField::Warehouse),
                            "SeasonRank" => Ok(GeneratedField::SeasonRank),
                            "FishData" => Ok(GeneratedField::FishData),
                            "CommunityData" => Ok(GeneratedField::CommunityData),
                            "PrivilegeData" => Ok(GeneratedField::PrivilegeData),
                            "MasterModeDungeonData" => Ok(GeneratedField::MasterModeDungeonData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SocialData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SocialData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SocialData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut char_id__ = None;
                let mut account_id__ = None;
                let mut basic_data__ = None;
                let mut avatar_info__ = None;
                let mut face_data__ = None;
                let mut profession_data__ = None;
                let mut equip_data__ = None;
                let mut fashion_data__ = None;
                let mut setting_data__ = None;
                let mut scene_data__ = None;
                let mut user_attr_data__ = None;
                let mut team_data__ = None;
                let mut union_data__ = None;
                let mut account_data__ = None;
                let mut function_data__ = None;
                let mut personal_zone__ = None;
                let mut warehouse__ = None;
                let mut season_rank__ = None;
                let mut fish_data__ = None;
                let mut community_data__ = None;
                let mut privilege_data__ = None;
                let mut master_mode_dungeon_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AccountId => {
                            if account_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccountId"));
                            }
                            account_id__ = map_.next_value()?;
                        }
                        GeneratedField::BasicData => {
                            if basic_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BasicData"));
                            }
                            basic_data__ = map_.next_value()?;
                        }
                        GeneratedField::AvatarInfo => {
                            if avatar_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AvatarInfo"));
                            }
                            avatar_info__ = map_.next_value()?;
                        }
                        GeneratedField::FaceData => {
                            if face_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FaceData"));
                            }
                            face_data__ = map_.next_value()?;
                        }
                        GeneratedField::ProfessionData => {
                            if profession_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfessionData"));
                            }
                            profession_data__ = map_.next_value()?;
                        }
                        GeneratedField::EquipData => {
                            if equip_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipData"));
                            }
                            equip_data__ = map_.next_value()?;
                        }
                        GeneratedField::FashionData => {
                            if fashion_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionData"));
                            }
                            fashion_data__ = map_.next_value()?;
                        }
                        GeneratedField::SettingData => {
                            if setting_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SettingData"));
                            }
                            setting_data__ = map_.next_value()?;
                        }
                        GeneratedField::SceneData => {
                            if scene_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneData"));
                            }
                            scene_data__ = map_.next_value()?;
                        }
                        GeneratedField::UserAttrData => {
                            if user_attr_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UserAttrData"));
                            }
                            user_attr_data__ = map_.next_value()?;
                        }
                        GeneratedField::TeamData => {
                            if team_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TeamData"));
                            }
                            team_data__ = map_.next_value()?;
                        }
                        GeneratedField::UnionData => {
                            if union_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnionData"));
                            }
                            union_data__ = map_.next_value()?;
                        }
                        GeneratedField::AccountData => {
                            if account_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccountData"));
                            }
                            account_data__ = map_.next_value()?;
                        }
                        GeneratedField::FunctionData => {
                            if function_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FunctionData"));
                            }
                            function_data__ = map_.next_value()?;
                        }
                        GeneratedField::PersonalZone => {
                            if personal_zone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PersonalZone"));
                            }
                            personal_zone__ = map_.next_value()?;
                        }
                        GeneratedField::Warehouse => {
                            if warehouse__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Warehouse"));
                            }
                            warehouse__ = map_.next_value()?;
                        }
                        GeneratedField::SeasonRank => {
                            if season_rank__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonRank"));
                            }
                            season_rank__ = map_.next_value()?;
                        }
                        GeneratedField::FishData => {
                            if fish_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FishData"));
                            }
                            fish_data__ = map_.next_value()?;
                        }
                        GeneratedField::CommunityData => {
                            if community_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CommunityData"));
                            }
                            community_data__ = map_.next_value()?;
                        }
                        GeneratedField::PrivilegeData => {
                            if privilege_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PrivilegeData"));
                            }
                            privilege_data__ = map_.next_value()?;
                        }
                        GeneratedField::MasterModeDungeonData => {
                            if master_mode_dungeon_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MasterModeDungeonData"));
                            }
                            master_mode_dungeon_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SocialData {
                    char_id: char_id__,
                    account_id: account_id__,
                    basic_data: basic_data__,
                    avatar_info: avatar_info__,
                    face_data: face_data__,
                    profession_data: profession_data__,
                    equip_data: equip_data__,
                    fashion_data: fashion_data__,
                    setting_data: setting_data__,
                    scene_data: scene_data__,
                    user_attr_data: user_attr_data__,
                    team_data: team_data__,
                    union_data: union_data__,
                    account_data: account_data__,
                    function_data: function_data__,
                    personal_zone: personal_zone__,
                    warehouse: warehouse__,
                    season_rank: season_rank__,
                    fish_data: fish_data__,
                    community_data: community_data__,
                    privilege_data: privilege_data__,
                    master_mode_dungeon_data: master_mode_dungeon_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SocialData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StartPlayAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_invitee_id.is_some() {
            len += 1;
        }
        if self.v_action_id.is_some() {
            len += 1;
        }
        if self.v_is_upper.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.StartPlayAction", len)?;
        if let Some(v) = self.v_invitee_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("VInviteeId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.v_action_id.as_ref() {
            struct_ser.serialize_field("VActionId", v)?;
        }
        if let Some(v) = self.v_is_upper.as_ref() {
            struct_ser.serialize_field("VIsUpper", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StartPlayAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VInviteeId",
            "VActionId",
            "VIsUpper",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VInviteeId,
            VActionId,
            VIsUpper,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VInviteeId" => Ok(GeneratedField::VInviteeId),
                            "VActionId" => Ok(GeneratedField::VActionId),
                            "VIsUpper" => Ok(GeneratedField::VIsUpper),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StartPlayAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.StartPlayAction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StartPlayAction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_invitee_id__ = None;
                let mut v_action_id__ = None;
                let mut v_is_upper__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VInviteeId => {
                            if v_invitee_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VInviteeId"));
                            }
                            v_invitee_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VActionId => {
                            if v_action_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VActionId"));
                            }
                            v_action_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VIsUpper => {
                            if v_is_upper__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VIsUpper"));
                            }
                            v_is_upper__ = map_.next_value()?;
                        }
                    }
                }
                Ok(StartPlayAction {
                    v_invitee_id: v_invitee_id__,
                    v_action_id: v_action_id__,
                    v_is_upper: v_is_upper__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.StartPlayAction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StatRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cnt.is_some() {
            len += 1;
        }
        if !self.group_cnts.is_empty() {
            len += 1;
        }
        if !self.scene_records.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.StatRecord", len)?;
        if let Some(v) = self.cnt.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Cnt", ToString::to_string(&v).as_str())?;
        }
        if !self.group_cnts.is_empty() {
            let v: std::collections::HashMap<_, _> = self.group_cnts.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("GroupCnts", &v)?;
        }
        if !self.scene_records.is_empty() {
            struct_ser.serialize_field("SceneRecords", &self.scene_records)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StatRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Cnt",
            "GroupCnts",
            "SceneRecords",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Cnt,
            GroupCnts,
            SceneRecords,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Cnt" => Ok(GeneratedField::Cnt),
                            "GroupCnts" => Ok(GeneratedField::GroupCnts),
                            "SceneRecords" => Ok(GeneratedField::SceneRecords),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StatRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.StatRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StatRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cnt__ = None;
                let mut group_cnts__ = None;
                let mut scene_records__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Cnt => {
                            if cnt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Cnt"));
                            }
                            cnt__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GroupCnts => {
                            if group_cnts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GroupCnts"));
                            }
                            group_cnts__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<u64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::SceneRecords => {
                            if scene_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneRecords"));
                            }
                            scene_records__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(StatRecord {
                    cnt: cnt__,
                    group_cnts: group_cnts__.unwrap_or_default(),
                    scene_records: scene_records__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.StatRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StatisticsData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.stat_record_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.StatisticsData", len)?;
        if !self.stat_record_map.is_empty() {
            struct_ser.serialize_field("StatRecordMap", &self.stat_record_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StatisticsData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "StatRecordMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StatRecordMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "StatRecordMap" => Ok(GeneratedField::StatRecordMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StatisticsData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.StatisticsData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StatisticsData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut stat_record_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StatRecordMap => {
                            if stat_record_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StatRecordMap"));
                            }
                            stat_record_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(StatisticsData {
                    stat_record_map: stat_record_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.StatisticsData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StopRide {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_force.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.StopRide", len)?;
        if let Some(v) = self.is_force.as_ref() {
            struct_ser.serialize_field("IsForce", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StopRide {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsForce",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsForce,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsForce" => Ok(GeneratedField::IsForce),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StopRide;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.StopRide")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StopRide, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_force__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsForce => {
                            if is_force__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsForce"));
                            }
                            is_force__ = map_.next_value()?;
                        }
                    }
                }
                Ok(StopRide {
                    is_force: is_force__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.StopRide", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Structure {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.uuid.is_some() {
            len += 1;
        }
        if self.client_uuid.is_some() {
            len += 1;
        }
        if self.group_id.is_some() {
            len += 1;
        }
        if self.item_id.is_some() {
            len += 1;
        }
        if self.char_id.is_some() {
            len += 1;
        }
        if self.position.is_some() {
            len += 1;
        }
        if self.quaternion.is_some() {
            len += 1;
        }
        if self.operator_char_id.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if self.material_info.is_some() {
            len += 1;
        }
        if self.lamplight_info.is_some() {
            len += 1;
        }
        if self.farmland_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Structure", len)?;
        if let Some(v) = self.uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Uuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.client_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ClientUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.group_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("GroupId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.item_id.as_ref() {
            struct_ser.serialize_field("ItemId", v)?;
        }
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.position.as_ref() {
            struct_ser.serialize_field("Position", v)?;
        }
        if let Some(v) = self.quaternion.as_ref() {
            struct_ser.serialize_field("Quaternion", v)?;
        }
        if let Some(v) = self.operator_char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("OperatorCharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("Name", v)?;
        }
        if let Some(v) = self.material_info.as_ref() {
            struct_ser.serialize_field("MaterialInfo", v)?;
        }
        if let Some(v) = self.lamplight_info.as_ref() {
            struct_ser.serialize_field("LamplightInfo", v)?;
        }
        if let Some(v) = self.farmland_info.as_ref() {
            struct_ser.serialize_field("FarmlandInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Structure {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Uuid",
            "ClientUuid",
            "GroupId",
            "ItemId",
            "CharId",
            "Position",
            "Quaternion",
            "OperatorCharId",
            "Name",
            "MaterialInfo",
            "LamplightInfo",
            "FarmlandInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Uuid,
            ClientUuid,
            GroupId,
            ItemId,
            CharId,
            Position,
            Quaternion,
            OperatorCharId,
            Name,
            MaterialInfo,
            LamplightInfo,
            FarmlandInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Uuid" => Ok(GeneratedField::Uuid),
                            "ClientUuid" => Ok(GeneratedField::ClientUuid),
                            "GroupId" => Ok(GeneratedField::GroupId),
                            "ItemId" => Ok(GeneratedField::ItemId),
                            "CharId" => Ok(GeneratedField::CharId),
                            "Position" => Ok(GeneratedField::Position),
                            "Quaternion" => Ok(GeneratedField::Quaternion),
                            "OperatorCharId" => Ok(GeneratedField::OperatorCharId),
                            "Name" => Ok(GeneratedField::Name),
                            "MaterialInfo" => Ok(GeneratedField::MaterialInfo),
                            "LamplightInfo" => Ok(GeneratedField::LamplightInfo),
                            "FarmlandInfo" => Ok(GeneratedField::FarmlandInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Structure;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Structure")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Structure, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut uuid__ = None;
                let mut client_uuid__ = None;
                let mut group_id__ = None;
                let mut item_id__ = None;
                let mut char_id__ = None;
                let mut position__ = None;
                let mut quaternion__ = None;
                let mut operator_char_id__ = None;
                let mut name__ = None;
                let mut material_info__ = None;
                let mut lamplight_info__ = None;
                let mut farmland_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Uuid => {
                            if uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Uuid"));
                            }
                            uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ClientUuid => {
                            if client_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ClientUuid"));
                            }
                            client_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GroupId => {
                            if group_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GroupId"));
                            }
                            group_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ItemId => {
                            if item_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ItemId"));
                            }
                            item_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Position => {
                            if position__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Position"));
                            }
                            position__ = map_.next_value()?;
                        }
                        GeneratedField::Quaternion => {
                            if quaternion__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Quaternion"));
                            }
                            quaternion__ = map_.next_value()?;
                        }
                        GeneratedField::OperatorCharId => {
                            if operator_char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OperatorCharId"));
                            }
                            operator_char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::MaterialInfo => {
                            if material_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaterialInfo"));
                            }
                            material_info__ = map_.next_value()?;
                        }
                        GeneratedField::LamplightInfo => {
                            if lamplight_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LamplightInfo"));
                            }
                            lamplight_info__ = map_.next_value()?;
                        }
                        GeneratedField::FarmlandInfo => {
                            if farmland_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FarmlandInfo"));
                            }
                            farmland_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(Structure {
                    uuid: uuid__,
                    client_uuid: client_uuid__,
                    group_id: group_id__,
                    item_id: item_id__,
                    char_id: char_id__,
                    position: position__,
                    quaternion: quaternion__,
                    operator_char_id: operator_char_id__,
                    name: name__,
                    material_info: material_info__,
                    lamplight_info: lamplight_info__,
                    farmland_info: farmland_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Structure", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StructureFarmlandInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.operator_char_id.is_some() {
            len += 1;
        }
        if self.seed_instance.is_some() {
            len += 1;
        }
        if self.need_water.is_some() {
            len += 1;
        }
        if self.farmland_state.is_some() {
            len += 1;
        }
        if self.seeding_time.is_some() {
            len += 1;
        }
        if self.grow_end_time.is_some() {
            len += 1;
        }
        if self.pollinate_begin_time.is_some() {
            len += 1;
        }
        if self.pollinate_end_time.is_some() {
            len += 1;
        }
        if self.harvest_begin_time.is_some() {
            len += 1;
        }
        if self.harvest_end_time.is_some() {
            len += 1;
        }
        if self.is_end.is_some() {
            len += 1;
        }
        if self.flower_instance.is_some() {
            len += 1;
        }
        if self.next_segment_index.is_some() {
            len += 1;
        }
        if !self.records.is_empty() {
            len += 1;
        }
        if !self.fertilizes.is_empty() {
            len += 1;
        }
        if self.pollen_instance.is_some() {
            len += 1;
        }
        if !self.pick_up_players.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.StructureFarmlandInfo", len)?;
        if let Some(v) = self.operator_char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("OperatorCharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.seed_instance.as_ref() {
            struct_ser.serialize_field("SeedInstance", v)?;
        }
        if let Some(v) = self.need_water.as_ref() {
            struct_ser.serialize_field("NeedWater", v)?;
        }
        if let Some(v) = self.farmland_state.as_ref() {
            let v = EFarmlandState::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("FarmlandState", &v)?;
        }
        if let Some(v) = self.seeding_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SeedingTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.grow_end_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("GrowEndTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.pollinate_begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("PollinateBeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.pollinate_end_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("PollinateEndTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.harvest_begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HarvestBeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.harvest_end_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HarvestEndTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.is_end.as_ref() {
            struct_ser.serialize_field("IsEnd", v)?;
        }
        if let Some(v) = self.flower_instance.as_ref() {
            struct_ser.serialize_field("FlowerInstance", v)?;
        }
        if let Some(v) = self.next_segment_index.as_ref() {
            struct_ser.serialize_field("NextSegmentIndex", v)?;
        }
        if !self.records.is_empty() {
            struct_ser.serialize_field("Records", &self.records)?;
        }
        if !self.fertilizes.is_empty() {
            struct_ser.serialize_field("Fertilizes", &self.fertilizes)?;
        }
        if let Some(v) = self.pollen_instance.as_ref() {
            struct_ser.serialize_field("PollenInstance", v)?;
        }
        if !self.pick_up_players.is_empty() {
            struct_ser.serialize_field("PickUpPlayers", &self.pick_up_players)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StructureFarmlandInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OperatorCharId",
            "SeedInstance",
            "NeedWater",
            "FarmlandState",
            "SeedingTime",
            "GrowEndTime",
            "PollinateBeginTime",
            "PollinateEndTime",
            "HarvestBeginTime",
            "HarvestEndTime",
            "IsEnd",
            "FlowerInstance",
            "NextSegmentIndex",
            "Records",
            "Fertilizes",
            "PollenInstance",
            "PickUpPlayers",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OperatorCharId,
            SeedInstance,
            NeedWater,
            FarmlandState,
            SeedingTime,
            GrowEndTime,
            PollinateBeginTime,
            PollinateEndTime,
            HarvestBeginTime,
            HarvestEndTime,
            IsEnd,
            FlowerInstance,
            NextSegmentIndex,
            Records,
            Fertilizes,
            PollenInstance,
            PickUpPlayers,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "OperatorCharId" => Ok(GeneratedField::OperatorCharId),
                            "SeedInstance" => Ok(GeneratedField::SeedInstance),
                            "NeedWater" => Ok(GeneratedField::NeedWater),
                            "FarmlandState" => Ok(GeneratedField::FarmlandState),
                            "SeedingTime" => Ok(GeneratedField::SeedingTime),
                            "GrowEndTime" => Ok(GeneratedField::GrowEndTime),
                            "PollinateBeginTime" => Ok(GeneratedField::PollinateBeginTime),
                            "PollinateEndTime" => Ok(GeneratedField::PollinateEndTime),
                            "HarvestBeginTime" => Ok(GeneratedField::HarvestBeginTime),
                            "HarvestEndTime" => Ok(GeneratedField::HarvestEndTime),
                            "IsEnd" => Ok(GeneratedField::IsEnd),
                            "FlowerInstance" => Ok(GeneratedField::FlowerInstance),
                            "NextSegmentIndex" => Ok(GeneratedField::NextSegmentIndex),
                            "Records" => Ok(GeneratedField::Records),
                            "Fertilizes" => Ok(GeneratedField::Fertilizes),
                            "PollenInstance" => Ok(GeneratedField::PollenInstance),
                            "PickUpPlayers" => Ok(GeneratedField::PickUpPlayers),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StructureFarmlandInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.StructureFarmlandInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StructureFarmlandInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut operator_char_id__ = None;
                let mut seed_instance__ = None;
                let mut need_water__ = None;
                let mut farmland_state__ = None;
                let mut seeding_time__ = None;
                let mut grow_end_time__ = None;
                let mut pollinate_begin_time__ = None;
                let mut pollinate_end_time__ = None;
                let mut harvest_begin_time__ = None;
                let mut harvest_end_time__ = None;
                let mut is_end__ = None;
                let mut flower_instance__ = None;
                let mut next_segment_index__ = None;
                let mut records__ = None;
                let mut fertilizes__ = None;
                let mut pollen_instance__ = None;
                let mut pick_up_players__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OperatorCharId => {
                            if operator_char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OperatorCharId"));
                            }
                            operator_char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SeedInstance => {
                            if seed_instance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeedInstance"));
                            }
                            seed_instance__ = map_.next_value()?;
                        }
                        GeneratedField::NeedWater => {
                            if need_water__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NeedWater"));
                            }
                            need_water__ = map_.next_value()?;
                        }
                        GeneratedField::FarmlandState => {
                            if farmland_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FarmlandState"));
                            }
                            farmland_state__ = map_.next_value::<::std::option::Option<EFarmlandState>>()?.map(|x| x as i32);
                        }
                        GeneratedField::SeedingTime => {
                            if seeding_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeedingTime"));
                            }
                            seeding_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GrowEndTime => {
                            if grow_end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GrowEndTime"));
                            }
                            grow_end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PollinateBeginTime => {
                            if pollinate_begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PollinateBeginTime"));
                            }
                            pollinate_begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PollinateEndTime => {
                            if pollinate_end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PollinateEndTime"));
                            }
                            pollinate_end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HarvestBeginTime => {
                            if harvest_begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HarvestBeginTime"));
                            }
                            harvest_begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HarvestEndTime => {
                            if harvest_end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HarvestEndTime"));
                            }
                            harvest_end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsEnd => {
                            if is_end__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsEnd"));
                            }
                            is_end__ = map_.next_value()?;
                        }
                        GeneratedField::FlowerInstance => {
                            if flower_instance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FlowerInstance"));
                            }
                            flower_instance__ = map_.next_value()?;
                        }
                        GeneratedField::NextSegmentIndex => {
                            if next_segment_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NextSegmentIndex"));
                            }
                            next_segment_index__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Records => {
                            if records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Records"));
                            }
                            records__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Fertilizes => {
                            if fertilizes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Fertilizes"));
                            }
                            fertilizes__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::PollenInstance => {
                            if pollen_instance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PollenInstance"));
                            }
                            pollen_instance__ = map_.next_value()?;
                        }
                        GeneratedField::PickUpPlayers => {
                            if pick_up_players__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PickUpPlayers"));
                            }
                            pick_up_players__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(StructureFarmlandInfo {
                    operator_char_id: operator_char_id__,
                    seed_instance: seed_instance__,
                    need_water: need_water__,
                    farmland_state: farmland_state__,
                    seeding_time: seeding_time__,
                    grow_end_time: grow_end_time__,
                    pollinate_begin_time: pollinate_begin_time__,
                    pollinate_end_time: pollinate_end_time__,
                    harvest_begin_time: harvest_begin_time__,
                    harvest_end_time: harvest_end_time__,
                    is_end: is_end__,
                    flower_instance: flower_instance__,
                    next_segment_index: next_segment_index__,
                    records: records__.unwrap_or_default(),
                    fertilizes: fertilizes__.unwrap_or_default(),
                    pollen_instance: pollen_instance__,
                    pick_up_players: pick_up_players__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.StructureFarmlandInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StructureLamplightInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.StructureLamplightInfo", len)?;
        if let Some(v) = self.state.as_ref() {
            let v = EHomelandLamplightState::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("State", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StructureLamplightInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "State",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "State" => Ok(GeneratedField::State),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StructureLamplightInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.StructureLamplightInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StructureLamplightInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("State"));
                            }
                            state__ = map_.next_value::<::std::option::Option<EHomelandLamplightState>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(StructureLamplightInfo {
                    state: state__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.StructureLamplightInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StructureMaterialInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.material_id.is_some() {
            len += 1;
        }
        if self.char_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.StructureMaterialInfo", len)?;
        if let Some(v) = self.material_id.as_ref() {
            struct_ser.serialize_field("MaterialId", v)?;
        }
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StructureMaterialInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "MaterialId",
            "CharId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MaterialId,
            CharId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "MaterialId" => Ok(GeneratedField::MaterialId),
                            "CharId" => Ok(GeneratedField::CharId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StructureMaterialInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.StructureMaterialInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StructureMaterialInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut material_id__ = None;
                let mut char_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MaterialId => {
                            if material_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaterialId"));
                            }
                            material_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(StructureMaterialInfo {
                    material_id: material_id__,
                    char_id: char_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.StructureMaterialInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StructureOp {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.op_type.is_some() {
            len += 1;
        }
        if self.structure.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.StructureOp", len)?;
        if let Some(v) = self.op_type.as_ref() {
            let v = StructureOpType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("OpType", &v)?;
        }
        if let Some(v) = self.structure.as_ref() {
            struct_ser.serialize_field("Structure", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StructureOp {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OpType",
            "Structure",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OpType,
            Structure,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "OpType" => Ok(GeneratedField::OpType),
                            "Structure" => Ok(GeneratedField::Structure),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StructureOp;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.StructureOp")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StructureOp, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut op_type__ = None;
                let mut structure__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OpType => {
                            if op_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OpType"));
                            }
                            op_type__ = map_.next_value::<::std::option::Option<StructureOpType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Structure => {
                            if structure__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Structure"));
                            }
                            structure__ = map_.next_value()?;
                        }
                    }
                }
                Ok(StructureOp {
                    op_type: op_type__,
                    structure: structure__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.StructureOp", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StructureOpType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Add => "StructureOpTypeAdd",
            Self::Update => "StructureOpTypeUpdate",
            Self::Delete => "StructureOpTypeDelete",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for StructureOpType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "StructureOpTypeAdd",
            "StructureOpTypeUpdate",
            "StructureOpTypeDelete",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StructureOpType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "StructureOpTypeAdd" => Ok(StructureOpType::Add),
                    "StructureOpTypeUpdate" => Ok(StructureOpType::Update),
                    "StructureOpTypeDelete" => Ok(StructureOpType::Delete),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SwitchSceneRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.transfer_param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SwitchSceneRequest", len)?;
        if let Some(v) = self.transfer_param.as_ref() {
            struct_ser.serialize_field("TransferParam", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SwitchSceneRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TransferParam",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TransferParam,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TransferParam" => Ok(GeneratedField::TransferParam),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SwitchSceneRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SwitchSceneRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SwitchSceneRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transfer_param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TransferParam => {
                            if transfer_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TransferParam"));
                            }
                            transfer_param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SwitchSceneRequest {
                    transfer_param: transfer_param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SwitchSceneRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SwitchSceneResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.transfer_param.is_some() {
            len += 1;
        }
        if self.err_code.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SwitchSceneResponse", len)?;
        if let Some(v) = self.transfer_param.as_ref() {
            struct_ser.serialize_field("TransferParam", v)?;
        }
        if let Some(v) = self.err_code.as_ref() {
            let v = EErrorCode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("ErrCode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SwitchSceneResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TransferParam",
            "ErrCode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TransferParam,
            ErrCode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TransferParam" => Ok(GeneratedField::TransferParam),
                            "ErrCode" => Ok(GeneratedField::ErrCode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SwitchSceneResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SwitchSceneResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SwitchSceneResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transfer_param__ = None;
                let mut err_code__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TransferParam => {
                            if transfer_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TransferParam"));
                            }
                            transfer_param__ = map_.next_value()?;
                        }
                        GeneratedField::ErrCode => {
                            if err_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ErrCode"));
                            }
                            err_code__ = map_.next_value::<::std::option::Option<EErrorCode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(SwitchSceneResponse {
                    transfer_param: transfer_param__,
                    err_code: err_code__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SwitchSceneResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncAllServerStateObject {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_object.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncAllServerStateObject", len)?;
        if let Some(v) = self.v_object.as_ref() {
            struct_ser.serialize_field("VObject", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncAllServerStateObject {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VObject",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VObject,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VObject" => Ok(GeneratedField::VObject),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncAllServerStateObject;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncAllServerStateObject")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncAllServerStateObject, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_object__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VObject => {
                            if v_object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VObject"));
                            }
                            v_object__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncAllServerStateObject {
                    v_object: v_object__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncAllServerStateObject", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncAwardData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.level_up_award_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncAwardData", len)?;
        if !self.level_up_award_infos.is_empty() {
            struct_ser.serialize_field("LevelUpAwardInfos", &self.level_up_award_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncAwardData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LevelUpAwardInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LevelUpAwardInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LevelUpAwardInfos" => Ok(GeneratedField::LevelUpAwardInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncAwardData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncAwardData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncAwardData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut level_up_award_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LevelUpAwardInfos => {
                            if level_up_award_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LevelUpAwardInfos"));
                            }
                            level_up_award_infos__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(SyncAwardData {
                    level_up_award_infos: level_up_award_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncAwardData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncBulletHitInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.hit_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncBulletHitInfo", len)?;
        if !self.hit_infos.is_empty() {
            struct_ser.serialize_field("HitInfos", &self.hit_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncBulletHitInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HitInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HitInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "HitInfos" => Ok(GeneratedField::HitInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncBulletHitInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncBulletHitInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncBulletHitInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut hit_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HitInfos => {
                            if hit_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HitInfos"));
                            }
                            hit_infos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SyncBulletHitInfo {
                    hit_infos: hit_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncBulletHitInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncCirclePathLength {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.path_length.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncCirclePathLength", len)?;
        if let Some(v) = self.path_length.as_ref() {
            struct_ser.serialize_field("PathLength", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncCirclePathLength {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PathLength",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PathLength,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PathLength" => Ok(GeneratedField::PathLength),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncCirclePathLength;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncCirclePathLength")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncCirclePathLength, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut path_length__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PathLength => {
                            if path_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PathLength"));
                            }
                            path_length__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SyncCirclePathLength {
                    path_length: path_length__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncCirclePathLength", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncClientUseSkill {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_target_uuid.is_some() {
            len += 1;
        }
        if self.skill_level_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncClientUseSkill", len)?;
        if let Some(v) = self.skill_target_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SkillTargetUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.skill_level_id.as_ref() {
            struct_ser.serialize_field("SkillLevelId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncClientUseSkill {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillTargetUuid",
            "SkillLevelId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillTargetUuid,
            SkillLevelId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillTargetUuid" => Ok(GeneratedField::SkillTargetUuid),
                            "SkillLevelId" => Ok(GeneratedField::SkillLevelId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncClientUseSkill;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncClientUseSkill")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncClientUseSkill, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_target_uuid__ = None;
                let mut skill_level_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillTargetUuid => {
                            if skill_target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillTargetUuid"));
                            }
                            skill_target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillLevelId => {
                            if skill_level_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillLevelId"));
                            }
                            skill_level_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SyncClientUseSkill {
                    skill_target_uuid: skill_target_uuid__,
                    skill_level_id: skill_level_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncClientUseSkill", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncContainerData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncContainerData", len)?;
        if let Some(v) = self.v_data.as_ref() {
            struct_ser.serialize_field("VData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncContainerData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VData" => Ok(GeneratedField::VData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncContainerData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncContainerData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncContainerData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VData => {
                            if v_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VData"));
                            }
                            v_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncContainerData {
                    v_data: v_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncContainerData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncContainerDirtyData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncContainerDirtyData", len)?;
        if let Some(v) = self.v_data.as_ref() {
            struct_ser.serialize_field("VData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncContainerDirtyData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VData" => Ok(GeneratedField::VData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncContainerDirtyData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncContainerDirtyData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncContainerDirtyData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VData => {
                            if v_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VData"));
                            }
                            v_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncContainerDirtyData {
                    v_data: v_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncContainerDirtyData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncDamageInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.damage_source.is_some() {
            len += 1;
        }
        if self.is_miss.is_some() {
            len += 1;
        }
        if self.is_crit.is_some() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        if self.type_flag.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        if self.actual_value.is_some() {
            len += 1;
        }
        if self.lucky_value.is_some() {
            len += 1;
        }
        if self.hp_lessen_value.is_some() {
            len += 1;
        }
        if self.shield_lessen_value.is_some() {
            len += 1;
        }
        if self.attacker_uuid.is_some() {
            len += 1;
        }
        if self.owner_id.is_some() {
            len += 1;
        }
        if self.owner_level.is_some() {
            len += 1;
        }
        if self.owner_stage.is_some() {
            len += 1;
        }
        if self.hit_event_id.is_some() {
            len += 1;
        }
        if self.is_normal.is_some() {
            len += 1;
        }
        if self.is_dead.is_some() {
            len += 1;
        }
        if self.property.is_some() {
            len += 1;
        }
        if self.damage_pos.is_some() {
            len += 1;
        }
        if !self.part_infos.is_empty() {
            len += 1;
        }
        if self.top_summoner_id.is_some() {
            len += 1;
        }
        if self.damage_weight.is_some() {
            len += 1;
        }
        if self.passive_uuid.is_some() {
            len += 1;
        }
        if self.is_rainbow.is_some() {
            len += 1;
        }
        if self.damage_mode.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncDamageInfo", len)?;
        if let Some(v) = self.damage_source.as_ref() {
            let v = EDamageSource::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("DamageSource", &v)?;
        }
        if let Some(v) = self.is_miss.as_ref() {
            struct_ser.serialize_field("IsMiss", v)?;
        }
        if let Some(v) = self.is_crit.as_ref() {
            struct_ser.serialize_field("IsCrit", v)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            let v = EDamageType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Type", &v)?;
        }
        if let Some(v) = self.type_flag.as_ref() {
            struct_ser.serialize_field("TypeFlag", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Value", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.actual_value.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ActualValue", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.lucky_value.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LuckyValue", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.hp_lessen_value.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HpLessenValue", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.shield_lessen_value.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ShieldLessenValue", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.attacker_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("AttackerUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.owner_id.as_ref() {
            struct_ser.serialize_field("OwnerId", v)?;
        }
        if let Some(v) = self.owner_level.as_ref() {
            struct_ser.serialize_field("OwnerLevel", v)?;
        }
        if let Some(v) = self.owner_stage.as_ref() {
            struct_ser.serialize_field("OwnerStage", v)?;
        }
        if let Some(v) = self.hit_event_id.as_ref() {
            struct_ser.serialize_field("HitEventId", v)?;
        }
        if let Some(v) = self.is_normal.as_ref() {
            struct_ser.serialize_field("IsNormal", v)?;
        }
        if let Some(v) = self.is_dead.as_ref() {
            struct_ser.serialize_field("IsDead", v)?;
        }
        if let Some(v) = self.property.as_ref() {
            let v = EDamageProperty::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Property", &v)?;
        }
        if let Some(v) = self.damage_pos.as_ref() {
            struct_ser.serialize_field("DamagePos", v)?;
        }
        if !self.part_infos.is_empty() {
            struct_ser.serialize_field("PartInfos", &self.part_infos)?;
        }
        if let Some(v) = self.top_summoner_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TopSummonerId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.damage_weight.as_ref() {
            struct_ser.serialize_field("DamageWeight", v)?;
        }
        if let Some(v) = self.passive_uuid.as_ref() {
            struct_ser.serialize_field("PassiveUuid", v)?;
        }
        if let Some(v) = self.is_rainbow.as_ref() {
            struct_ser.serialize_field("IsRainbow", v)?;
        }
        if let Some(v) = self.damage_mode.as_ref() {
            let v = EDamageMode::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("DamageMode", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncDamageInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DamageSource",
            "IsMiss",
            "IsCrit",
            "Type",
            "TypeFlag",
            "Value",
            "ActualValue",
            "LuckyValue",
            "HpLessenValue",
            "ShieldLessenValue",
            "AttackerUuid",
            "OwnerId",
            "OwnerLevel",
            "OwnerStage",
            "HitEventId",
            "IsNormal",
            "IsDead",
            "Property",
            "DamagePos",
            "PartInfos",
            "TopSummonerId",
            "DamageWeight",
            "PassiveUuid",
            "IsRainbow",
            "DamageMode",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DamageSource,
            IsMiss,
            IsCrit,
            Type,
            TypeFlag,
            Value,
            ActualValue,
            LuckyValue,
            HpLessenValue,
            ShieldLessenValue,
            AttackerUuid,
            OwnerId,
            OwnerLevel,
            OwnerStage,
            HitEventId,
            IsNormal,
            IsDead,
            Property,
            DamagePos,
            PartInfos,
            TopSummonerId,
            DamageWeight,
            PassiveUuid,
            IsRainbow,
            DamageMode,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DamageSource" => Ok(GeneratedField::DamageSource),
                            "IsMiss" => Ok(GeneratedField::IsMiss),
                            "IsCrit" => Ok(GeneratedField::IsCrit),
                            "Type" => Ok(GeneratedField::Type),
                            "TypeFlag" => Ok(GeneratedField::TypeFlag),
                            "Value" => Ok(GeneratedField::Value),
                            "ActualValue" => Ok(GeneratedField::ActualValue),
                            "LuckyValue" => Ok(GeneratedField::LuckyValue),
                            "HpLessenValue" => Ok(GeneratedField::HpLessenValue),
                            "ShieldLessenValue" => Ok(GeneratedField::ShieldLessenValue),
                            "AttackerUuid" => Ok(GeneratedField::AttackerUuid),
                            "OwnerId" => Ok(GeneratedField::OwnerId),
                            "OwnerLevel" => Ok(GeneratedField::OwnerLevel),
                            "OwnerStage" => Ok(GeneratedField::OwnerStage),
                            "HitEventId" => Ok(GeneratedField::HitEventId),
                            "IsNormal" => Ok(GeneratedField::IsNormal),
                            "IsDead" => Ok(GeneratedField::IsDead),
                            "Property" => Ok(GeneratedField::Property),
                            "DamagePos" => Ok(GeneratedField::DamagePos),
                            "PartInfos" => Ok(GeneratedField::PartInfos),
                            "TopSummonerId" => Ok(GeneratedField::TopSummonerId),
                            "DamageWeight" => Ok(GeneratedField::DamageWeight),
                            "PassiveUuid" => Ok(GeneratedField::PassiveUuid),
                            "IsRainbow" => Ok(GeneratedField::IsRainbow),
                            "DamageMode" => Ok(GeneratedField::DamageMode),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncDamageInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncDamageInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncDamageInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut damage_source__ = None;
                let mut is_miss__ = None;
                let mut is_crit__ = None;
                let mut r#type__ = None;
                let mut type_flag__ = None;
                let mut value__ = None;
                let mut actual_value__ = None;
                let mut lucky_value__ = None;
                let mut hp_lessen_value__ = None;
                let mut shield_lessen_value__ = None;
                let mut attacker_uuid__ = None;
                let mut owner_id__ = None;
                let mut owner_level__ = None;
                let mut owner_stage__ = None;
                let mut hit_event_id__ = None;
                let mut is_normal__ = None;
                let mut is_dead__ = None;
                let mut property__ = None;
                let mut damage_pos__ = None;
                let mut part_infos__ = None;
                let mut top_summoner_id__ = None;
                let mut damage_weight__ = None;
                let mut passive_uuid__ = None;
                let mut is_rainbow__ = None;
                let mut damage_mode__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DamageSource => {
                            if damage_source__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DamageSource"));
                            }
                            damage_source__ = map_.next_value::<::std::option::Option<EDamageSource>>()?.map(|x| x as i32);
                        }
                        GeneratedField::IsMiss => {
                            if is_miss__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsMiss"));
                            }
                            is_miss__ = map_.next_value()?;
                        }
                        GeneratedField::IsCrit => {
                            if is_crit__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsCrit"));
                            }
                            is_crit__ = map_.next_value()?;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<EDamageType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::TypeFlag => {
                            if type_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TypeFlag"));
                            }
                            type_flag__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Value"));
                            }
                            value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ActualValue => {
                            if actual_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActualValue"));
                            }
                            actual_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LuckyValue => {
                            if lucky_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LuckyValue"));
                            }
                            lucky_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HpLessenValue => {
                            if hp_lessen_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HpLessenValue"));
                            }
                            hp_lessen_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ShieldLessenValue => {
                            if shield_lessen_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShieldLessenValue"));
                            }
                            shield_lessen_value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AttackerUuid => {
                            if attacker_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AttackerUuid"));
                            }
                            attacker_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OwnerId => {
                            if owner_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OwnerId"));
                            }
                            owner_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OwnerLevel => {
                            if owner_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OwnerLevel"));
                            }
                            owner_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OwnerStage => {
                            if owner_stage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OwnerStage"));
                            }
                            owner_stage__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HitEventId => {
                            if hit_event_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HitEventId"));
                            }
                            hit_event_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsNormal => {
                            if is_normal__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsNormal"));
                            }
                            is_normal__ = map_.next_value()?;
                        }
                        GeneratedField::IsDead => {
                            if is_dead__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsDead"));
                            }
                            is_dead__ = map_.next_value()?;
                        }
                        GeneratedField::Property => {
                            if property__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Property"));
                            }
                            property__ = map_.next_value::<::std::option::Option<EDamageProperty>>()?.map(|x| x as i32);
                        }
                        GeneratedField::DamagePos => {
                            if damage_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DamagePos"));
                            }
                            damage_pos__ = map_.next_value()?;
                        }
                        GeneratedField::PartInfos => {
                            if part_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PartInfos"));
                            }
                            part_infos__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TopSummonerId => {
                            if top_summoner_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TopSummonerId"));
                            }
                            top_summoner_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DamageWeight => {
                            if damage_weight__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DamageWeight"));
                            }
                            damage_weight__ = map_.next_value()?;
                        }
                        GeneratedField::PassiveUuid => {
                            if passive_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PassiveUuid"));
                            }
                            passive_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsRainbow => {
                            if is_rainbow__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsRainbow"));
                            }
                            is_rainbow__ = map_.next_value()?;
                        }
                        GeneratedField::DamageMode => {
                            if damage_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DamageMode"));
                            }
                            damage_mode__ = map_.next_value::<::std::option::Option<EDamageMode>>()?.map(|x| x as i32);
                        }
                    }
                }
                Ok(SyncDamageInfo {
                    damage_source: damage_source__,
                    is_miss: is_miss__,
                    is_crit: is_crit__,
                    r#type: r#type__,
                    type_flag: type_flag__,
                    value: value__,
                    actual_value: actual_value__,
                    lucky_value: lucky_value__,
                    hp_lessen_value: hp_lessen_value__,
                    shield_lessen_value: shield_lessen_value__,
                    attacker_uuid: attacker_uuid__,
                    owner_id: owner_id__,
                    owner_level: owner_level__,
                    owner_stage: owner_stage__,
                    hit_event_id: hit_event_id__,
                    is_normal: is_normal__,
                    is_dead: is_dead__,
                    property: property__,
                    damage_pos: damage_pos__,
                    part_infos: part_infos__.unwrap_or_default(),
                    top_summoner_id: top_summoner_id__,
                    damage_weight: damage_weight__,
                    passive_uuid: passive_uuid__,
                    is_rainbow: is_rainbow__,
                    damage_mode: damage_mode__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncDamageInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncDirWhenAiming {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.dir.is_some() {
            len += 1;
        }
        if self.aim_dir.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncDirWhenAiming", len)?;
        if let Some(v) = self.dir.as_ref() {
            struct_ser.serialize_field("Dir", v)?;
        }
        if let Some(v) = self.aim_dir.as_ref() {
            struct_ser.serialize_field("AimDir", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncDirWhenAiming {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Dir",
            "AimDir",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Dir,
            AimDir,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Dir" => Ok(GeneratedField::Dir),
                            "AimDir" => Ok(GeneratedField::AimDir),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncDirWhenAiming;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncDirWhenAiming")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncDirWhenAiming, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dir__ = None;
                let mut aim_dir__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Dir => {
                            if dir__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Dir"));
                            }
                            dir__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AimDir => {
                            if aim_dir__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AimDir"));
                            }
                            aim_dir__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SyncDirWhenAiming {
                    dir: dir__,
                    aim_dir: aim_dir__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncDirWhenAiming", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncDungeonData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncDungeonData", len)?;
        if let Some(v) = self.v_data.as_ref() {
            struct_ser.serialize_field("VData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncDungeonData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VData" => Ok(GeneratedField::VData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncDungeonData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncDungeonData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncDungeonData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VData => {
                            if v_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VData"));
                            }
                            v_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncDungeonData {
                    v_data: v_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncDungeonData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncDungeonDirtyData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncDungeonDirtyData", len)?;
        if let Some(v) = self.v_data.as_ref() {
            struct_ser.serialize_field("VData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncDungeonDirtyData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VData" => Ok(GeneratedField::VData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncDungeonDirtyData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncDungeonDirtyData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncDungeonDirtyData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VData => {
                            if v_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VData"));
                            }
                            v_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncDungeonDirtyData {
                    v_data: v_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncDungeonDirtyData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncEntityBehaviorTree {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.entity_id.is_some() {
            len += 1;
        }
        if self.json.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncEntityBehaviorTree", len)?;
        if let Some(v) = self.entity_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("EntityId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.json.as_ref() {
            struct_ser.serialize_field("Json", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncEntityBehaviorTree {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EntityId",
            "Json",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EntityId,
            Json,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EntityId" => Ok(GeneratedField::EntityId),
                            "Json" => Ok(GeneratedField::Json),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncEntityBehaviorTree;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncEntityBehaviorTree")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncEntityBehaviorTree, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut entity_id__ = None;
                let mut json__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EntityId => {
                            if entity_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EntityId"));
                            }
                            entity_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Json => {
                            if json__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Json"));
                            }
                            json__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncEntityBehaviorTree {
                    entity_id: entity_id__,
                    json: json__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncEntityBehaviorTree", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncFakeBulletHitInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.hit_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncFakeBulletHitInfo", len)?;
        if !self.hit_infos.is_empty() {
            struct_ser.serialize_field("HitInfos", &self.hit_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncFakeBulletHitInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HitInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HitInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "HitInfos" => Ok(GeneratedField::HitInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncFakeBulletHitInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncFakeBulletHitInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncFakeBulletHitInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut hit_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HitInfos => {
                            if hit_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HitInfos"));
                            }
                            hit_infos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SyncFakeBulletHitInfo {
                    hit_infos: hit_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncFakeBulletHitInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncFieldOfView {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.json.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncFieldOfView", len)?;
        if let Some(v) = self.json.as_ref() {
            struct_ser.serialize_field("Json", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncFieldOfView {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Json",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Json,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Json" => Ok(GeneratedField::Json),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncFieldOfView;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncFieldOfView")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncFieldOfView, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut json__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Json => {
                            if json__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Json"));
                            }
                            json__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncFieldOfView {
                    json: json__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncFieldOfView", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncHitInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.hit_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncHitInfo", len)?;
        if !self.hit_infos.is_empty() {
            struct_ser.serialize_field("HitInfos", &self.hit_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncHitInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HitInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HitInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "HitInfos" => Ok(GeneratedField::HitInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncHitInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncHitInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncHitInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut hit_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HitInfos => {
                            if hit_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HitInfos"));
                            }
                            hit_infos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SyncHitInfo {
                    hit_infos: hit_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncHitInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncLog {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.log.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncLog", len)?;
        if let Some(v) = self.log.as_ref() {
            struct_ser.serialize_field("Log", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncLog {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Log",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Log,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Log" => Ok(GeneratedField::Log),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncLog;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncLog")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncLog, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut log__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Log => {
                            if log__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Log"));
                            }
                            log__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncLog {
                    log: log__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncLog", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncNearDeltaInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.delta_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncNearDeltaInfo", len)?;
        if !self.delta_infos.is_empty() {
            struct_ser.serialize_field("DeltaInfos", &self.delta_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncNearDeltaInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DeltaInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeltaInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DeltaInfos" => Ok(GeneratedField::DeltaInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncNearDeltaInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncNearDeltaInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncNearDeltaInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut delta_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeltaInfos => {
                            if delta_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DeltaInfos"));
                            }
                            delta_infos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SyncNearDeltaInfo {
                    delta_infos: delta_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncNearDeltaInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncNearEntities {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.appear.is_empty() {
            len += 1;
        }
        if !self.disappear.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncNearEntities", len)?;
        if !self.appear.is_empty() {
            struct_ser.serialize_field("Appear", &self.appear)?;
        }
        if !self.disappear.is_empty() {
            struct_ser.serialize_field("Disappear", &self.disappear)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncNearEntities {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Appear",
            "Disappear",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Appear,
            Disappear,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Appear" => Ok(GeneratedField::Appear),
                            "Disappear" => Ok(GeneratedField::Disappear),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncNearEntities;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncNearEntities")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncNearEntities, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut appear__ = None;
                let mut disappear__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Appear => {
                            if appear__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Appear"));
                            }
                            appear__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Disappear => {
                            if disappear__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Disappear"));
                            }
                            disappear__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SyncNearEntities {
                    appear: appear__.unwrap_or_default(),
                    disappear: disappear__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncNearEntities", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncPathNode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.entity_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncPathNode", len)?;
        if let Some(v) = self.entity_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("EntityId", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncPathNode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EntityId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EntityId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EntityId" => Ok(GeneratedField::EntityId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncPathNode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncPathNode")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncPathNode, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut entity_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EntityId => {
                            if entity_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EntityId"));
                            }
                            entity_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SyncPathNode {
                    entity_id: entity_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncPathNode", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncPersonalObject {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_datas.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncPersonalObject", len)?;
        if let Some(v) = self.v_datas.as_ref() {
            struct_ser.serialize_field("VDatas", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncPersonalObject {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VDatas",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VDatas,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VDatas" => Ok(GeneratedField::VDatas),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncPersonalObject;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncPersonalObject")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncPersonalObject, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_datas__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VDatas => {
                            if v_datas__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VDatas"));
                            }
                            v_datas__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncPersonalObject {
                    v_datas: v_datas__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncPersonalObject", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncPlayCameraAnimation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncPlayCameraAnimation", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncPlayCameraAnimation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncPlayCameraAnimation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncPlayCameraAnimation")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncPlayCameraAnimation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SyncPlayCameraAnimation {
                    id: id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncPlayCameraAnimation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncSceneArea {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scene_area_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncSceneArea", len)?;
        if let Some(v) = self.scene_area_id.as_ref() {
            struct_ser.serialize_field("SceneAreaId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncSceneArea {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SceneAreaId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SceneAreaId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SceneAreaId" => Ok(GeneratedField::SceneAreaId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncSceneArea;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncSceneArea")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncSceneArea, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_area_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SceneAreaId => {
                            if scene_area_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneAreaId"));
                            }
                            scene_area_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SyncSceneArea {
                    scene_area_id: scene_area_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncSceneArea", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncSceneAttrs {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.attrs.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncSceneAttrs", len)?;
        if let Some(v) = self.attrs.as_ref() {
            struct_ser.serialize_field("Attrs", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncSceneAttrs {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Attrs",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Attrs,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Attrs" => Ok(GeneratedField::Attrs),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncSceneAttrs;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncSceneAttrs")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncSceneAttrs, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut attrs__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Attrs => {
                            if attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Attrs"));
                            }
                            attrs__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncSceneAttrs {
                    attrs: attrs__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncSceneAttrs", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncSceneEvents {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.evt.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncSceneEvents", len)?;
        if let Some(v) = self.evt.as_ref() {
            struct_ser.serialize_field("Evt", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncSceneEvents {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Evt",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Evt,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Evt" => Ok(GeneratedField::Evt),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncSceneEvents;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncSceneEvents")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncSceneEvents, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut evt__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Evt => {
                            if evt__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Evt"));
                            }
                            evt__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncSceneEvents {
                    evt: evt__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncSceneEvents", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncServerData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.server_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncServerData", len)?;
        if let Some(v) = self.server_data.as_ref() {
            struct_ser.serialize_field("ServerData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncServerData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ServerData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ServerData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ServerData" => Ok(GeneratedField::ServerData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncServerData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncServerData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncServerData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut server_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ServerData => {
                            if server_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ServerData"));
                            }
                            server_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncServerData {
                    server_data: server_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncServerData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncServerSkillEnd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncServerSkillEnd", len)?;
        if let Some(v) = self.skill_uuid.as_ref() {
            struct_ser.serialize_field("SkillUuid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncServerSkillEnd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillUuid" => Ok(GeneratedField::SkillUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncServerSkillEnd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncServerSkillEnd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncServerSkillEnd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillUuid => {
                            if skill_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillUuid"));
                            }
                            skill_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SyncServerSkillEnd {
                    skill_uuid: skill_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncServerSkillEnd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncServerSkillSingingTimeSub {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_uuid.is_some() {
            len += 1;
        }
        if self.time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncServerSkillSingingTimeSub", len)?;
        if let Some(v) = self.skill_uuid.as_ref() {
            struct_ser.serialize_field("SkillUuid", v)?;
        }
        if let Some(v) = self.time.as_ref() {
            struct_ser.serialize_field("Time", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncServerSkillSingingTimeSub {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillUuid",
            "Time",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillUuid,
            Time,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillUuid" => Ok(GeneratedField::SkillUuid),
                            "Time" => Ok(GeneratedField::Time),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncServerSkillSingingTimeSub;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncServerSkillSingingTimeSub")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncServerSkillSingingTimeSub, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_uuid__ = None;
                let mut time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillUuid => {
                            if skill_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillUuid"));
                            }
                            skill_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Time"));
                            }
                            time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SyncServerSkillSingingTimeSub {
                    skill_uuid: skill_uuid__,
                    time: time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncServerSkillSingingTimeSub", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncServerSkillStageEnd {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_stage_end_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncServerSkillStageEnd", len)?;
        if let Some(v) = self.skill_stage_end_info.as_ref() {
            struct_ser.serialize_field("SkillStageEndInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncServerSkillStageEnd {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillStageEndInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillStageEndInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillStageEndInfo" => Ok(GeneratedField::SkillStageEndInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncServerSkillStageEnd;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncServerSkillStageEnd")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncServerSkillStageEnd, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_stage_end_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillStageEndInfo => {
                            if skill_stage_end_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillStageEndInfo"));
                            }
                            skill_stage_end_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncServerSkillStageEnd {
                    skill_stage_end_info: skill_stage_end_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncServerSkillStageEnd", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncServerTime {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.client_milliseconds.is_some() {
            len += 1;
        }
        if self.server_milliseconds.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncServerTime", len)?;
        if let Some(v) = self.client_milliseconds.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ClientMilliseconds", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.server_milliseconds.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ServerMilliseconds", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncServerTime {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ClientMilliseconds",
            "ServerMilliseconds",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ClientMilliseconds,
            ServerMilliseconds,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ClientMilliseconds" => Ok(GeneratedField::ClientMilliseconds),
                            "ServerMilliseconds" => Ok(GeneratedField::ServerMilliseconds),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncServerTime;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncServerTime")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncServerTime, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut client_milliseconds__ = None;
                let mut server_milliseconds__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ClientMilliseconds => {
                            if client_milliseconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ClientMilliseconds"));
                            }
                            client_milliseconds__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ServerMilliseconds => {
                            if server_milliseconds__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ServerMilliseconds"));
                            }
                            server_milliseconds__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SyncServerTime {
                    client_milliseconds: client_milliseconds__,
                    server_milliseconds: server_milliseconds__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncServerTime", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncSkillLocation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_uuid.is_some() {
            len += 1;
        }
        if self.skill_stage.is_some() {
            len += 1;
        }
        if self.cur_pos.is_some() {
            len += 1;
        }
        if self.dest_pos.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncSkillLocation", len)?;
        if let Some(v) = self.skill_uuid.as_ref() {
            struct_ser.serialize_field("SkillUuid", v)?;
        }
        if let Some(v) = self.skill_stage.as_ref() {
            struct_ser.serialize_field("SkillStage", v)?;
        }
        if let Some(v) = self.cur_pos.as_ref() {
            struct_ser.serialize_field("CurPos", v)?;
        }
        if let Some(v) = self.dest_pos.as_ref() {
            struct_ser.serialize_field("DestPos", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncSkillLocation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillUuid",
            "SkillStage",
            "CurPos",
            "DestPos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillUuid,
            SkillStage,
            CurPos,
            DestPos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillUuid" => Ok(GeneratedField::SkillUuid),
                            "SkillStage" => Ok(GeneratedField::SkillStage),
                            "CurPos" => Ok(GeneratedField::CurPos),
                            "DestPos" => Ok(GeneratedField::DestPos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncSkillLocation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncSkillLocation")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncSkillLocation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_uuid__ = None;
                let mut skill_stage__ = None;
                let mut cur_pos__ = None;
                let mut dest_pos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillUuid => {
                            if skill_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillUuid"));
                            }
                            skill_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillStage => {
                            if skill_stage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillStage"));
                            }
                            skill_stage__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurPos => {
                            if cur_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurPos"));
                            }
                            cur_pos__ = map_.next_value()?;
                        }
                        GeneratedField::DestPos => {
                            if dest_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DestPos"));
                            }
                            dest_pos__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncSkillLocation {
                    skill_uuid: skill_uuid__,
                    skill_stage: skill_stage__,
                    cur_pos: cur_pos__,
                    dest_pos: dest_pos__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncSkillLocation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncSkillStageTrigger {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.trigger_type.is_some() {
            len += 1;
        }
        if self.time.is_some() {
            len += 1;
        }
        if self.skill_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncSkillStageTrigger", len)?;
        if let Some(v) = self.trigger_type.as_ref() {
            struct_ser.serialize_field("TriggerType", v)?;
        }
        if let Some(v) = self.time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Time", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.skill_uuid.as_ref() {
            struct_ser.serialize_field("SkillUuid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncSkillStageTrigger {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TriggerType",
            "Time",
            "SkillUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TriggerType,
            Time,
            SkillUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TriggerType" => Ok(GeneratedField::TriggerType),
                            "Time" => Ok(GeneratedField::Time),
                            "SkillUuid" => Ok(GeneratedField::SkillUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncSkillStageTrigger;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncSkillStageTrigger")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncSkillStageTrigger, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut trigger_type__ = None;
                let mut time__ = None;
                let mut skill_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TriggerType => {
                            if trigger_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TriggerType"));
                            }
                            trigger_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Time => {
                            if time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Time"));
                            }
                            time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillUuid => {
                            if skill_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillUuid"));
                            }
                            skill_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(SyncSkillStageTrigger {
                    trigger_type: trigger_type__,
                    time: time__,
                    skill_uuid: skill_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncSkillStageTrigger", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncSubSceneAttrs {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.attrs.is_some() {
            len += 1;
        }
        if self.is_first_enter.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncSubSceneAttrs", len)?;
        if let Some(v) = self.attrs.as_ref() {
            struct_ser.serialize_field("Attrs", v)?;
        }
        if let Some(v) = self.is_first_enter.as_ref() {
            struct_ser.serialize_field("IsFirstEnter", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncSubSceneAttrs {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Attrs",
            "IsFirstEnter",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Attrs,
            IsFirstEnter,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Attrs" => Ok(GeneratedField::Attrs),
                            "IsFirstEnter" => Ok(GeneratedField::IsFirstEnter),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncSubSceneAttrs;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncSubSceneAttrs")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncSubSceneAttrs, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut attrs__ = None;
                let mut is_first_enter__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Attrs => {
                            if attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Attrs"));
                            }
                            attrs__ = map_.next_value()?;
                        }
                        GeneratedField::IsFirstEnter => {
                            if is_first_enter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsFirstEnter"));
                            }
                            is_first_enter__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncSubSceneAttrs {
                    attrs: attrs__,
                    is_first_enter: is_first_enter__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncSubSceneAttrs", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncToMeDeltaInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.delta_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncToMeDeltaInfo", len)?;
        if let Some(v) = self.delta_info.as_ref() {
            struct_ser.serialize_field("DeltaInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncToMeDeltaInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DeltaInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DeltaInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DeltaInfo" => Ok(GeneratedField::DeltaInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncToMeDeltaInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncToMeDeltaInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncToMeDeltaInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut delta_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DeltaInfo => {
                            if delta_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DeltaInfo"));
                            }
                            delta_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(SyncToMeDeltaInfo {
                    delta_info: delta_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncToMeDeltaInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SyncUserBeHitInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.behit_infos.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.SyncUserBeHitInfo", len)?;
        if !self.behit_infos.is_empty() {
            struct_ser.serialize_field("BehitInfos", &self.behit_infos)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SyncUserBeHitInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BehitInfos",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BehitInfos,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BehitInfos" => Ok(GeneratedField::BehitInfos),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SyncUserBeHitInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.SyncUserBeHitInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SyncUserBeHitInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut behit_infos__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BehitInfos => {
                            if behit_infos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BehitInfos"));
                            }
                            behit_infos__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SyncUserBeHitInfo {
                    behit_infos: behit_infos__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.SyncUserBeHitInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SystemType {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Null => "SystemType_Null",
            Self::Android => "SystemType_Android",
            Self::Ios => "SystemType_Ios",
            Self::Web => "SystemType_Web",
            Self::Linux => "SystemType_Linux",
            Self::Windows => "SystemType_Windows",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SystemType {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SystemType_Null",
            "SystemType_Android",
            "SystemType_Ios",
            "SystemType_Web",
            "SystemType_Linux",
            "SystemType_Windows",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SystemType;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SystemType_Null" => Ok(SystemType::Null),
                    "SystemType_Android" => Ok(SystemType::Android),
                    "SystemType_Ios" => Ok(SystemType::Ios),
                    "SystemType_Web" => Ok(SystemType::Web),
                    "SystemType_Linux" => Ok(SystemType::Linux),
                    "SystemType_Windows" => Ok(SystemType::Windows),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for TakeOffShowPiece {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_piece_type.is_some() {
            len += 1;
        }
        if self.v_piece_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TakeOffShowPiece", len)?;
        if let Some(v) = self.v_piece_type.as_ref() {
            let v = EShowPieceType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("VPieceType", &v)?;
        }
        if let Some(v) = self.v_piece_id.as_ref() {
            struct_ser.serialize_field("VPieceId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TakeOffShowPiece {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VPieceType",
            "VPieceId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VPieceType,
            VPieceId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VPieceType" => Ok(GeneratedField::VPieceType),
                            "VPieceId" => Ok(GeneratedField::VPieceId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TakeOffShowPiece;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TakeOffShowPiece")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TakeOffShowPiece, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_piece_type__ = None;
                let mut v_piece_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VPieceType => {
                            if v_piece_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VPieceType"));
                            }
                            v_piece_type__ = map_.next_value::<::std::option::Option<EShowPieceType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::VPieceId => {
                            if v_piece_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VPieceId"));
                            }
                            v_piece_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TakeOffShowPiece {
                    v_piece_type: v_piece_type__,
                    v_piece_id: v_piece_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TakeOffShowPiece", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TakeOnActivateRideSkin {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TakeOnActivateRideSkin", len)?;
        if let Some(v) = self.param.as_ref() {
            struct_ser.serialize_field("Param", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TakeOnActivateRideSkin {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Param",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Param,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Param" => Ok(GeneratedField::Param),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TakeOnActivateRideSkin;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TakeOnActivateRideSkin")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TakeOnActivateRideSkin, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Param => {
                            if param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Param"));
                            }
                            param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(TakeOnActivateRideSkin {
                    param: param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TakeOnActivateRideSkin", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TakeOnActivateRideSkinParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skin_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TakeOnActivateRideSkinParam", len)?;
        if let Some(v) = self.skin_id.as_ref() {
            struct_ser.serialize_field("SkinId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TakeOnActivateRideSkinParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkinId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkinId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkinId" => Ok(GeneratedField::SkinId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TakeOnActivateRideSkinParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TakeOnActivateRideSkinParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TakeOnActivateRideSkinParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skin_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkinId => {
                            if skin_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkinId"));
                            }
                            skin_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TakeOnActivateRideSkinParam {
                    skin_id: skin_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TakeOnActivateRideSkinParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TakeOnSetRideSkin {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TakeOnSetRideSkin", len)?;
        if let Some(v) = self.param.as_ref() {
            struct_ser.serialize_field("Param", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TakeOnSetRideSkin {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Param",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Param,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Param" => Ok(GeneratedField::Param),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TakeOnSetRideSkin;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TakeOnSetRideSkin")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TakeOnSetRideSkin, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Param => {
                            if param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Param"));
                            }
                            param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(TakeOnSetRideSkin {
                    param: param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TakeOnSetRideSkin", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TakeOnSetRideSkinParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skin_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TakeOnSetRideSkinParam", len)?;
        if let Some(v) = self.skin_id.as_ref() {
            struct_ser.serialize_field("SkinId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TakeOnSetRideSkinParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkinId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkinId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkinId" => Ok(GeneratedField::SkinId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TakeOnSetRideSkinParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TakeOnSetRideSkinParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TakeOnSetRideSkinParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skin_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkinId => {
                            if skin_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkinId"));
                            }
                            skin_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TakeOnSetRideSkinParam {
                    skin_id: skin_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TakeOnSetRideSkinParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TakeOnShowPiece {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_piece_type.is_some() {
            len += 1;
        }
        if self.v_piece_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TakeOnShowPiece", len)?;
        if let Some(v) = self.v_piece_type.as_ref() {
            let v = EShowPieceType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("VPieceType", &v)?;
        }
        if let Some(v) = self.v_piece_id.as_ref() {
            struct_ser.serialize_field("VPieceId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TakeOnShowPiece {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VPieceType",
            "VPieceId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VPieceType,
            VPieceId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VPieceType" => Ok(GeneratedField::VPieceType),
                            "VPieceId" => Ok(GeneratedField::VPieceId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TakeOnShowPiece;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TakeOnShowPiece")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TakeOnShowPiece, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_piece_type__ = None;
                let mut v_piece_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VPieceType => {
                            if v_piece_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VPieceType"));
                            }
                            v_piece_type__ = map_.next_value::<::std::option::Option<EShowPieceType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::VPieceId => {
                            if v_piece_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VPieceId"));
                            }
                            v_piece_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TakeOnShowPiece {
                    v_piece_type: v_piece_type__,
                    v_piece_id: v_piece_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TakeOnShowPiece", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TeamMemData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.char_id.is_some() {
            len += 1;
        }
        if self.enter_time.is_some() {
            len += 1;
        }
        if self.call_status.is_some() {
            len += 1;
        }
        if self.talent_id.is_some() {
            len += 1;
        }
        if self.online_status.is_some() {
            len += 1;
        }
        if self.scene_id.is_some() {
            len += 1;
        }
        if self.voice_is_open.is_some() {
            len += 1;
        }
        if self.group_id.is_some() {
            len += 1;
        }
        if self.social_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TeamMemData", len)?;
        if let Some(v) = self.char_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CharId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.enter_time.as_ref() {
            struct_ser.serialize_field("EnterTime", v)?;
        }
        if let Some(v) = self.call_status.as_ref() {
            struct_ser.serialize_field("CallStatus", v)?;
        }
        if let Some(v) = self.talent_id.as_ref() {
            struct_ser.serialize_field("TalentId", v)?;
        }
        if let Some(v) = self.online_status.as_ref() {
            struct_ser.serialize_field("OnlineStatus", v)?;
        }
        if let Some(v) = self.scene_id.as_ref() {
            struct_ser.serialize_field("SceneId", v)?;
        }
        if let Some(v) = self.voice_is_open.as_ref() {
            struct_ser.serialize_field("VoiceIsOpen", v)?;
        }
        if let Some(v) = self.group_id.as_ref() {
            struct_ser.serialize_field("GroupId", v)?;
        }
        if let Some(v) = self.social_data.as_ref() {
            struct_ser.serialize_field("SocialData", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TeamMemData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CharId",
            "EnterTime",
            "CallStatus",
            "TalentId",
            "OnlineStatus",
            "SceneId",
            "VoiceIsOpen",
            "GroupId",
            "SocialData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CharId,
            EnterTime,
            CallStatus,
            TalentId,
            OnlineStatus,
            SceneId,
            VoiceIsOpen,
            GroupId,
            SocialData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CharId" => Ok(GeneratedField::CharId),
                            "EnterTime" => Ok(GeneratedField::EnterTime),
                            "CallStatus" => Ok(GeneratedField::CallStatus),
                            "TalentId" => Ok(GeneratedField::TalentId),
                            "OnlineStatus" => Ok(GeneratedField::OnlineStatus),
                            "SceneId" => Ok(GeneratedField::SceneId),
                            "VoiceIsOpen" => Ok(GeneratedField::VoiceIsOpen),
                            "GroupId" => Ok(GeneratedField::GroupId),
                            "SocialData" => Ok(GeneratedField::SocialData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TeamMemData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TeamMemData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TeamMemData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut char_id__ = None;
                let mut enter_time__ = None;
                let mut call_status__ = None;
                let mut talent_id__ = None;
                let mut online_status__ = None;
                let mut scene_id__ = None;
                let mut voice_is_open__ = None;
                let mut group_id__ = None;
                let mut social_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CharId => {
                            if char_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CharId"));
                            }
                            char_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EnterTime => {
                            if enter_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EnterTime"));
                            }
                            enter_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CallStatus => {
                            if call_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CallStatus"));
                            }
                            call_status__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TalentId => {
                            if talent_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TalentId"));
                            }
                            talent_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OnlineStatus => {
                            if online_status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OnlineStatus"));
                            }
                            online_status__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SceneId => {
                            if scene_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneId"));
                            }
                            scene_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VoiceIsOpen => {
                            if voice_is_open__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VoiceIsOpen"));
                            }
                            voice_is_open__ = map_.next_value()?;
                        }
                        GeneratedField::GroupId => {
                            if group_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GroupId"));
                            }
                            group_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SocialData => {
                            if social_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SocialData"));
                            }
                            social_data__ = map_.next_value()?;
                        }
                    }
                }
                Ok(TeamMemData {
                    char_id: char_id__,
                    enter_time: enter_time__,
                    call_status: call_status__,
                    talent_id: talent_id__,
                    online_status: online_status__,
                    scene_id: scene_id__,
                    voice_is_open: voice_is_open__,
                    group_id: group_id__,
                    social_data: social_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TeamMemData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TeamMemberSocialData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.basic_data.is_some() {
            len += 1;
        }
        if self.avatar_info.is_some() {
            len += 1;
        }
        if self.face_data.is_some() {
            len += 1;
        }
        if self.profession_data.is_some() {
            len += 1;
        }
        if self.equip_data.is_some() {
            len += 1;
        }
        if self.fashion_data.is_some() {
            len += 1;
        }
        if self.user_scene_info.is_some() {
            len += 1;
        }
        if self.user_attr_data.is_some() {
            len += 1;
        }
        if self.personal_zone.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TeamMemberSocialData", len)?;
        if let Some(v) = self.basic_data.as_ref() {
            struct_ser.serialize_field("BasicData", v)?;
        }
        if let Some(v) = self.avatar_info.as_ref() {
            struct_ser.serialize_field("AvatarInfo", v)?;
        }
        if let Some(v) = self.face_data.as_ref() {
            struct_ser.serialize_field("FaceData", v)?;
        }
        if let Some(v) = self.profession_data.as_ref() {
            struct_ser.serialize_field("ProfessionData", v)?;
        }
        if let Some(v) = self.equip_data.as_ref() {
            struct_ser.serialize_field("EquipData", v)?;
        }
        if let Some(v) = self.fashion_data.as_ref() {
            struct_ser.serialize_field("FashionData", v)?;
        }
        if let Some(v) = self.user_scene_info.as_ref() {
            struct_ser.serialize_field("UserSceneInfo", v)?;
        }
        if let Some(v) = self.user_attr_data.as_ref() {
            struct_ser.serialize_field("UserAttrData", v)?;
        }
        if let Some(v) = self.personal_zone.as_ref() {
            struct_ser.serialize_field("PersonalZone", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TeamMemberSocialData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BasicData",
            "AvatarInfo",
            "FaceData",
            "ProfessionData",
            "EquipData",
            "FashionData",
            "UserSceneInfo",
            "UserAttrData",
            "PersonalZone",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BasicData,
            AvatarInfo,
            FaceData,
            ProfessionData,
            EquipData,
            FashionData,
            UserSceneInfo,
            UserAttrData,
            PersonalZone,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BasicData" => Ok(GeneratedField::BasicData),
                            "AvatarInfo" => Ok(GeneratedField::AvatarInfo),
                            "FaceData" => Ok(GeneratedField::FaceData),
                            "ProfessionData" => Ok(GeneratedField::ProfessionData),
                            "EquipData" => Ok(GeneratedField::EquipData),
                            "FashionData" => Ok(GeneratedField::FashionData),
                            "UserSceneInfo" => Ok(GeneratedField::UserSceneInfo),
                            "UserAttrData" => Ok(GeneratedField::UserAttrData),
                            "PersonalZone" => Ok(GeneratedField::PersonalZone),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TeamMemberSocialData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TeamMemberSocialData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TeamMemberSocialData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut basic_data__ = None;
                let mut avatar_info__ = None;
                let mut face_data__ = None;
                let mut profession_data__ = None;
                let mut equip_data__ = None;
                let mut fashion_data__ = None;
                let mut user_scene_info__ = None;
                let mut user_attr_data__ = None;
                let mut personal_zone__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BasicData => {
                            if basic_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BasicData"));
                            }
                            basic_data__ = map_.next_value()?;
                        }
                        GeneratedField::AvatarInfo => {
                            if avatar_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AvatarInfo"));
                            }
                            avatar_info__ = map_.next_value()?;
                        }
                        GeneratedField::FaceData => {
                            if face_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FaceData"));
                            }
                            face_data__ = map_.next_value()?;
                        }
                        GeneratedField::ProfessionData => {
                            if profession_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ProfessionData"));
                            }
                            profession_data__ = map_.next_value()?;
                        }
                        GeneratedField::EquipData => {
                            if equip_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EquipData"));
                            }
                            equip_data__ = map_.next_value()?;
                        }
                        GeneratedField::FashionData => {
                            if fashion_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FashionData"));
                            }
                            fashion_data__ = map_.next_value()?;
                        }
                        GeneratedField::UserSceneInfo => {
                            if user_scene_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UserSceneInfo"));
                            }
                            user_scene_info__ = map_.next_value()?;
                        }
                        GeneratedField::UserAttrData => {
                            if user_attr_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UserAttrData"));
                            }
                            user_attr_data__ = map_.next_value()?;
                        }
                        GeneratedField::PersonalZone => {
                            if personal_zone__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PersonalZone"));
                            }
                            personal_zone__ = map_.next_value()?;
                        }
                    }
                }
                Ok(TeamMemberSocialData {
                    basic_data: basic_data__,
                    avatar_info: avatar_info__,
                    face_data: face_data__,
                    profession_data: profession_data__,
                    equip_data: equip_data__,
                    fashion_data: fashion_data__,
                    user_scene_info: user_scene_info__,
                    user_attr_data: user_attr_data__,
                    personal_zone: personal_zone__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TeamMemberSocialData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Teleport {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.teleport_params.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Teleport", len)?;
        if let Some(v) = self.teleport_params.as_ref() {
            struct_ser.serialize_field("TeleportParams", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Teleport {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TeleportParams",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TeleportParams,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TeleportParams" => Ok(GeneratedField::TeleportParams),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Teleport;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Teleport")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Teleport, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut teleport_params__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TeleportParams => {
                            if teleport_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TeleportParams"));
                            }
                            teleport_params__ = map_.next_value()?;
                        }
                    }
                }
                Ok(Teleport {
                    teleport_params: teleport_params__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Teleport", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TeleportParams {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.transfer_params.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TeleportParams", len)?;
        if let Some(v) = self.transfer_params.as_ref() {
            struct_ser.serialize_field("TransferParams", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TeleportParams {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TransferParams",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TransferParams,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TransferParams" => Ok(GeneratedField::TransferParams),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TeleportParams;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TeleportParams")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TeleportParams, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transfer_params__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TransferParams => {
                            if transfer_params__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TransferParams"));
                            }
                            transfer_params__ = map_.next_value()?;
                        }
                    }
                }
                Ok(TeleportParams {
                    transfer_params: transfer_params__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TeleportParams", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TempAttr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TempAttr", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("Value", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TempAttr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Value,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Value" => Ok(GeneratedField::Value),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TempAttr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TempAttr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TempAttr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Value"));
                            }
                            value__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TempAttr {
                    id: id__,
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TempAttr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TempAttrCollection {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.attrs.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TempAttrCollection", len)?;
        if !self.attrs.is_empty() {
            struct_ser.serialize_field("Attrs", &self.attrs)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TempAttrCollection {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Attrs",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Attrs,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Attrs" => Ok(GeneratedField::Attrs),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TempAttrCollection;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TempAttrCollection")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TempAttrCollection, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut attrs__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Attrs => {
                            if attrs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Attrs"));
                            }
                            attrs__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(TempAttrCollection {
                    attrs: attrs__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TempAttrCollection", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ThrowMoveInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target_uuid.is_some() {
            len += 1;
        }
        if self.skill_id.is_some() {
            len += 1;
        }
        if self.skill_level.is_some() {
            len += 1;
        }
        if self.stage_id.is_some() {
            len += 1;
        }
        if self.event_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.ThrowMoveInfo", len)?;
        if let Some(v) = self.target_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.skill_id.as_ref() {
            struct_ser.serialize_field("SkillId", v)?;
        }
        if let Some(v) = self.skill_level.as_ref() {
            struct_ser.serialize_field("SkillLevel", v)?;
        }
        if let Some(v) = self.stage_id.as_ref() {
            struct_ser.serialize_field("StageId", v)?;
        }
        if let Some(v) = self.event_id.as_ref() {
            struct_ser.serialize_field("EventId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ThrowMoveInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetUuid",
            "SkillId",
            "SkillLevel",
            "StageId",
            "EventId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetUuid,
            SkillId,
            SkillLevel,
            StageId,
            EventId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            "SkillId" => Ok(GeneratedField::SkillId),
                            "SkillLevel" => Ok(GeneratedField::SkillLevel),
                            "StageId" => Ok(GeneratedField::StageId),
                            "EventId" => Ok(GeneratedField::EventId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ThrowMoveInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.ThrowMoveInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ThrowMoveInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_uuid__ = None;
                let mut skill_id__ = None;
                let mut skill_level__ = None;
                let mut stage_id__ = None;
                let mut event_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillId => {
                            if skill_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillId"));
                            }
                            skill_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillLevel => {
                            if skill_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillLevel"));
                            }
                            skill_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StageId => {
                            if stage_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StageId"));
                            }
                            stage_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EventId => {
                            if event_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EventId"));
                            }
                            event_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(ThrowMoveInfo {
                    target_uuid: target_uuid__,
                    skill_id: skill_id__,
                    skill_level: skill_level__,
                    stage_id: stage_id__,
                    event_id: event_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.ThrowMoveInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TimerInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cfg_id.is_some() {
            len += 1;
        }
        if self.timer_type.is_some() {
            len += 1;
        }
        if self.cur_type.is_some() {
            len += 1;
        }
        if self.start_timestamp.is_some() {
            len += 1;
        }
        if self.end_timestamp.is_some() {
            len += 1;
        }
        if self.last_time_stamp.is_some() {
            len += 1;
        }
        if self.last_end_time_stamp.is_some() {
            len += 1;
        }
        if self.next_time_stamp.is_some() {
            len += 1;
        }
        if self.next_end_time_stamp.is_some() {
            len += 1;
        }
        if !self.offset_list.is_empty() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TimerInfo", len)?;
        if let Some(v) = self.cfg_id.as_ref() {
            struct_ser.serialize_field("CfgId", v)?;
        }
        if let Some(v) = self.timer_type.as_ref() {
            let v = ETimerType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("TimerType", &v)?;
        }
        if let Some(v) = self.cur_type.as_ref() {
            let v = ETimerExeType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("CurType", &v)?;
        }
        if let Some(v) = self.start_timestamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("StartTimestamp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.end_timestamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("EndTimestamp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.last_time_stamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastTimeStamp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.last_end_time_stamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastEndTimeStamp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.next_time_stamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("NextTimeStamp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.next_end_time_stamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("NextEndTimeStamp", ToString::to_string(&v).as_str())?;
        }
        if !self.offset_list.is_empty() {
            struct_ser.serialize_field("OffsetList", &self.offset_list)?;
        }
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("Duration", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TimerInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CfgId",
            "TimerType",
            "CurType",
            "StartTimestamp",
            "EndTimestamp",
            "LastTimeStamp",
            "LastEndTimeStamp",
            "NextTimeStamp",
            "NextEndTimeStamp",
            "OffsetList",
            "Duration",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CfgId,
            TimerType,
            CurType,
            StartTimestamp,
            EndTimestamp,
            LastTimeStamp,
            LastEndTimeStamp,
            NextTimeStamp,
            NextEndTimeStamp,
            OffsetList,
            Duration,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CfgId" => Ok(GeneratedField::CfgId),
                            "TimerType" => Ok(GeneratedField::TimerType),
                            "CurType" => Ok(GeneratedField::CurType),
                            "StartTimestamp" => Ok(GeneratedField::StartTimestamp),
                            "EndTimestamp" => Ok(GeneratedField::EndTimestamp),
                            "LastTimeStamp" => Ok(GeneratedField::LastTimeStamp),
                            "LastEndTimeStamp" => Ok(GeneratedField::LastEndTimeStamp),
                            "NextTimeStamp" => Ok(GeneratedField::NextTimeStamp),
                            "NextEndTimeStamp" => Ok(GeneratedField::NextEndTimeStamp),
                            "OffsetList" => Ok(GeneratedField::OffsetList),
                            "Duration" => Ok(GeneratedField::Duration),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TimerInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TimerInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TimerInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cfg_id__ = None;
                let mut timer_type__ = None;
                let mut cur_type__ = None;
                let mut start_timestamp__ = None;
                let mut end_timestamp__ = None;
                let mut last_time_stamp__ = None;
                let mut last_end_time_stamp__ = None;
                let mut next_time_stamp__ = None;
                let mut next_end_time_stamp__ = None;
                let mut offset_list__ = None;
                let mut duration__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CfgId => {
                            if cfg_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CfgId"));
                            }
                            cfg_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TimerType => {
                            if timer_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TimerType"));
                            }
                            timer_type__ = map_.next_value::<::std::option::Option<ETimerType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::CurType => {
                            if cur_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurType"));
                            }
                            cur_type__ = map_.next_value::<::std::option::Option<ETimerExeType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::StartTimestamp => {
                            if start_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StartTimestamp"));
                            }
                            start_timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EndTimestamp => {
                            if end_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EndTimestamp"));
                            }
                            end_timestamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastTimeStamp => {
                            if last_time_stamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastTimeStamp"));
                            }
                            last_time_stamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastEndTimeStamp => {
                            if last_end_time_stamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastEndTimeStamp"));
                            }
                            last_end_time_stamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextTimeStamp => {
                            if next_time_stamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NextTimeStamp"));
                            }
                            next_time_stamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextEndTimeStamp => {
                            if next_end_time_stamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NextEndTimeStamp"));
                            }
                            next_end_time_stamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OffsetList => {
                            if offset_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OffsetList"));
                            }
                            offset_list__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Duration"));
                            }
                            duration__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TimerInfo {
                    cfg_id: cfg_id__,
                    timer_type: timer_type__,
                    cur_type: cur_type__,
                    start_timestamp: start_timestamp__,
                    end_timestamp: end_timestamp__,
                    last_time_stamp: last_time_stamp__,
                    last_end_time_stamp: last_end_time_stamp__,
                    next_time_stamp: next_time_stamp__,
                    next_end_time_stamp: next_end_time_stamp__,
                    offset_list: offset_list__.unwrap_or_default(),
                    duration: duration__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TimerInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TimerRefreshDataList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.refresh_data_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TimerRefreshDataList", len)?;
        if !self.refresh_data_list.is_empty() {
            struct_ser.serialize_field("RefreshDataList", &self.refresh_data_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TimerRefreshDataList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RefreshDataList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RefreshDataList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RefreshDataList" => Ok(GeneratedField::RefreshDataList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TimerRefreshDataList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TimerRefreshDataList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TimerRefreshDataList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut refresh_data_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RefreshDataList => {
                            if refresh_data_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshDataList"));
                            }
                            refresh_data_list__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(TimerRefreshDataList {
                    refresh_data_list: refresh_data_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TimerRefreshDataList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TimerRefreshInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.last_refresh_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TimerRefreshInfo", len)?;
        if let Some(v) = self.last_refresh_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastRefreshTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TimerRefreshInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "LastRefreshTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            LastRefreshTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "LastRefreshTime" => Ok(GeneratedField::LastRefreshTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TimerRefreshInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TimerRefreshInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TimerRefreshInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut last_refresh_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::LastRefreshTime => {
                            if last_refresh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastRefreshTime"));
                            }
                            last_refresh_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TimerRefreshInfo {
                    last_refresh_time: last_refresh_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TimerRefreshInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TimerRefreshList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.refresh_data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TimerRefreshList", len)?;
        if !self.refresh_data.is_empty() {
            struct_ser.serialize_field("RefreshData", &self.refresh_data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TimerRefreshList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "RefreshData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            RefreshData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "RefreshData" => Ok(GeneratedField::RefreshData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TimerRefreshList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TimerRefreshList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TimerRefreshList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut refresh_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::RefreshData => {
                            if refresh_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshData"));
                            }
                            refresh_data__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(TimerRefreshList {
                    refresh_data: refresh_data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TimerRefreshList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TransferParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scene_id.is_some() {
            len += 1;
        }
        if self.transfer_type.is_some() {
            len += 1;
        }
        if self.position_param.is_some() {
            len += 1;
        }
        if self.change_flag.is_some() {
            len += 1;
        }
        if self.is_server_switch.is_some() {
            len += 1;
        }
        if self.visual_layer_config_id.is_some() {
            len += 1;
        }
        if self.scene_guid.is_some() {
            len += 1;
        }
        if self.connect_guid.is_some() {
            len += 1;
        }
        if self.sub_scene_uuid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TransferParam", len)?;
        if let Some(v) = self.scene_id.as_ref() {
            struct_ser.serialize_field("SceneId", v)?;
        }
        if let Some(v) = self.transfer_type.as_ref() {
            let v = EUserTransferType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("TransferType", &v)?;
        }
        if let Some(v) = self.position_param.as_ref() {
            struct_ser.serialize_field("PositionParam", v)?;
        }
        if let Some(v) = self.change_flag.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ChangeFlag", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.is_server_switch.as_ref() {
            struct_ser.serialize_field("IsServerSwitch", v)?;
        }
        if let Some(v) = self.visual_layer_config_id.as_ref() {
            struct_ser.serialize_field("VisualLayerConfigId", v)?;
        }
        if let Some(v) = self.scene_guid.as_ref() {
            struct_ser.serialize_field("SceneGuid", v)?;
        }
        if let Some(v) = self.connect_guid.as_ref() {
            struct_ser.serialize_field("ConnectGuid", v)?;
        }
        if let Some(v) = self.sub_scene_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SubSceneUuid", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TransferParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SceneId",
            "TransferType",
            "PositionParam",
            "ChangeFlag",
            "IsServerSwitch",
            "VisualLayerConfigId",
            "SceneGuid",
            "ConnectGuid",
            "SubSceneUuid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SceneId,
            TransferType,
            PositionParam,
            ChangeFlag,
            IsServerSwitch,
            VisualLayerConfigId,
            SceneGuid,
            ConnectGuid,
            SubSceneUuid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SceneId" => Ok(GeneratedField::SceneId),
                            "TransferType" => Ok(GeneratedField::TransferType),
                            "PositionParam" => Ok(GeneratedField::PositionParam),
                            "ChangeFlag" => Ok(GeneratedField::ChangeFlag),
                            "IsServerSwitch" => Ok(GeneratedField::IsServerSwitch),
                            "VisualLayerConfigId" => Ok(GeneratedField::VisualLayerConfigId),
                            "SceneGuid" => Ok(GeneratedField::SceneGuid),
                            "ConnectGuid" => Ok(GeneratedField::ConnectGuid),
                            "SubSceneUuid" => Ok(GeneratedField::SubSceneUuid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TransferParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TransferParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TransferParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_id__ = None;
                let mut transfer_type__ = None;
                let mut position_param__ = None;
                let mut change_flag__ = None;
                let mut is_server_switch__ = None;
                let mut visual_layer_config_id__ = None;
                let mut scene_guid__ = None;
                let mut connect_guid__ = None;
                let mut sub_scene_uuid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SceneId => {
                            if scene_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneId"));
                            }
                            scene_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TransferType => {
                            if transfer_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TransferType"));
                            }
                            transfer_type__ = map_.next_value::<::std::option::Option<EUserTransferType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::PositionParam => {
                            if position_param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PositionParam"));
                            }
                            position_param__ = map_.next_value()?;
                        }
                        GeneratedField::ChangeFlag => {
                            if change_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ChangeFlag"));
                            }
                            change_flag__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsServerSwitch => {
                            if is_server_switch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsServerSwitch"));
                            }
                            is_server_switch__ = map_.next_value()?;
                        }
                        GeneratedField::VisualLayerConfigId => {
                            if visual_layer_config_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VisualLayerConfigId"));
                            }
                            visual_layer_config_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SceneGuid => {
                            if scene_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneGuid"));
                            }
                            scene_guid__ = map_.next_value()?;
                        }
                        GeneratedField::ConnectGuid => {
                            if connect_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConnectGuid"));
                            }
                            connect_guid__ = map_.next_value()?;
                        }
                        GeneratedField::SubSceneUuid => {
                            if sub_scene_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SubSceneUuid"));
                            }
                            sub_scene_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TransferParam {
                    scene_id: scene_id__,
                    transfer_type: transfer_type__,
                    position_param: position_param__,
                    change_flag: change_flag__,
                    is_server_switch: is_server_switch__,
                    visual_layer_config_id: visual_layer_config_id__,
                    scene_guid: scene_guid__,
                    connect_guid: connect_guid__,
                    sub_scene_uuid: sub_scene_uuid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TransferParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TransferPoint {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.points.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TransferPoint", len)?;
        if !self.points.is_empty() {
            struct_ser.serialize_field("Points", &self.points)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TransferPoint {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Points",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Points,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Points" => Ok(GeneratedField::Points),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TransferPoint;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TransferPoint")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TransferPoint, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut points__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Points => {
                            if points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Points"));
                            }
                            points__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i32>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(TransferPoint {
                    points: points__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TransferPoint", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Treasure {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.rows.is_empty() {
            len += 1;
        }
        if !self.history_rows.is_empty() {
            len += 1;
        }
        if self.flag.is_some() {
            len += 1;
        }
        if self.refresh_time.is_some() {
            len += 1;
        }
        if !self.selected_reward.is_empty() {
            len += 1;
        }
        if self.season_id.is_some() {
            len += 1;
        }
        if self.last_season_id.is_some() {
            len += 1;
        }
        if self.last_refresh_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Treasure", len)?;
        if !self.rows.is_empty() {
            struct_ser.serialize_field("Rows", &self.rows)?;
        }
        if !self.history_rows.is_empty() {
            struct_ser.serialize_field("HistoryRows", &self.history_rows)?;
        }
        if let Some(v) = self.flag.as_ref() {
            struct_ser.serialize_field("Flag", v)?;
        }
        if let Some(v) = self.refresh_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RefreshTime", ToString::to_string(&v).as_str())?;
        }
        if !self.selected_reward.is_empty() {
            struct_ser.serialize_field("SelectedReward", &self.selected_reward)?;
        }
        if let Some(v) = self.season_id.as_ref() {
            struct_ser.serialize_field("SeasonId", v)?;
        }
        if let Some(v) = self.last_season_id.as_ref() {
            struct_ser.serialize_field("LastSeasonId", v)?;
        }
        if let Some(v) = self.last_refresh_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastRefreshTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Treasure {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Rows",
            "HistoryRows",
            "Flag",
            "RefreshTime",
            "SelectedReward",
            "SeasonId",
            "LastSeasonId",
            "LastRefreshTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Rows,
            HistoryRows,
            Flag,
            RefreshTime,
            SelectedReward,
            SeasonId,
            LastSeasonId,
            LastRefreshTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Rows" => Ok(GeneratedField::Rows),
                            "HistoryRows" => Ok(GeneratedField::HistoryRows),
                            "Flag" => Ok(GeneratedField::Flag),
                            "RefreshTime" => Ok(GeneratedField::RefreshTime),
                            "SelectedReward" => Ok(GeneratedField::SelectedReward),
                            "SeasonId" => Ok(GeneratedField::SeasonId),
                            "LastSeasonId" => Ok(GeneratedField::LastSeasonId),
                            "LastRefreshTime" => Ok(GeneratedField::LastRefreshTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Treasure;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Treasure")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Treasure, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut rows__ = None;
                let mut history_rows__ = None;
                let mut flag__ = None;
                let mut refresh_time__ = None;
                let mut selected_reward__ = None;
                let mut season_id__ = None;
                let mut last_season_id__ = None;
                let mut last_refresh_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Rows => {
                            if rows__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Rows"));
                            }
                            rows__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::HistoryRows => {
                            if history_rows__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HistoryRows"));
                            }
                            history_rows__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::Flag => {
                            if flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Flag"));
                            }
                            flag__ = map_.next_value()?;
                        }
                        GeneratedField::RefreshTime => {
                            if refresh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshTime"));
                            }
                            refresh_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SelectedReward => {
                            if selected_reward__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SelectedReward"));
                            }
                            selected_reward__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::SeasonId => {
                            if season_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SeasonId"));
                            }
                            season_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastSeasonId => {
                            if last_season_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastSeasonId"));
                            }
                            last_season_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastRefreshTime => {
                            if last_refresh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastRefreshTime"));
                            }
                            last_refresh_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Treasure {
                    rows: rows__.unwrap_or_default(),
                    history_rows: history_rows__.unwrap_or_default(),
                    flag: flag__,
                    refresh_time: refresh_time__,
                    selected_reward: selected_reward__.unwrap_or_default(),
                    season_id: season_id__,
                    last_season_id: last_season_id__,
                    last_refresh_time: last_refresh_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Treasure", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TreasureItem {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.items.is_empty() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TreasureItem", len)?;
        if !self.items.is_empty() {
            struct_ser.serialize_field("Items", &self.items)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("Type", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TreasureItem {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Items",
            "Type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Items,
            Type,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Items" => Ok(GeneratedField::Items),
                            "Type" => Ok(GeneratedField::Type),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TreasureItem;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TreasureItem")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TreasureItem, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut items__ = None;
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Items => {
                            if items__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Items"));
                            }
                            items__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TreasureItem {
                    items: items__.unwrap_or_default(),
                    r#type: r#type__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TreasureItem", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TreasureItemRow {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.config_id.is_some() {
            len += 1;
        }
        if !self.main_targets.is_empty() {
            len += 1;
        }
        if !self.sub_targets.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TreasureItemRow", len)?;
        if let Some(v) = self.config_id.as_ref() {
            struct_ser.serialize_field("ConfigId", v)?;
        }
        if !self.main_targets.is_empty() {
            struct_ser.serialize_field("MainTargets", &self.main_targets)?;
        }
        if !self.sub_targets.is_empty() {
            struct_ser.serialize_field("SubTargets", &self.sub_targets)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TreasureItemRow {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ConfigId",
            "MainTargets",
            "SubTargets",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ConfigId,
            MainTargets,
            SubTargets,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ConfigId" => Ok(GeneratedField::ConfigId),
                            "MainTargets" => Ok(GeneratedField::MainTargets),
                            "SubTargets" => Ok(GeneratedField::SubTargets),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TreasureItemRow;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TreasureItemRow")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TreasureItemRow, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut config_id__ = None;
                let mut main_targets__ = None;
                let mut sub_targets__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ConfigId => {
                            if config_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ConfigId"));
                            }
                            config_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MainTargets => {
                            if main_targets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MainTargets"));
                            }
                            main_targets__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::SubTargets => {
                            if sub_targets__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SubTargets"));
                            }
                            sub_targets__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(TreasureItemRow {
                    config_id: config_id__,
                    main_targets: main_targets__.unwrap_or_default(),
                    sub_targets: sub_targets__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TreasureItemRow", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TreasureItemTarget {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target_id.is_some() {
            len += 1;
        }
        if self.target_num.is_some() {
            len += 1;
        }
        if self.reward.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TreasureItemTarget", len)?;
        if let Some(v) = self.target_id.as_ref() {
            struct_ser.serialize_field("TargetId", v)?;
        }
        if let Some(v) = self.target_num.as_ref() {
            struct_ser.serialize_field("TargetNum", v)?;
        }
        if let Some(v) = self.reward.as_ref() {
            struct_ser.serialize_field("Reward", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TreasureItemTarget {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetId",
            "TargetNum",
            "Reward",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetId,
            TargetNum,
            Reward,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetId" => Ok(GeneratedField::TargetId),
                            "TargetNum" => Ok(GeneratedField::TargetNum),
                            "Reward" => Ok(GeneratedField::Reward),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TreasureItemTarget;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TreasureItemTarget")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TreasureItemTarget, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_id__ = None;
                let mut target_num__ = None;
                let mut reward__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetId => {
                            if target_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetId"));
                            }
                            target_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetNum => {
                            if target_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetNum"));
                            }
                            target_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Reward => {
                            if reward__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Reward"));
                            }
                            reward__ = map_.next_value()?;
                        }
                    }
                }
                Ok(TreasureItemTarget {
                    target_id: target_id__,
                    target_num: target_num__,
                    reward: reward__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TreasureItemTarget", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TrialRoad {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.pass_room.is_empty() {
            len += 1;
        }
        if !self.room_target_award.is_empty() {
            len += 1;
        }
        if self.target_award.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TrialRoad", len)?;
        if !self.pass_room.is_empty() {
            struct_ser.serialize_field("PassRoom", &self.pass_room)?;
        }
        if !self.room_target_award.is_empty() {
            struct_ser.serialize_field("RoomTargetAward", &self.room_target_award)?;
        }
        if let Some(v) = self.target_award.as_ref() {
            struct_ser.serialize_field("TargetAward", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TrialRoad {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PassRoom",
            "RoomTargetAward",
            "TargetAward",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PassRoom,
            RoomTargetAward,
            TargetAward,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PassRoom" => Ok(GeneratedField::PassRoom),
                            "RoomTargetAward" => Ok(GeneratedField::RoomTargetAward),
                            "TargetAward" => Ok(GeneratedField::TargetAward),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TrialRoad;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TrialRoad")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TrialRoad, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut pass_room__ = None;
                let mut room_target_award__ = None;
                let mut target_award__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PassRoom => {
                            if pass_room__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PassRoom"));
                            }
                            pass_room__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::RoomTargetAward => {
                            if room_target_award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RoomTargetAward"));
                            }
                            room_target_award__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::TargetAward => {
                            if target_award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetAward"));
                            }
                            target_award__ = map_.next_value()?;
                        }
                    }
                }
                Ok(TrialRoad {
                    pass_room: pass_room__.unwrap_or_default(),
                    room_target_award: room_target_award__.unwrap_or_default(),
                    target_award: target_award__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TrialRoad", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TrialRoadRoomTargetAward {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.target_progress.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TrialRoadRoomTargetAward", len)?;
        if !self.target_progress.is_empty() {
            struct_ser.serialize_field("TargetProgress", &self.target_progress)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TrialRoadRoomTargetAward {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetProgress",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetProgress,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetProgress" => Ok(GeneratedField::TargetProgress),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TrialRoadRoomTargetAward;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TrialRoadRoomTargetAward")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TrialRoadRoomTargetAward, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_progress__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetProgress => {
                            if target_progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetProgress"));
                            }
                            target_progress__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(TrialRoadRoomTargetAward {
                    target_progress: target_progress__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TrialRoadRoomTargetAward", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TrialRoadTargetAward {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.target_progress.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TrialRoadTargetAward", len)?;
        if !self.target_progress.is_empty() {
            struct_ser.serialize_field("TargetProgress", &self.target_progress)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TrialRoadTargetAward {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetProgress",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetProgress,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetProgress" => Ok(GeneratedField::TargetProgress),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TrialRoadTargetAward;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TrialRoadTargetAward")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TrialRoadTargetAward, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_progress__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetProgress => {
                            if target_progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetProgress"));
                            }
                            target_progress__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(TrialRoadTargetAward {
                    target_progress: target_progress__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TrialRoadTargetAward", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TrialRoadTargetProgress {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.target_id.is_some() {
            len += 1;
        }
        if self.target_progress.is_some() {
            len += 1;
        }
        if self.award_state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TrialRoadTargetProgress", len)?;
        if let Some(v) = self.target_id.as_ref() {
            struct_ser.serialize_field("TargetId", v)?;
        }
        if let Some(v) = self.target_progress.as_ref() {
            struct_ser.serialize_field("TargetProgress", v)?;
        }
        if let Some(v) = self.award_state.as_ref() {
            struct_ser.serialize_field("AwardState", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TrialRoadTargetProgress {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TargetId",
            "TargetProgress",
            "AwardState",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TargetId,
            TargetProgress,
            AwardState,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TargetId" => Ok(GeneratedField::TargetId),
                            "TargetProgress" => Ok(GeneratedField::TargetProgress),
                            "AwardState" => Ok(GeneratedField::AwardState),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TrialRoadTargetProgress;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TrialRoadTargetProgress")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TrialRoadTargetProgress, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut target_id__ = None;
                let mut target_progress__ = None;
                let mut award_state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TargetId => {
                            if target_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetId"));
                            }
                            target_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetProgress => {
                            if target_progress__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetProgress"));
                            }
                            target_progress__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AwardState => {
                            if award_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardState"));
                            }
                            award_state__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TrialRoadTargetProgress {
                    target_id: target_id__,
                    target_progress: target_progress__,
                    award_state: award_state__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TrialRoadTargetProgress", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TssAccountInfoProto {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.account.is_some() {
            len += 1;
        }
        if self.account_type.is_some() {
            len += 1;
        }
        if self.plat_id.is_some() {
            len += 1;
        }
        if self.game_id.is_some() {
            len += 1;
        }
        if self.world_id.is_some() {
            len += 1;
        }
        if self.channel_id.is_some() {
            len += 1;
        }
        if self.role_id.is_some() {
            len += 1;
        }
        if self.anti_data.is_some() {
            len += 1;
        }
        if self.account_id.is_some() {
            len += 1;
        }
        if self.client_ip.is_some() {
            len += 1;
        }
        if self.role_name.is_some() {
            len += 1;
        }
        if self.index.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.TssAccountInfoProto", len)?;
        if let Some(v) = self.account.as_ref() {
            struct_ser.serialize_field("Account", v)?;
        }
        if let Some(v) = self.account_type.as_ref() {
            struct_ser.serialize_field("AccountType", v)?;
        }
        if let Some(v) = self.plat_id.as_ref() {
            struct_ser.serialize_field("PlatId", v)?;
        }
        if let Some(v) = self.game_id.as_ref() {
            struct_ser.serialize_field("GameId", v)?;
        }
        if let Some(v) = self.world_id.as_ref() {
            struct_ser.serialize_field("WorldId", v)?;
        }
        if let Some(v) = self.channel_id.as_ref() {
            struct_ser.serialize_field("ChannelId", v)?;
        }
        if let Some(v) = self.role_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RoleId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.anti_data.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("AntiData", pbjson::private::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.account_id.as_ref() {
            struct_ser.serialize_field("AccountId", v)?;
        }
        if let Some(v) = self.client_ip.as_ref() {
            struct_ser.serialize_field("ClientIp", v)?;
        }
        if let Some(v) = self.role_name.as_ref() {
            struct_ser.serialize_field("RoleName", v)?;
        }
        if let Some(v) = self.index.as_ref() {
            struct_ser.serialize_field("Index", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TssAccountInfoProto {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Account",
            "AccountType",
            "PlatId",
            "GameId",
            "WorldId",
            "ChannelId",
            "RoleId",
            "AntiData",
            "AccountId",
            "ClientIp",
            "RoleName",
            "Index",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Account,
            AccountType,
            PlatId,
            GameId,
            WorldId,
            ChannelId,
            RoleId,
            AntiData,
            AccountId,
            ClientIp,
            RoleName,
            Index,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Account" => Ok(GeneratedField::Account),
                            "AccountType" => Ok(GeneratedField::AccountType),
                            "PlatId" => Ok(GeneratedField::PlatId),
                            "GameId" => Ok(GeneratedField::GameId),
                            "WorldId" => Ok(GeneratedField::WorldId),
                            "ChannelId" => Ok(GeneratedField::ChannelId),
                            "RoleId" => Ok(GeneratedField::RoleId),
                            "AntiData" => Ok(GeneratedField::AntiData),
                            "AccountId" => Ok(GeneratedField::AccountId),
                            "ClientIp" => Ok(GeneratedField::ClientIp),
                            "RoleName" => Ok(GeneratedField::RoleName),
                            "Index" => Ok(GeneratedField::Index),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TssAccountInfoProto;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.TssAccountInfoProto")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TssAccountInfoProto, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut account__ = None;
                let mut account_type__ = None;
                let mut plat_id__ = None;
                let mut game_id__ = None;
                let mut world_id__ = None;
                let mut channel_id__ = None;
                let mut role_id__ = None;
                let mut anti_data__ = None;
                let mut account_id__ = None;
                let mut client_ip__ = None;
                let mut role_name__ = None;
                let mut index__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Account => {
                            if account__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Account"));
                            }
                            account__ = map_.next_value()?;
                        }
                        GeneratedField::AccountType => {
                            if account_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccountType"));
                            }
                            account_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PlatId => {
                            if plat_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlatId"));
                            }
                            plat_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GameId => {
                            if game_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("GameId"));
                            }
                            game_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WorldId => {
                            if world_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WorldId"));
                            }
                            world_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ChannelId => {
                            if channel_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ChannelId"));
                            }
                            channel_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RoleId => {
                            if role_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RoleId"));
                            }
                            role_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AntiData => {
                            if anti_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AntiData"));
                            }
                            anti_data__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AccountId => {
                            if account_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AccountId"));
                            }
                            account_id__ = map_.next_value()?;
                        }
                        GeneratedField::ClientIp => {
                            if client_ip__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ClientIp"));
                            }
                            client_ip__ = map_.next_value()?;
                        }
                        GeneratedField::RoleName => {
                            if role_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RoleName"));
                            }
                            role_name__ = map_.next_value()?;
                        }
                        GeneratedField::Index => {
                            if index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Index"));
                            }
                            index__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TssAccountInfoProto {
                    account: account__,
                    account_type: account_type__,
                    plat_id: plat_id__,
                    game_id: game_id__,
                    world_id: world_id__,
                    channel_id: channel_id__,
                    role_id: role_id__,
                    anti_data: anti_data__,
                    account_id: account_id__,
                    client_ip: client_ip__,
                    role_name: role_name__,
                    index: index__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.TssAccountInfoProto", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UnionBuilding {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.building_id.is_some() {
            len += 1;
        }
        if self.building_level.is_some() {
            len += 1;
        }
        if self.upgrade_finish_time.is_some() {
            len += 1;
        }
        if self.has_speed_up_sec.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UnionBuilding", len)?;
        if let Some(v) = self.building_id.as_ref() {
            struct_ser.serialize_field("BuildingId", v)?;
        }
        if let Some(v) = self.building_level.as_ref() {
            struct_ser.serialize_field("BuildingLevel", v)?;
        }
        if let Some(v) = self.upgrade_finish_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("UpgradeFinishTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.has_speed_up_sec.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HasSpeedUpSec", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UnionBuilding {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BuildingId",
            "BuildingLevel",
            "UpgradeFinishTime",
            "HasSpeedUpSec",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BuildingId,
            BuildingLevel,
            UpgradeFinishTime,
            HasSpeedUpSec,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BuildingId" => Ok(GeneratedField::BuildingId),
                            "BuildingLevel" => Ok(GeneratedField::BuildingLevel),
                            "UpgradeFinishTime" => Ok(GeneratedField::UpgradeFinishTime),
                            "HasSpeedUpSec" => Ok(GeneratedField::HasSpeedUpSec),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UnionBuilding;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UnionBuilding")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UnionBuilding, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut building_id__ = None;
                let mut building_level__ = None;
                let mut upgrade_finish_time__ = None;
                let mut has_speed_up_sec__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BuildingId => {
                            if building_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuildingId"));
                            }
                            building_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BuildingLevel => {
                            if building_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BuildingLevel"));
                            }
                            building_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::UpgradeFinishTime => {
                            if upgrade_finish_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UpgradeFinishTime"));
                            }
                            upgrade_finish_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HasSpeedUpSec => {
                            if has_speed_up_sec__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HasSpeedUpSec"));
                            }
                            has_speed_up_sec__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(UnionBuilding {
                    building_id: building_id__,
                    building_level: building_level__,
                    upgrade_finish_time: upgrade_finish_time__,
                    has_speed_up_sec: has_speed_up_sec__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UnionBuilding", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UnionDanceHistory {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.dance_end_time.is_some() {
            len += 1;
        }
        if self.sent_dance_award.is_some() {
            len += 1;
        }
        if self.drawn_dance_award.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UnionDanceHistory", len)?;
        if let Some(v) = self.dance_end_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("DanceEndTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.sent_dance_award.as_ref() {
            struct_ser.serialize_field("SentDanceAward", v)?;
        }
        if let Some(v) = self.drawn_dance_award.as_ref() {
            struct_ser.serialize_field("DrawnDanceAward", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UnionDanceHistory {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DanceEndTime",
            "SentDanceAward",
            "DrawnDanceAward",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DanceEndTime,
            SentDanceAward,
            DrawnDanceAward,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "DanceEndTime" => Ok(GeneratedField::DanceEndTime),
                            "SentDanceAward" => Ok(GeneratedField::SentDanceAward),
                            "DrawnDanceAward" => Ok(GeneratedField::DrawnDanceAward),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UnionDanceHistory;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UnionDanceHistory")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UnionDanceHistory, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dance_end_time__ = None;
                let mut sent_dance_award__ = None;
                let mut drawn_dance_award__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DanceEndTime => {
                            if dance_end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DanceEndTime"));
                            }
                            dance_end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SentDanceAward => {
                            if sent_dance_award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SentDanceAward"));
                            }
                            sent_dance_award__ = map_.next_value()?;
                        }
                        GeneratedField::DrawnDanceAward => {
                            if drawn_dance_award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DrawnDanceAward"));
                            }
                            drawn_dance_award__ = map_.next_value()?;
                        }
                    }
                }
                Ok(UnionDanceHistory {
                    dance_end_time: dance_end_time__,
                    sent_dance_award: sent_dance_award__,
                    drawn_dance_award: drawn_dance_award__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UnionDanceHistory", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UnionData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.unionid.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if self.union_hunt_rank.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UnionData", len)?;
        if let Some(v) = self.unionid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Unionid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("Name", v)?;
        }
        if let Some(v) = self.union_hunt_rank.as_ref() {
            struct_ser.serialize_field("UnionHuntRank", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UnionData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Unionid",
            "Name",
            "UnionHuntRank",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Unionid,
            Name,
            UnionHuntRank,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Unionid" => Ok(GeneratedField::Unionid),
                            "Name" => Ok(GeneratedField::Name),
                            "UnionHuntRank" => Ok(GeneratedField::UnionHuntRank),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UnionData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UnionData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UnionData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut unionid__ = None;
                let mut name__ = None;
                let mut union_hunt_rank__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Unionid => {
                            if unionid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Unionid"));
                            }
                            unionid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::UnionHuntRank => {
                            if union_hunt_rank__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnionHuntRank"));
                            }
                            union_hunt_rank__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(UnionData {
                    unionid: unionid__,
                    name: name__,
                    union_hunt_rank: union_hunt_rank__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UnionData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UnionEScreenInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.e_screen_id.is_some() {
            len += 1;
        }
        if !self.photo_graphs.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UnionEScreenInfo", len)?;
        if let Some(v) = self.e_screen_id.as_ref() {
            struct_ser.serialize_field("EScreenId", v)?;
        }
        if !self.photo_graphs.is_empty() {
            struct_ser.serialize_field("PhotoGraphs", &self.photo_graphs)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UnionEScreenInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EScreenId",
            "PhotoGraphs",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EScreenId,
            PhotoGraphs,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EScreenId" => Ok(GeneratedField::EScreenId),
                            "PhotoGraphs" => Ok(GeneratedField::PhotoGraphs),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UnionEScreenInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UnionEScreenInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UnionEScreenInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut e_screen_id__ = None;
                let mut photo_graphs__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EScreenId => {
                            if e_screen_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EScreenId"));
                            }
                            e_screen_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PhotoGraphs => {
                            if photo_graphs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PhotoGraphs"));
                            }
                            photo_graphs__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(UnionEScreenInfo {
                    e_screen_id: e_screen_id__,
                    photo_graphs: photo_graphs__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UnionEScreenInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UnionHistoryActive {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.union_id.is_some() {
            len += 1;
        }
        if self.active_points.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UnionHistoryActive", len)?;
        if let Some(v) = self.union_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("UnionId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.active_points.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ActivePoints", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UnionHistoryActive {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UnionId",
            "ActivePoints",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UnionId,
            ActivePoints,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UnionId" => Ok(GeneratedField::UnionId),
                            "ActivePoints" => Ok(GeneratedField::ActivePoints),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UnionHistoryActive;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UnionHistoryActive")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UnionHistoryActive, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut union_id__ = None;
                let mut active_points__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UnionId => {
                            if union_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnionId"));
                            }
                            union_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ActivePoints => {
                            if active_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActivePoints"));
                            }
                            active_points__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(UnionHistoryActive {
                    union_id: union_id__,
                    active_points: active_points__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UnionHistoryActive", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UnlockColorInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.color_info_map.is_empty() {
            len += 1;
        }
        if !self.color_block_info_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UnlockColorInfo", len)?;
        if !self.color_info_map.is_empty() {
            struct_ser.serialize_field("ColorInfoMap", &self.color_info_map)?;
        }
        if !self.color_block_info_map.is_empty() {
            struct_ser.serialize_field("ColorBlockInfoMap", &self.color_block_info_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UnlockColorInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ColorInfoMap",
            "ColorBlockInfoMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ColorInfoMap,
            ColorBlockInfoMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ColorInfoMap" => Ok(GeneratedField::ColorInfoMap),
                            "ColorBlockInfoMap" => Ok(GeneratedField::ColorBlockInfoMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UnlockColorInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UnlockColorInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UnlockColorInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut color_info_map__ = None;
                let mut color_block_info_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ColorInfoMap => {
                            if color_info_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ColorInfoMap"));
                            }
                            color_info_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::ColorBlockInfoMap => {
                            if color_block_info_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ColorBlockInfoMap"));
                            }
                            color_block_info_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(UnlockColorInfo {
                    color_info_map: color_info_map__.unwrap_or_default(),
                    color_block_info_map: color_block_info_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UnlockColorInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UnlockEmojiData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.unlock_map.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UnlockEmojiData", len)?;
        if !self.unlock_map.is_empty() {
            struct_ser.serialize_field("UnlockMap", &self.unlock_map)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UnlockEmojiData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UnlockMap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UnlockMap,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UnlockMap" => Ok(GeneratedField::UnlockMap),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UnlockEmojiData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UnlockEmojiData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UnlockEmojiData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut unlock_map__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UnlockMap => {
                            if unlock_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockMap"));
                            }
                            unlock_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(UnlockEmojiData {
                    unlock_map: unlock_map__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UnlockEmojiData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UnlockInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.object_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UnlockInfo", len)?;
        if let Some(v) = self.object_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ObjectId", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UnlockInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ObjectId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ObjectId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "ObjectId" => Ok(GeneratedField::ObjectId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UnlockInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UnlockInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UnlockInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut object_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ObjectId => {
                            if object_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ObjectId"));
                            }
                            object_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(UnlockInfo {
                    object_id: object_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UnlockInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UnlockProficiency {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.unlock_buffer_id.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UnlockProficiency", len)?;
        if !self.unlock_buffer_id.is_empty() {
            struct_ser.serialize_field("UnlockBufferId", &self.unlock_buffer_id)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UnlockProficiency {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UnlockBufferId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UnlockBufferId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UnlockBufferId" => Ok(GeneratedField::UnlockBufferId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UnlockProficiency;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UnlockProficiency")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UnlockProficiency, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut unlock_buffer_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UnlockBufferId => {
                            if unlock_buffer_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnlockBufferId"));
                            }
                            unlock_buffer_id__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(UnlockProficiency {
                    unlock_buffer_id: unlock_buffer_id__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UnlockProficiency", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UpdateStructure {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UpdateStructure", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UpdateStructure {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UpdateStructure;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UpdateStructure")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UpdateStructure, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(UpdateStructure {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UpdateStructure", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UpdateStructureRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.home_id.is_some() {
            len += 1;
        }
        if !self.ops.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UpdateStructureRequest", len)?;
        if let Some(v) = self.home_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("HomeId", ToString::to_string(&v).as_str())?;
        }
        if !self.ops.is_empty() {
            struct_ser.serialize_field("Ops", &self.ops)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UpdateStructureRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HomeId",
            "Ops",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HomeId,
            Ops,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "HomeId" => Ok(GeneratedField::HomeId),
                            "Ops" => Ok(GeneratedField::Ops),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UpdateStructureRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UpdateStructureRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UpdateStructureRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut home_id__ = None;
                let mut ops__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HomeId => {
                            if home_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HomeId"));
                            }
                            home_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Ops => {
                            if ops__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Ops"));
                            }
                            ops__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(UpdateStructureRequest {
                    home_id: home_id__,
                    ops: ops__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UpdateStructureRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UploadTLogBody {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.t_log_name.is_some() {
            len += 1;
        }
        if self.t_log_body.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UploadTLogBody", len)?;
        if let Some(v) = self.t_log_name.as_ref() {
            struct_ser.serialize_field("TLogName", v)?;
        }
        if let Some(v) = self.t_log_body.as_ref() {
            struct_ser.serialize_field("TLogBody", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UploadTLogBody {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TLogName",
            "TLogBody",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TLogName,
            TLogBody,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TLogName" => Ok(GeneratedField::TLogName),
                            "TLogBody" => Ok(GeneratedField::TLogBody),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UploadTLogBody;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UploadTLogBody")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UploadTLogBody, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut t_log_name__ = None;
                let mut t_log_body__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TLogName => {
                            if t_log_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TLogName"));
                            }
                            t_log_name__ = map_.next_value()?;
                        }
                        GeneratedField::TLogBody => {
                            if t_log_body__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TLogBody"));
                            }
                            t_log_body__ = map_.next_value()?;
                        }
                    }
                }
                Ok(UploadTLogBody {
                    t_log_name: t_log_name__,
                    t_log_body: t_log_body__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UploadTLogBody", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UseSkill {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.param.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UseSkill", len)?;
        if let Some(v) = self.param.as_ref() {
            struct_ser.serialize_field("Param", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UseSkill {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Param",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Param,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Param" => Ok(GeneratedField::Param),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UseSkill;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UseSkill")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UseSkill, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut param__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Param => {
                            if param__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Param"));
                            }
                            param__ = map_.next_value()?;
                        }
                    }
                }
                Ok(UseSkill {
                    param: param__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UseSkill", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UseSkillParam {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.skill_uuid.is_some() {
            len += 1;
        }
        if self.skillid.is_some() {
            len += 1;
        }
        if self.skill_level.is_some() {
            len += 1;
        }
        if self.begin_time.is_some() {
            len += 1;
        }
        if self.target_uuid.is_some() {
            len += 1;
        }
        if self.target_pos.is_some() {
            len += 1;
        }
        if self.cur_pos.is_some() {
            len += 1;
        }
        if self.target_part_id.is_some() {
            len += 1;
        }
        if self.target_part_pos.is_some() {
            len += 1;
        }
        if self.is_passive.is_some() {
            len += 1;
        }
        if self.is_activate_roulette.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UseSkillParam", len)?;
        if let Some(v) = self.skill_uuid.as_ref() {
            struct_ser.serialize_field("SkillUuid", v)?;
        }
        if let Some(v) = self.skillid.as_ref() {
            struct_ser.serialize_field("Skillid", v)?;
        }
        if let Some(v) = self.skill_level.as_ref() {
            struct_ser.serialize_field("SkillLevel", v)?;
        }
        if let Some(v) = self.begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.target_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.target_pos.as_ref() {
            struct_ser.serialize_field("TargetPos", v)?;
        }
        if let Some(v) = self.cur_pos.as_ref() {
            struct_ser.serialize_field("CurPos", v)?;
        }
        if let Some(v) = self.target_part_id.as_ref() {
            struct_ser.serialize_field("TargetPartId", v)?;
        }
        if let Some(v) = self.target_part_pos.as_ref() {
            struct_ser.serialize_field("TargetPartPos", v)?;
        }
        if let Some(v) = self.is_passive.as_ref() {
            struct_ser.serialize_field("IsPassive", v)?;
        }
        if let Some(v) = self.is_activate_roulette.as_ref() {
            struct_ser.serialize_field("IsActivateRoulette", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UseSkillParam {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SkillUuid",
            "Skillid",
            "SkillLevel",
            "BeginTime",
            "TargetUuid",
            "TargetPos",
            "CurPos",
            "TargetPartId",
            "TargetPartPos",
            "IsPassive",
            "IsActivateRoulette",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SkillUuid,
            Skillid,
            SkillLevel,
            BeginTime,
            TargetUuid,
            TargetPos,
            CurPos,
            TargetPartId,
            TargetPartPos,
            IsPassive,
            IsActivateRoulette,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SkillUuid" => Ok(GeneratedField::SkillUuid),
                            "Skillid" => Ok(GeneratedField::Skillid),
                            "SkillLevel" => Ok(GeneratedField::SkillLevel),
                            "BeginTime" => Ok(GeneratedField::BeginTime),
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            "TargetPos" => Ok(GeneratedField::TargetPos),
                            "CurPos" => Ok(GeneratedField::CurPos),
                            "TargetPartId" => Ok(GeneratedField::TargetPartId),
                            "TargetPartPos" => Ok(GeneratedField::TargetPartPos),
                            "IsPassive" => Ok(GeneratedField::IsPassive),
                            "IsActivateRoulette" => Ok(GeneratedField::IsActivateRoulette),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UseSkillParam;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UseSkillParam")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UseSkillParam, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut skill_uuid__ = None;
                let mut skillid__ = None;
                let mut skill_level__ = None;
                let mut begin_time__ = None;
                let mut target_uuid__ = None;
                let mut target_pos__ = None;
                let mut cur_pos__ = None;
                let mut target_part_id__ = None;
                let mut target_part_pos__ = None;
                let mut is_passive__ = None;
                let mut is_activate_roulette__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SkillUuid => {
                            if skill_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillUuid"));
                            }
                            skill_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Skillid => {
                            if skillid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Skillid"));
                            }
                            skillid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SkillLevel => {
                            if skill_level__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SkillLevel"));
                            }
                            skill_level__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::BeginTime => {
                            if begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeginTime"));
                            }
                            begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetPos => {
                            if target_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetPos"));
                            }
                            target_pos__ = map_.next_value()?;
                        }
                        GeneratedField::CurPos => {
                            if cur_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurPos"));
                            }
                            cur_pos__ = map_.next_value()?;
                        }
                        GeneratedField::TargetPartId => {
                            if target_part_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetPartId"));
                            }
                            target_part_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetPartPos => {
                            if target_part_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetPartPos"));
                            }
                            target_part_pos__ = map_.next_value()?;
                        }
                        GeneratedField::IsPassive => {
                            if is_passive__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsPassive"));
                            }
                            is_passive__ = map_.next_value()?;
                        }
                        GeneratedField::IsActivateRoulette => {
                            if is_activate_roulette__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsActivateRoulette"));
                            }
                            is_activate_roulette__ = map_.next_value()?;
                        }
                    }
                }
                Ok(UseSkillParam {
                    skill_uuid: skill_uuid__,
                    skillid: skillid__,
                    skill_level: skill_level__,
                    begin_time: begin_time__,
                    target_uuid: target_uuid__,
                    target_pos: target_pos__,
                    cur_pos: cur_pos__,
                    target_part_id: target_part_id__,
                    target_part_pos: target_part_pos__,
                    is_passive: is_passive__,
                    is_activate_roulette: is_activate_roulette__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UseSkillParam", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UseSlot {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_request.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UseSlot", len)?;
        if let Some(v) = self.v_request.as_ref() {
            struct_ser.serialize_field("VRequest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UseSlot {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VRequest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VRequest,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VRequest" => Ok(GeneratedField::VRequest),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UseSlot;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UseSlot")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UseSlot, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_request__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VRequest => {
                            if v_request__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VRequest"));
                            }
                            v_request__ = map_.next_value()?;
                        }
                    }
                }
                Ok(UseSlot {
                    v_request: v_request__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UseSlot", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UseSlotRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.slot_id.is_some() {
            len += 1;
        }
        if self.use_type.is_some() {
            len += 1;
        }
        if self.extra_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UseSlotRequest", len)?;
        if let Some(v) = self.slot_id.as_ref() {
            struct_ser.serialize_field("SlotId", v)?;
        }
        if let Some(v) = self.use_type.as_ref() {
            let v = EUseSlotType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("UseType", &v)?;
        }
        if let Some(v) = self.extra_data.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ExtraData", pbjson::private::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UseSlotRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SlotId",
            "UseType",
            "ExtraData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SlotId,
            UseType,
            ExtraData,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SlotId" => Ok(GeneratedField::SlotId),
                            "UseType" => Ok(GeneratedField::UseType),
                            "ExtraData" => Ok(GeneratedField::ExtraData),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UseSlotRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UseSlotRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UseSlotRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut slot_id__ = None;
                let mut use_type__ = None;
                let mut extra_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SlotId => {
                            if slot_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SlotId"));
                            }
                            slot_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::UseType => {
                            if use_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UseType"));
                            }
                            use_type__ = map_.next_value::<::std::option::Option<EUseSlotType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ExtraData => {
                            if extra_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExtraData"));
                            }
                            extra_data__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(UseSlotRequest {
                    slot_id: slot_id__,
                    use_type: use_type__,
                    extra_data: extra_data__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UseSlotRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserActivityInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.start_time.is_some() {
            len += 1;
        }
        if self.end_time.is_some() {
            len += 1;
        }
        if !self.rewards.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserActivityInfo", len)?;
        if let Some(v) = self.start_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("StartTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.end_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("EndTime", ToString::to_string(&v).as_str())?;
        }
        if !self.rewards.is_empty() {
            struct_ser.serialize_field("Rewards", &self.rewards)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserActivityInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "StartTime",
            "EndTime",
            "Rewards",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StartTime,
            EndTime,
            Rewards,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "StartTime" => Ok(GeneratedField::StartTime),
                            "EndTime" => Ok(GeneratedField::EndTime),
                            "Rewards" => Ok(GeneratedField::Rewards),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserActivityInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserActivityInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserActivityInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut start_time__ = None;
                let mut end_time__ = None;
                let mut rewards__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StartTime => {
                            if start_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("StartTime"));
                            }
                            start_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EndTime => {
                            if end_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EndTime"));
                            }
                            end_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Rewards => {
                            if rewards__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Rewards"));
                            }
                            rewards__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(UserActivityInfo {
                    start_time: start_time__,
                    end_time: end_time__,
                    rewards: rewards__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserActivityInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserActivityList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.activities.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserActivityList", len)?;
        if !self.activities.is_empty() {
            struct_ser.serialize_field("Activities", &self.activities)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserActivityList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Activities",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Activities,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Activities" => Ok(GeneratedField::Activities),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserActivityList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserActivityList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserActivityList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut activities__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Activities => {
                            if activities__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Activities"));
                            }
                            activities__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(UserActivityList {
                    activities: activities__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserActivityList", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserActivityRewardInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        if !self.functions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserActivityRewardInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("Status", v)?;
        }
        if !self.functions.is_empty() {
            struct_ser.serialize_field("Functions", &self.functions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserActivityRewardInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "Status",
            "Functions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Status,
            Functions,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "Status" => Ok(GeneratedField::Status),
                            "Functions" => Ok(GeneratedField::Functions),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserActivityRewardInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserActivityRewardInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserActivityRewardInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut status__ = None;
                let mut functions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Status"));
                            }
                            status__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Functions => {
                            if functions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Functions"));
                            }
                            functions__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                    }
                }
                Ok(UserActivityRewardInfo {
                    id: id__,
                    status: status__,
                    functions: functions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserActivityRewardInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserAttrData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.state.is_some() {
            len += 1;
        }
        if self.fight_point.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserAttrData", len)?;
        if let Some(v) = self.state.as_ref() {
            struct_ser.serialize_field("State", v)?;
        }
        if let Some(v) = self.fight_point.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("FightPoint", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserAttrData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "State",
            "FightPoint",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            State,
            FightPoint,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "State" => Ok(GeneratedField::State),
                            "FightPoint" => Ok(GeneratedField::FightPoint),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserAttrData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserAttrData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserAttrData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut state__ = None;
                let mut fight_point__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::State => {
                            if state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("State"));
                            }
                            state__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FightPoint => {
                            if fight_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FightPoint"));
                            }
                            fight_point__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(UserAttrData {
                    state: state__,
                    fight_point: fight_point__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserAttrData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserControlInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_begin.is_some() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        if self.secondary_type.is_some() {
            len += 1;
        }
        if self.remain_time.is_some() {
            len += 1;
        }
        if self.step.is_some() {
            len += 1;
        }
        if self.hor_velocity.is_some() {
            len += 1;
        }
        if self.ver_velocity.is_some() {
            len += 1;
        }
        if self.pitch_angle.is_some() {
            len += 1;
        }
        if self.time_stamp.is_some() {
            len += 1;
        }
        if self.run_dir.is_some() {
            len += 1;
        }
        if self.normal.is_some() {
            len += 1;
        }
        if self.cur_pos.is_some() {
            len += 1;
        }
        if self.dest_pos.is_some() {
            len += 1;
        }
        if self.move_version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserControlInfo", len)?;
        if let Some(v) = self.is_begin.as_ref() {
            struct_ser.serialize_field("IsBegin", v)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("Type", v)?;
        }
        if let Some(v) = self.secondary_type.as_ref() {
            struct_ser.serialize_field("SecondaryType", v)?;
        }
        if let Some(v) = self.remain_time.as_ref() {
            struct_ser.serialize_field("RemainTime", v)?;
        }
        if let Some(v) = self.step.as_ref() {
            struct_ser.serialize_field("Step", v)?;
        }
        if let Some(v) = self.hor_velocity.as_ref() {
            struct_ser.serialize_field("HorVelocity", v)?;
        }
        if let Some(v) = self.ver_velocity.as_ref() {
            struct_ser.serialize_field("VerVelocity", v)?;
        }
        if let Some(v) = self.pitch_angle.as_ref() {
            struct_ser.serialize_field("PitchAngle", v)?;
        }
        if let Some(v) = self.time_stamp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TimeStamp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.run_dir.as_ref() {
            struct_ser.serialize_field("RunDir", v)?;
        }
        if let Some(v) = self.normal.as_ref() {
            struct_ser.serialize_field("Normal", v)?;
        }
        if let Some(v) = self.cur_pos.as_ref() {
            struct_ser.serialize_field("CurPos", v)?;
        }
        if let Some(v) = self.dest_pos.as_ref() {
            struct_ser.serialize_field("DestPos", v)?;
        }
        if let Some(v) = self.move_version.as_ref() {
            struct_ser.serialize_field("MoveVersion", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserControlInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "IsBegin",
            "Type",
            "SecondaryType",
            "RemainTime",
            "Step",
            "HorVelocity",
            "VerVelocity",
            "PitchAngle",
            "TimeStamp",
            "RunDir",
            "Normal",
            "CurPos",
            "DestPos",
            "MoveVersion",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsBegin,
            Type,
            SecondaryType,
            RemainTime,
            Step,
            HorVelocity,
            VerVelocity,
            PitchAngle,
            TimeStamp,
            RunDir,
            Normal,
            CurPos,
            DestPos,
            MoveVersion,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "IsBegin" => Ok(GeneratedField::IsBegin),
                            "Type" => Ok(GeneratedField::Type),
                            "SecondaryType" => Ok(GeneratedField::SecondaryType),
                            "RemainTime" => Ok(GeneratedField::RemainTime),
                            "Step" => Ok(GeneratedField::Step),
                            "HorVelocity" => Ok(GeneratedField::HorVelocity),
                            "VerVelocity" => Ok(GeneratedField::VerVelocity),
                            "PitchAngle" => Ok(GeneratedField::PitchAngle),
                            "TimeStamp" => Ok(GeneratedField::TimeStamp),
                            "RunDir" => Ok(GeneratedField::RunDir),
                            "Normal" => Ok(GeneratedField::Normal),
                            "CurPos" => Ok(GeneratedField::CurPos),
                            "DestPos" => Ok(GeneratedField::DestPos),
                            "MoveVersion" => Ok(GeneratedField::MoveVersion),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserControlInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserControlInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserControlInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_begin__ = None;
                let mut r#type__ = None;
                let mut secondary_type__ = None;
                let mut remain_time__ = None;
                let mut step__ = None;
                let mut hor_velocity__ = None;
                let mut ver_velocity__ = None;
                let mut pitch_angle__ = None;
                let mut time_stamp__ = None;
                let mut run_dir__ = None;
                let mut normal__ = None;
                let mut cur_pos__ = None;
                let mut dest_pos__ = None;
                let mut move_version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsBegin => {
                            if is_begin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsBegin"));
                            }
                            is_begin__ = map_.next_value()?;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SecondaryType => {
                            if secondary_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SecondaryType"));
                            }
                            secondary_type__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RemainTime => {
                            if remain_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RemainTime"));
                            }
                            remain_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Step => {
                            if step__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Step"));
                            }
                            step__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::HorVelocity => {
                            if hor_velocity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HorVelocity"));
                            }
                            hor_velocity__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::VerVelocity => {
                            if ver_velocity__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VerVelocity"));
                            }
                            ver_velocity__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PitchAngle => {
                            if pitch_angle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PitchAngle"));
                            }
                            pitch_angle__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TimeStamp => {
                            if time_stamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TimeStamp"));
                            }
                            time_stamp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RunDir => {
                            if run_dir__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RunDir"));
                            }
                            run_dir__ = map_.next_value()?;
                        }
                        GeneratedField::Normal => {
                            if normal__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Normal"));
                            }
                            normal__ = map_.next_value()?;
                        }
                        GeneratedField::CurPos => {
                            if cur_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurPos"));
                            }
                            cur_pos__ = map_.next_value()?;
                        }
                        GeneratedField::DestPos => {
                            if dest_pos__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DestPos"));
                            }
                            dest_pos__ = map_.next_value()?;
                        }
                        GeneratedField::MoveVersion => {
                            if move_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MoveVersion"));
                            }
                            move_version__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(UserControlInfo {
                    is_begin: is_begin__,
                    r#type: r#type__,
                    secondary_type: secondary_type__,
                    remain_time: remain_time__,
                    step: step__,
                    hor_velocity: hor_velocity__,
                    ver_velocity: ver_velocity__,
                    pitch_angle: pitch_angle__,
                    time_stamp: time_stamp__,
                    run_dir: run_dir__,
                    normal: normal__,
                    cur_pos: cur_pos__,
                    dest_pos: dest_pos__,
                    move_version: move_version__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserControlInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserDoAction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_selected_str.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserDoAction", len)?;
        if let Some(v) = self.v_selected_str.as_ref() {
            struct_ser.serialize_field("VSelectedStr", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserDoAction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VSelectedStr",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VSelectedStr,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VSelectedStr" => Ok(GeneratedField::VSelectedStr),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserDoAction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserDoAction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserDoAction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_selected_str__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VSelectedStr => {
                            if v_selected_str__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VSelectedStr"));
                            }
                            v_selected_str__ = map_.next_value()?;
                        }
                    }
                }
                Ok(UserDoAction {
                    v_selected_str: v_selected_str__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserDoAction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserFightAttr {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cur_hp.is_some() {
            len += 1;
        }
        if self.max_hp.is_some() {
            len += 1;
        }
        if self.origin_energy.is_some() {
            len += 1;
        }
        if !self.resource_ids.is_empty() {
            len += 1;
        }
        if !self.resources.is_empty() {
            len += 1;
        }
        if self.is_dead.is_some() {
            len += 1;
        }
        if self.dead_time.is_some() {
            len += 1;
        }
        if self.revive_id.is_some() {
            len += 1;
        }
        if !self.cd_info.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserFightAttr", len)?;
        if let Some(v) = self.cur_hp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("CurHp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.max_hp.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("MaxHp", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.origin_energy.as_ref() {
            struct_ser.serialize_field("OriginEnergy", v)?;
        }
        if !self.resource_ids.is_empty() {
            struct_ser.serialize_field("ResourceIds", &self.resource_ids)?;
        }
        if !self.resources.is_empty() {
            struct_ser.serialize_field("Resources", &self.resources)?;
        }
        if let Some(v) = self.is_dead.as_ref() {
            struct_ser.serialize_field("IsDead", v)?;
        }
        if let Some(v) = self.dead_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("DeadTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.revive_id.as_ref() {
            struct_ser.serialize_field("ReviveId", v)?;
        }
        if !self.cd_info.is_empty() {
            struct_ser.serialize_field("CdInfo", &self.cd_info)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserFightAttr {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CurHp",
            "MaxHp",
            "OriginEnergy",
            "ResourceIds",
            "Resources",
            "IsDead",
            "DeadTime",
            "ReviveId",
            "CdInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CurHp,
            MaxHp,
            OriginEnergy,
            ResourceIds,
            Resources,
            IsDead,
            DeadTime,
            ReviveId,
            CdInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CurHp" => Ok(GeneratedField::CurHp),
                            "MaxHp" => Ok(GeneratedField::MaxHp),
                            "OriginEnergy" => Ok(GeneratedField::OriginEnergy),
                            "ResourceIds" => Ok(GeneratedField::ResourceIds),
                            "Resources" => Ok(GeneratedField::Resources),
                            "IsDead" => Ok(GeneratedField::IsDead),
                            "DeadTime" => Ok(GeneratedField::DeadTime),
                            "ReviveId" => Ok(GeneratedField::ReviveId),
                            "CdInfo" => Ok(GeneratedField::CdInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserFightAttr;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserFightAttr")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserFightAttr, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cur_hp__ = None;
                let mut max_hp__ = None;
                let mut origin_energy__ = None;
                let mut resource_ids__ = None;
                let mut resources__ = None;
                let mut is_dead__ = None;
                let mut dead_time__ = None;
                let mut revive_id__ = None;
                let mut cd_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CurHp => {
                            if cur_hp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CurHp"));
                            }
                            cur_hp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxHp => {
                            if max_hp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaxHp"));
                            }
                            max_hp__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OriginEnergy => {
                            if origin_energy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("OriginEnergy"));
                            }
                            origin_energy__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ResourceIds => {
                            if resource_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ResourceIds"));
                            }
                            resource_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::Resources => {
                            if resources__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Resources"));
                            }
                            resources__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::IsDead => {
                            if is_dead__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsDead"));
                            }
                            is_dead__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DeadTime => {
                            if dead_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DeadTime"));
                            }
                            dead_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReviveId => {
                            if revive_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReviveId"));
                            }
                            revive_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CdInfo => {
                            if cd_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CdInfo"));
                            }
                            cd_info__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(UserFightAttr {
                    cur_hp: cur_hp__,
                    max_hp: max_hp__,
                    origin_energy: origin_energy__,
                    resource_ids: resource_ids__.unwrap_or_default(),
                    resources: resources__.unwrap_or_default(),
                    is_dead: is_dead__,
                    dead_time: dead_time__,
                    revive_id: revive_id__,
                    cd_info: cd_info__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserFightAttr", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserNotifyTrigger {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.v_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserNotifyTrigger", len)?;
        if let Some(v) = self.v_info.as_ref() {
            struct_ser.serialize_field("VInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserNotifyTrigger {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            VInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "VInfo" => Ok(GeneratedField::VInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserNotifyTrigger;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserNotifyTrigger")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserNotifyTrigger, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut v_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::VInfo => {
                            if v_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("VInfo"));
                            }
                            v_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(UserNotifyTrigger {
                    v_info: v_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserNotifyTrigger", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserNotifyTriggerInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.target_uuid.is_some() {
            len += 1;
        }
        if self.trigger_actor_type.is_some() {
            len += 1;
        }
        if self.trigger_actor_is_summon.is_some() {
            len += 1;
        }
        if self.trigger_actor_instance_id.is_some() {
            len += 1;
        }
        if self.trigger_actor_table_uid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserNotifyTriggerInfo", len)?;
        if let Some(v) = self.r#type.as_ref() {
            let v = ENotifyTrigger::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("Type", &v)?;
        }
        if let Some(v) = self.target_uuid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TargetUuid", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.trigger_actor_type.as_ref() {
            let v = EEntityType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("TriggerActorType", &v)?;
        }
        if let Some(v) = self.trigger_actor_is_summon.as_ref() {
            struct_ser.serialize_field("TriggerActorIsSummon", v)?;
        }
        if let Some(v) = self.trigger_actor_instance_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TriggerActorInstanceId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.trigger_actor_table_uid.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("TriggerActorTableUid", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserNotifyTriggerInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Type",
            "TargetUuid",
            "TriggerActorType",
            "TriggerActorIsSummon",
            "TriggerActorInstanceId",
            "TriggerActorTableUid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            TargetUuid,
            TriggerActorType,
            TriggerActorIsSummon,
            TriggerActorInstanceId,
            TriggerActorTableUid,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Type" => Ok(GeneratedField::Type),
                            "TargetUuid" => Ok(GeneratedField::TargetUuid),
                            "TriggerActorType" => Ok(GeneratedField::TriggerActorType),
                            "TriggerActorIsSummon" => Ok(GeneratedField::TriggerActorIsSummon),
                            "TriggerActorInstanceId" => Ok(GeneratedField::TriggerActorInstanceId),
                            "TriggerActorTableUid" => Ok(GeneratedField::TriggerActorTableUid),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserNotifyTriggerInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserNotifyTriggerInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserNotifyTriggerInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut target_uuid__ = None;
                let mut trigger_actor_type__ = None;
                let mut trigger_actor_is_summon__ = None;
                let mut trigger_actor_instance_id__ = None;
                let mut trigger_actor_table_uid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<ENotifyTrigger>>()?.map(|x| x as i32);
                        }
                        GeneratedField::TargetUuid => {
                            if target_uuid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetUuid"));
                            }
                            target_uuid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TriggerActorType => {
                            if trigger_actor_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TriggerActorType"));
                            }
                            trigger_actor_type__ = map_.next_value::<::std::option::Option<EEntityType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::TriggerActorIsSummon => {
                            if trigger_actor_is_summon__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TriggerActorIsSummon"));
                            }
                            trigger_actor_is_summon__ = map_.next_value()?;
                        }
                        GeneratedField::TriggerActorInstanceId => {
                            if trigger_actor_instance_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TriggerActorInstanceId"));
                            }
                            trigger_actor_instance_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TriggerActorTableUid => {
                            if trigger_actor_table_uid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TriggerActorTableUid"));
                            }
                            trigger_actor_table_uid__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(UserNotifyTriggerInfo {
                    r#type: r#type__,
                    target_uuid: target_uuid__,
                    trigger_actor_type: trigger_actor_type__,
                    trigger_actor_is_summon: trigger_actor_is_summon__,
                    trigger_actor_instance_id: trigger_actor_instance_id__,
                    trigger_actor_table_uid: trigger_actor_table_uid__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserNotifyTriggerInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserRecommendPlayData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.play_mail.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserRecommendPlayData", len)?;
        if !self.play_mail.is_empty() {
            let v: std::collections::HashMap<_, _> = self.play_mail.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("PlayMail", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserRecommendPlayData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PlayMail",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PlayMail,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "PlayMail" => Ok(GeneratedField::PlayMail),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserRecommendPlayData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserRecommendPlayData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserRecommendPlayData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut play_mail__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PlayMail => {
                            if play_mail__.is_some() {
                                return Err(serde::de::Error::duplicate_field("PlayMail"));
                            }
                            play_mail__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i32>, ::pbjson::private::NumberDeserialize<i64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                    }
                }
                Ok(UserRecommendPlayData {
                    play_mail: play_mail__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserRecommendPlayData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserSceneInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scene_id.is_some() {
            len += 1;
        }
        if self.scene_guid.is_some() {
            len += 1;
        }
        if self.line_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserSceneInfo", len)?;
        if let Some(v) = self.scene_id.as_ref() {
            struct_ser.serialize_field("SceneId", v)?;
        }
        if let Some(v) = self.scene_guid.as_ref() {
            struct_ser.serialize_field("SceneGuid", v)?;
        }
        if let Some(v) = self.line_id.as_ref() {
            struct_ser.serialize_field("LineId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserSceneInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SceneId",
            "SceneGuid",
            "LineId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SceneId,
            SceneGuid,
            LineId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SceneId" => Ok(GeneratedField::SceneId),
                            "SceneGuid" => Ok(GeneratedField::SceneGuid),
                            "LineId" => Ok(GeneratedField::LineId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserSceneInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserSceneInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserSceneInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scene_id__ = None;
                let mut scene_guid__ = None;
                let mut line_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SceneId => {
                            if scene_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneId"));
                            }
                            scene_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SceneGuid => {
                            if scene_guid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SceneGuid"));
                            }
                            scene_guid__ = map_.next_value()?;
                        }
                        GeneratedField::LineId => {
                            if line_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LineId"));
                            }
                            line_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(UserSceneInfo {
                    scene_id: scene_id__,
                    scene_guid: scene_guid__,
                    line_id: line_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserSceneInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserUnion {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.union_id.is_some() {
            len += 1;
        }
        if self.next_join_time.is_some() {
            len += 1;
        }
        if !self.req_union_times.is_empty() {
            len += 1;
        }
        if self.join_flag.is_some() {
            len += 1;
        }
        if !self.collected_ids.is_empty() {
            len += 1;
        }
        if self.active_award_reset_time.is_some() {
            len += 1;
        }
        if !self.received_award_ids.is_empty() {
            len += 1;
        }
        if !self.history_active_points.is_empty() {
            len += 1;
        }
        if self.active_last_refresh_time.is_some() {
            len += 1;
        }
        if !self.finish_daily_active_ids.is_empty() {
            len += 1;
        }
        if self.leave_time.is_some() {
            len += 1;
        }
        if self.dance_record.is_some() {
            len += 1;
        }
        if self.user_union_hunt_info.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserUnion", len)?;
        if let Some(v) = self.union_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("UnionId", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.next_join_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("NextJoinTime", ToString::to_string(&v).as_str())?;
        }
        if !self.req_union_times.is_empty() {
            let v: std::collections::HashMap<_, _> = self.req_union_times.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("ReqUnionTimes", &v)?;
        }
        if let Some(v) = self.join_flag.as_ref() {
            struct_ser.serialize_field("JoinFlag", v)?;
        }
        if !self.collected_ids.is_empty() {
            struct_ser.serialize_field("CollectedIds", &self.collected_ids.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if let Some(v) = self.active_award_reset_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ActiveAwardResetTime", ToString::to_string(&v).as_str())?;
        }
        if !self.received_award_ids.is_empty() {
            struct_ser.serialize_field("ReceivedAwardIds", &self.received_award_ids)?;
        }
        if !self.history_active_points.is_empty() {
            struct_ser.serialize_field("HistoryActivePoints", &self.history_active_points)?;
        }
        if let Some(v) = self.active_last_refresh_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ActiveLastRefreshTime", ToString::to_string(&v).as_str())?;
        }
        if !self.finish_daily_active_ids.is_empty() {
            struct_ser.serialize_field("FinishDailyActiveIds", &self.finish_daily_active_ids)?;
        }
        if let Some(v) = self.leave_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LeaveTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.dance_record.as_ref() {
            struct_ser.serialize_field("DanceRecord", v)?;
        }
        if let Some(v) = self.user_union_hunt_info.as_ref() {
            struct_ser.serialize_field("UserUnionHuntInfo", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserUnion {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UnionId",
            "NextJoinTime",
            "ReqUnionTimes",
            "JoinFlag",
            "CollectedIds",
            "ActiveAwardResetTime",
            "ReceivedAwardIds",
            "HistoryActivePoints",
            "ActiveLastRefreshTime",
            "FinishDailyActiveIds",
            "LeaveTime",
            "DanceRecord",
            "UserUnionHuntInfo",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            UnionId,
            NextJoinTime,
            ReqUnionTimes,
            JoinFlag,
            CollectedIds,
            ActiveAwardResetTime,
            ReceivedAwardIds,
            HistoryActivePoints,
            ActiveLastRefreshTime,
            FinishDailyActiveIds,
            LeaveTime,
            DanceRecord,
            UserUnionHuntInfo,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "UnionId" => Ok(GeneratedField::UnionId),
                            "NextJoinTime" => Ok(GeneratedField::NextJoinTime),
                            "ReqUnionTimes" => Ok(GeneratedField::ReqUnionTimes),
                            "JoinFlag" => Ok(GeneratedField::JoinFlag),
                            "CollectedIds" => Ok(GeneratedField::CollectedIds),
                            "ActiveAwardResetTime" => Ok(GeneratedField::ActiveAwardResetTime),
                            "ReceivedAwardIds" => Ok(GeneratedField::ReceivedAwardIds),
                            "HistoryActivePoints" => Ok(GeneratedField::HistoryActivePoints),
                            "ActiveLastRefreshTime" => Ok(GeneratedField::ActiveLastRefreshTime),
                            "FinishDailyActiveIds" => Ok(GeneratedField::FinishDailyActiveIds),
                            "LeaveTime" => Ok(GeneratedField::LeaveTime),
                            "DanceRecord" => Ok(GeneratedField::DanceRecord),
                            "UserUnionHuntInfo" => Ok(GeneratedField::UserUnionHuntInfo),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserUnion;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserUnion")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserUnion, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut union_id__ = None;
                let mut next_join_time__ = None;
                let mut req_union_times__ = None;
                let mut join_flag__ = None;
                let mut collected_ids__ = None;
                let mut active_award_reset_time__ = None;
                let mut received_award_ids__ = None;
                let mut history_active_points__ = None;
                let mut active_last_refresh_time__ = None;
                let mut finish_daily_active_ids__ = None;
                let mut leave_time__ = None;
                let mut dance_record__ = None;
                let mut user_union_hunt_info__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::UnionId => {
                            if union_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UnionId"));
                            }
                            union_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextJoinTime => {
                            if next_join_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NextJoinTime"));
                            }
                            next_join_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReqUnionTimes => {
                            if req_union_times__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReqUnionTimes"));
                            }
                            req_union_times__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<i64>, ::pbjson::private::NumberDeserialize<u64>>>()?
                                    .into_iter().map(|(k,v)| (k.0, v.0)).collect()
                            );
                        }
                        GeneratedField::JoinFlag => {
                            if join_flag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("JoinFlag"));
                            }
                            join_flag__ = map_.next_value()?;
                        }
                        GeneratedField::CollectedIds => {
                            if collected_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CollectedIds"));
                            }
                            collected_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::ActiveAwardResetTime => {
                            if active_award_reset_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActiveAwardResetTime"));
                            }
                            active_award_reset_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReceivedAwardIds => {
                            if received_award_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ReceivedAwardIds"));
                            }
                            received_award_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::HistoryActivePoints => {
                            if history_active_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HistoryActivePoints"));
                            }
                            history_active_points__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ActiveLastRefreshTime => {
                            if active_last_refresh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ActiveLastRefreshTime"));
                            }
                            active_last_refresh_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FinishDailyActiveIds => {
                            if finish_daily_active_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FinishDailyActiveIds"));
                            }
                            finish_daily_active_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::LeaveTime => {
                            if leave_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LeaveTime"));
                            }
                            leave_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DanceRecord => {
                            if dance_record__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DanceRecord"));
                            }
                            dance_record__ = map_.next_value()?;
                        }
                        GeneratedField::UserUnionHuntInfo => {
                            if user_union_hunt_info__.is_some() {
                                return Err(serde::de::Error::duplicate_field("UserUnionHuntInfo"));
                            }
                            user_union_hunt_info__ = map_.next_value()?;
                        }
                    }
                }
                Ok(UserUnion {
                    union_id: union_id__,
                    next_join_time: next_join_time__,
                    req_union_times: req_union_times__.unwrap_or_default(),
                    join_flag: join_flag__,
                    collected_ids: collected_ids__.unwrap_or_default(),
                    active_award_reset_time: active_award_reset_time__,
                    received_award_ids: received_award_ids__.unwrap_or_default(),
                    history_active_points: history_active_points__.unwrap_or_default(),
                    active_last_refresh_time: active_last_refresh_time__,
                    finish_daily_active_ids: finish_daily_active_ids__.unwrap_or_default(),
                    leave_time: leave_time__,
                    dance_record: dance_record__,
                    user_union_hunt_info: user_union_hunt_info__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserUnion", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserUnionHuntInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.hunt_rank.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.UserUnionHuntInfo", len)?;
        if let Some(v) = self.hunt_rank.as_ref() {
            struct_ser.serialize_field("HuntRank", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserUnionHuntInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HuntRank",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HuntRank,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "HuntRank" => Ok(GeneratedField::HuntRank),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserUnionHuntInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.UserUnionHuntInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserUnionHuntInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut hunt_rank__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HuntRank => {
                            if hunt_rank__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HuntRank"));
                            }
                            hunt_rank__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(UserUnionHuntInfo {
                    hunt_rank: hunt_rank__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.UserUnionHuntInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Vector2 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.x.is_some() {
            len += 1;
        }
        if self.y.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Vector2", len)?;
        if let Some(v) = self.x.as_ref() {
            struct_ser.serialize_field("X", v)?;
        }
        if let Some(v) = self.y.as_ref() {
            struct_ser.serialize_field("Y", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Vector2 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "X",
            "Y",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            X,
            Y,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "X" => Ok(GeneratedField::X),
                            "Y" => Ok(GeneratedField::Y),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Vector2;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Vector2")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Vector2, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut x__ = None;
                let mut y__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::X => {
                            if x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("X"));
                            }
                            x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Y => {
                            if y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Y"));
                            }
                            y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Vector2 {
                    x: x__,
                    y: y__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Vector2", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Vector3 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.x.is_some() {
            len += 1;
        }
        if self.y.is_some() {
            len += 1;
        }
        if self.z.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Vector3", len)?;
        if let Some(v) = self.x.as_ref() {
            struct_ser.serialize_field("X", v)?;
        }
        if let Some(v) = self.y.as_ref() {
            struct_ser.serialize_field("Y", v)?;
        }
        if let Some(v) = self.z.as_ref() {
            struct_ser.serialize_field("Z", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Vector3 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "X",
            "Y",
            "Z",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            X,
            Y,
            Z,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "X" => Ok(GeneratedField::X),
                            "Y" => Ok(GeneratedField::Y),
                            "Z" => Ok(GeneratedField::Z),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Vector3;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Vector3")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Vector3, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut x__ = None;
                let mut y__ = None;
                let mut z__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::X => {
                            if x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("X"));
                            }
                            x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Y => {
                            if y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Y"));
                            }
                            y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Z => {
                            if z__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Z"));
                            }
                            z__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Vector3 {
                    x: x__,
                    y: y__,
                    z: z__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Vector3", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Vector4 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.x.is_some() {
            len += 1;
        }
        if self.y.is_some() {
            len += 1;
        }
        if self.z.is_some() {
            len += 1;
        }
        if self.w.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.Vector4", len)?;
        if let Some(v) = self.x.as_ref() {
            struct_ser.serialize_field("X", v)?;
        }
        if let Some(v) = self.y.as_ref() {
            struct_ser.serialize_field("Y", v)?;
        }
        if let Some(v) = self.z.as_ref() {
            struct_ser.serialize_field("Z", v)?;
        }
        if let Some(v) = self.w.as_ref() {
            struct_ser.serialize_field("W", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Vector4 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "X",
            "Y",
            "Z",
            "W",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            X,
            Y,
            Z,
            W,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "X" => Ok(GeneratedField::X),
                            "Y" => Ok(GeneratedField::Y),
                            "Z" => Ok(GeneratedField::Z),
                            "W" => Ok(GeneratedField::W),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Vector4;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.Vector4")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Vector4, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut x__ = None;
                let mut y__ = None;
                let mut z__ = None;
                let mut w__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::X => {
                            if x__.is_some() {
                                return Err(serde::de::Error::duplicate_field("X"));
                            }
                            x__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Y => {
                            if y__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Y"));
                            }
                            y__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Z => {
                            if z__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Z"));
                            }
                            z__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::W => {
                            if w__.is_some() {
                                return Err(serde::de::Error::duplicate_field("W"));
                            }
                            w__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(Vector4 {
                    x: x__,
                    y: y__,
                    z: z__,
                    w: w__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.Vector4", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WarehouseData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.warehouse_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.WarehouseData", len)?;
        if let Some(v) = self.warehouse_id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("WarehouseId", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WarehouseData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "WarehouseId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            WarehouseId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "WarehouseId" => Ok(GeneratedField::WarehouseId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WarehouseData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.WarehouseData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WarehouseData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut warehouse_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::WarehouseId => {
                            if warehouse_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WarehouseId"));
                            }
                            warehouse_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WarehouseData {
                    warehouse_id: warehouse_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.WarehouseData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WeeklyTowerRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.begin_time.is_some() {
            len += 1;
        }
        if self.max_climb_up_id.is_some() {
            len += 1;
        }
        if !self.award_climb_up_ids.is_empty() {
            len += 1;
        }
        if self.rule_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.WeeklyTowerRecord", len)?;
        if let Some(v) = self.begin_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("BeginTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.max_climb_up_id.as_ref() {
            struct_ser.serialize_field("MaxClimbUpId", v)?;
        }
        if !self.award_climb_up_ids.is_empty() {
            struct_ser.serialize_field("AwardClimbUpIds", &self.award_climb_up_ids)?;
        }
        if let Some(v) = self.rule_id.as_ref() {
            struct_ser.serialize_field("RuleId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WeeklyTowerRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "BeginTime",
            "MaxClimbUpId",
            "AwardClimbUpIds",
            "RuleId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            BeginTime,
            MaxClimbUpId,
            AwardClimbUpIds,
            RuleId,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "BeginTime" => Ok(GeneratedField::BeginTime),
                            "MaxClimbUpId" => Ok(GeneratedField::MaxClimbUpId),
                            "AwardClimbUpIds" => Ok(GeneratedField::AwardClimbUpIds),
                            "RuleId" => Ok(GeneratedField::RuleId),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WeeklyTowerRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.WeeklyTowerRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WeeklyTowerRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut begin_time__ = None;
                let mut max_climb_up_id__ = None;
                let mut award_climb_up_ids__ = None;
                let mut rule_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::BeginTime => {
                            if begin_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("BeginTime"));
                            }
                            begin_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxClimbUpId => {
                            if max_climb_up_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("MaxClimbUpId"));
                            }
                            max_climb_up_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AwardClimbUpIds => {
                            if award_climb_up_ids__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AwardClimbUpIds"));
                            }
                            award_climb_up_ids__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::RuleId => {
                            if rule_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RuleId"));
                            }
                            rule_id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WeeklyTowerRecord {
                    begin_time: begin_time__,
                    max_climb_up_id: max_climb_up_id__,
                    award_climb_up_ids: award_climb_up_ids__.unwrap_or_default(),
                    rule_id: rule_id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.WeeklyTowerRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WorldEventMap {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.event_map.is_empty() {
            len += 1;
        }
        if self.accept_count.is_some() {
            len += 1;
        }
        if self.last_update_time.is_some() {
            len += 1;
        }
        if self.refresh_time.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.WorldEventMap", len)?;
        if !self.event_map.is_empty() {
            struct_ser.serialize_field("EventMap", &self.event_map)?;
        }
        if let Some(v) = self.accept_count.as_ref() {
            struct_ser.serialize_field("AcceptCount", v)?;
        }
        if let Some(v) = self.last_update_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("LastUpdateTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.refresh_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("RefreshTime", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WorldEventMap {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EventMap",
            "AcceptCount",
            "LastUpdateTime",
            "RefreshTime",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EventMap,
            AcceptCount,
            LastUpdateTime,
            RefreshTime,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "EventMap" => Ok(GeneratedField::EventMap),
                            "AcceptCount" => Ok(GeneratedField::AcceptCount),
                            "LastUpdateTime" => Ok(GeneratedField::LastUpdateTime),
                            "RefreshTime" => Ok(GeneratedField::RefreshTime),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WorldEventMap;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.WorldEventMap")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WorldEventMap, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut event_map__ = None;
                let mut accept_count__ = None;
                let mut last_update_time__ = None;
                let mut refresh_time__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EventMap => {
                            if event_map__.is_some() {
                                return Err(serde::de::Error::duplicate_field("EventMap"));
                            }
                            event_map__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u32>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::AcceptCount => {
                            if accept_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("AcceptCount"));
                            }
                            accept_count__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastUpdateTime => {
                            if last_update_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("LastUpdateTime"));
                            }
                            last_update_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RefreshTime => {
                            if refresh_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("RefreshTime"));
                            }
                            refresh_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WorldEventMap {
                    event_map: event_map__.unwrap_or_default(),
                    accept_count: accept_count__,
                    last_update_time: last_update_time__,
                    refresh_time: refresh_time__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.WorldEventMap", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WorldNtfSyncPathNode {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.lists.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.WorldNtfSyncPathNode", len)?;
        if let Some(v) = self.lists.as_ref() {
            struct_ser.serialize_field("Lists", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WorldNtfSyncPathNode {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Lists",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Lists,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Lists" => Ok(GeneratedField::Lists),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WorldNtfSyncPathNode;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.WorldNtfSyncPathNode")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WorldNtfSyncPathNode, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut lists__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Lists => {
                            if lists__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Lists"));
                            }
                            lists__ = map_.next_value()?;
                        }
                    }
                }
                Ok(WorldNtfSyncPathNode {
                    lists: lists__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.WorldNtfSyncPathNode", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WorldQuestInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.finish_points.is_some() {
            len += 1;
        }
        if !self.rewards.is_empty() {
            len += 1;
        }
        if self.exceeding_points.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.WorldQuestInfo", len)?;
        if let Some(v) = self.finish_points.as_ref() {
            struct_ser.serialize_field("FinishPoints", v)?;
        }
        if !self.rewards.is_empty() {
            struct_ser.serialize_field("Rewards", &self.rewards)?;
        }
        if let Some(v) = self.exceeding_points.as_ref() {
            struct_ser.serialize_field("ExceedingPoints", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WorldQuestInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FinishPoints",
            "Rewards",
            "ExceedingPoints",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            FinishPoints,
            Rewards,
            ExceedingPoints,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "FinishPoints" => Ok(GeneratedField::FinishPoints),
                            "Rewards" => Ok(GeneratedField::Rewards),
                            "ExceedingPoints" => Ok(GeneratedField::ExceedingPoints),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WorldQuestInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.WorldQuestInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WorldQuestInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut finish_points__ = None;
                let mut rewards__ = None;
                let mut exceeding_points__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::FinishPoints => {
                            if finish_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FinishPoints"));
                            }
                            finish_points__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Rewards => {
                            if rewards__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Rewards"));
                            }
                            rewards__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::ExceedingPoints => {
                            if exceeding_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ExceedingPoints"));
                            }
                            exceeding_points__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WorldQuestInfo {
                    finish_points: finish_points__,
                    rewards: rewards__.unwrap_or_default(),
                    exceeding_points: exceeding_points__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.WorldQuestInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WorldReconnectStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::FastReconnect => "FastReconnect",
            Self::NewSession => "NewSession",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for WorldReconnectStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "FastReconnect",
            "NewSession",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WorldReconnectStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "FastReconnect" => Ok(WorldReconnectStatus::FastReconnect),
                    "NewSession" => Ok(WorldReconnectStatus::NewSession),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CameraSchemeCache {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.camera_scheme_dict.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.cameraSchemeCache", len)?;
        if !self.camera_scheme_dict.is_empty() {
            struct_ser.serialize_field("CameraSchemeDict", &self.camera_scheme_dict)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CameraSchemeCache {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CameraSchemeDict",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CameraSchemeDict,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CameraSchemeDict" => Ok(GeneratedField::CameraSchemeDict),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CameraSchemeCache;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.cameraSchemeCache")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CameraSchemeCache, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut camera_scheme_dict__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CameraSchemeDict => {
                            if camera_scheme_dict__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CameraSchemeDict"));
                            }
                            camera_scheme_dict__ = Some(
                                map_.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                    }
                }
                Ok(CameraSchemeCache {
                    camera_scheme_dict: camera_scheme_dict__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.cameraSchemeCache", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CameraSchemeInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.camera_pattern_type.is_some() {
            len += 1;
        }
        if self.camera_scheme_type.is_some() {
            len += 1;
        }
        if self.scheme_key.is_some() {
            len += 1;
        }
        if self.scheme_name.is_some() {
            len += 1;
        }
        if self.scheme_time.is_some() {
            len += 1;
        }
        if self.exposure.is_some() {
            len += 1;
        }
        if self.contrast.is_some() {
            len += 1;
        }
        if self.saturation.is_some() {
            len += 1;
        }
        if self.horizontal.is_some() {
            len += 1;
        }
        if self.vertical.is_some() {
            len += 1;
        }
        if self.angle.is_some() {
            len += 1;
        }
        if self.depth_tag.is_some() {
            len += 1;
        }
        if self.aperture.is_some() {
            len += 1;
        }
        if self.near_blend.is_some() {
            len += 1;
        }
        if self.far_blend.is_some() {
            len += 1;
        }
        if self.focus_tag.is_some() {
            len += 1;
        }
        if self.focus.is_some() {
            len += 1;
        }
        if self.world_time.is_some() {
            len += 1;
        }
        if self.is_head_follow.is_some() {
            len += 1;
        }
        if self.is_eye_follow.is_some() {
            len += 1;
        }
        if !self.show_entity_dicts.is_empty() {
            len += 1;
        }
        if !self.show_ui_dicts.is_empty() {
            len += 1;
        }
        if self.filter_path.is_some() {
            len += 1;
        }
        if self.id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.cameraSchemeInfo", len)?;
        if let Some(v) = self.camera_pattern_type.as_ref() {
            let v = CameraPatternType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("CameraPatternType", &v)?;
        }
        if let Some(v) = self.camera_scheme_type.as_ref() {
            let v = CameraSchemeType::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("CameraSchemeType", &v)?;
        }
        if let Some(v) = self.scheme_key.as_ref() {
            struct_ser.serialize_field("SchemeKey", v)?;
        }
        if let Some(v) = self.scheme_name.as_ref() {
            struct_ser.serialize_field("SchemeName", v)?;
        }
        if let Some(v) = self.scheme_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("SchemeTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.exposure.as_ref() {
            struct_ser.serialize_field("Exposure", v)?;
        }
        if let Some(v) = self.contrast.as_ref() {
            struct_ser.serialize_field("Contrast", v)?;
        }
        if let Some(v) = self.saturation.as_ref() {
            struct_ser.serialize_field("Saturation", v)?;
        }
        if let Some(v) = self.horizontal.as_ref() {
            struct_ser.serialize_field("Horizontal", v)?;
        }
        if let Some(v) = self.vertical.as_ref() {
            struct_ser.serialize_field("Vertical", v)?;
        }
        if let Some(v) = self.angle.as_ref() {
            struct_ser.serialize_field("Angle", v)?;
        }
        if let Some(v) = self.depth_tag.as_ref() {
            struct_ser.serialize_field("DepthTag", v)?;
        }
        if let Some(v) = self.aperture.as_ref() {
            struct_ser.serialize_field("Aperture", v)?;
        }
        if let Some(v) = self.near_blend.as_ref() {
            struct_ser.serialize_field("NearBlend", v)?;
        }
        if let Some(v) = self.far_blend.as_ref() {
            struct_ser.serialize_field("FarBlend", v)?;
        }
        if let Some(v) = self.focus_tag.as_ref() {
            struct_ser.serialize_field("FocusTag", v)?;
        }
        if let Some(v) = self.focus.as_ref() {
            struct_ser.serialize_field("Focus", v)?;
        }
        if let Some(v) = self.world_time.as_ref() {
            struct_ser.serialize_field("WorldTime", v)?;
        }
        if let Some(v) = self.is_head_follow.as_ref() {
            struct_ser.serialize_field("IsHeadFollow", v)?;
        }
        if let Some(v) = self.is_eye_follow.as_ref() {
            struct_ser.serialize_field("IsEyeFollow", v)?;
        }
        if !self.show_entity_dicts.is_empty() {
            struct_ser.serialize_field("ShowEntityDicts", &self.show_entity_dicts)?;
        }
        if !self.show_ui_dicts.is_empty() {
            struct_ser.serialize_field("ShowUIDicts", &self.show_ui_dicts)?;
        }
        if let Some(v) = self.filter_path.as_ref() {
            struct_ser.serialize_field("FilterPath", v)?;
        }
        if let Some(v) = self.id.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("Id", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CameraSchemeInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CameraPatternType",
            "CameraSchemeType",
            "SchemeKey",
            "SchemeName",
            "SchemeTime",
            "Exposure",
            "Contrast",
            "Saturation",
            "Horizontal",
            "Vertical",
            "Angle",
            "DepthTag",
            "Aperture",
            "NearBlend",
            "FarBlend",
            "FocusTag",
            "Focus",
            "WorldTime",
            "IsHeadFollow",
            "IsEyeFollow",
            "ShowEntityDicts",
            "ShowUIDicts",
            "FilterPath",
            "Id",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CameraPatternType,
            CameraSchemeType,
            SchemeKey,
            SchemeName,
            SchemeTime,
            Exposure,
            Contrast,
            Saturation,
            Horizontal,
            Vertical,
            Angle,
            DepthTag,
            Aperture,
            NearBlend,
            FarBlend,
            FocusTag,
            Focus,
            WorldTime,
            IsHeadFollow,
            IsEyeFollow,
            ShowEntityDicts,
            ShowUiDicts,
            FilterPath,
            Id,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CameraPatternType" => Ok(GeneratedField::CameraPatternType),
                            "CameraSchemeType" => Ok(GeneratedField::CameraSchemeType),
                            "SchemeKey" => Ok(GeneratedField::SchemeKey),
                            "SchemeName" => Ok(GeneratedField::SchemeName),
                            "SchemeTime" => Ok(GeneratedField::SchemeTime),
                            "Exposure" => Ok(GeneratedField::Exposure),
                            "Contrast" => Ok(GeneratedField::Contrast),
                            "Saturation" => Ok(GeneratedField::Saturation),
                            "Horizontal" => Ok(GeneratedField::Horizontal),
                            "Vertical" => Ok(GeneratedField::Vertical),
                            "Angle" => Ok(GeneratedField::Angle),
                            "DepthTag" => Ok(GeneratedField::DepthTag),
                            "Aperture" => Ok(GeneratedField::Aperture),
                            "NearBlend" => Ok(GeneratedField::NearBlend),
                            "FarBlend" => Ok(GeneratedField::FarBlend),
                            "FocusTag" => Ok(GeneratedField::FocusTag),
                            "Focus" => Ok(GeneratedField::Focus),
                            "WorldTime" => Ok(GeneratedField::WorldTime),
                            "IsHeadFollow" => Ok(GeneratedField::IsHeadFollow),
                            "IsEyeFollow" => Ok(GeneratedField::IsEyeFollow),
                            "ShowEntityDicts" => Ok(GeneratedField::ShowEntityDicts),
                            "ShowUIDicts" => Ok(GeneratedField::ShowUiDicts),
                            "FilterPath" => Ok(GeneratedField::FilterPath),
                            "Id" => Ok(GeneratedField::Id),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CameraSchemeInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.cameraSchemeInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CameraSchemeInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut camera_pattern_type__ = None;
                let mut camera_scheme_type__ = None;
                let mut scheme_key__ = None;
                let mut scheme_name__ = None;
                let mut scheme_time__ = None;
                let mut exposure__ = None;
                let mut contrast__ = None;
                let mut saturation__ = None;
                let mut horizontal__ = None;
                let mut vertical__ = None;
                let mut angle__ = None;
                let mut depth_tag__ = None;
                let mut aperture__ = None;
                let mut near_blend__ = None;
                let mut far_blend__ = None;
                let mut focus_tag__ = None;
                let mut focus__ = None;
                let mut world_time__ = None;
                let mut is_head_follow__ = None;
                let mut is_eye_follow__ = None;
                let mut show_entity_dicts__ = None;
                let mut show_ui_dicts__ = None;
                let mut filter_path__ = None;
                let mut id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CameraPatternType => {
                            if camera_pattern_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CameraPatternType"));
                            }
                            camera_pattern_type__ = map_.next_value::<::std::option::Option<CameraPatternType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::CameraSchemeType => {
                            if camera_scheme_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CameraSchemeType"));
                            }
                            camera_scheme_type__ = map_.next_value::<::std::option::Option<CameraSchemeType>>()?.map(|x| x as i32);
                        }
                        GeneratedField::SchemeKey => {
                            if scheme_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SchemeKey"));
                            }
                            scheme_key__ = map_.next_value()?;
                        }
                        GeneratedField::SchemeName => {
                            if scheme_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SchemeName"));
                            }
                            scheme_name__ = map_.next_value()?;
                        }
                        GeneratedField::SchemeTime => {
                            if scheme_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SchemeTime"));
                            }
                            scheme_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Exposure => {
                            if exposure__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Exposure"));
                            }
                            exposure__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Contrast => {
                            if contrast__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Contrast"));
                            }
                            contrast__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Saturation => {
                            if saturation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Saturation"));
                            }
                            saturation__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Horizontal => {
                            if horizontal__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Horizontal"));
                            }
                            horizontal__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Vertical => {
                            if vertical__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Vertical"));
                            }
                            vertical__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Angle => {
                            if angle__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Angle"));
                            }
                            angle__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DepthTag => {
                            if depth_tag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DepthTag"));
                            }
                            depth_tag__ = map_.next_value()?;
                        }
                        GeneratedField::Aperture => {
                            if aperture__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Aperture"));
                            }
                            aperture__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NearBlend => {
                            if near_blend__.is_some() {
                                return Err(serde::de::Error::duplicate_field("NearBlend"));
                            }
                            near_blend__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FarBlend => {
                            if far_blend__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FarBlend"));
                            }
                            far_blend__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FocusTag => {
                            if focus_tag__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FocusTag"));
                            }
                            focus_tag__ = map_.next_value()?;
                        }
                        GeneratedField::Focus => {
                            if focus__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Focus"));
                            }
                            focus__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WorldTime => {
                            if world_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("WorldTime"));
                            }
                            world_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::IsHeadFollow => {
                            if is_head_follow__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsHeadFollow"));
                            }
                            is_head_follow__ = map_.next_value()?;
                        }
                        GeneratedField::IsEyeFollow => {
                            if is_eye_follow__.is_some() {
                                return Err(serde::de::Error::duplicate_field("IsEyeFollow"));
                            }
                            is_eye_follow__ = map_.next_value()?;
                        }
                        GeneratedField::ShowEntityDicts => {
                            if show_entity_dicts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShowEntityDicts"));
                            }
                            show_entity_dicts__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::ShowUiDicts => {
                            if show_ui_dicts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShowUIDicts"));
                            }
                            show_ui_dicts__ = Some(
                                map_.next_value::<std::collections::HashMap<::pbjson::private::NumberDeserialize<u64>, _>>()?
                                    .into_iter().map(|(k,v)| (k.0, v)).collect()
                            );
                        }
                        GeneratedField::FilterPath => {
                            if filter_path__.is_some() {
                                return Err(serde::de::Error::duplicate_field("FilterPath"));
                            }
                            filter_path__ = map_.next_value()?;
                        }
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(CameraSchemeInfo {
                    camera_pattern_type: camera_pattern_type__,
                    camera_scheme_type: camera_scheme_type__,
                    scheme_key: scheme_key__,
                    scheme_name: scheme_name__,
                    scheme_time: scheme_time__,
                    exposure: exposure__,
                    contrast: contrast__,
                    saturation: saturation__,
                    horizontal: horizontal__,
                    vertical: vertical__,
                    angle: angle__,
                    depth_tag: depth_tag__,
                    aperture: aperture__,
                    near_blend: near_blend__,
                    far_blend: far_blend__,
                    focus_tag: focus_tag__,
                    focus: focus__,
                    world_time: world_time__,
                    is_head_follow: is_head_follow__,
                    is_eye_follow: is_eye_follow__,
                    show_entity_dicts: show_entity_dicts__.unwrap_or_default(),
                    show_ui_dicts: show_ui_dicts__.unwrap_or_default(),
                    filter_path: filter_path__,
                    id: id__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.cameraSchemeInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CameraSelectSchemeCache {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.camera_scheme_cache.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.cameraSelectSchemeCache", len)?;
        if let Some(v) = self.camera_scheme_cache.as_ref() {
            struct_ser.serialize_field("CameraSchemeCache", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CameraSelectSchemeCache {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CameraSchemeCache",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CameraSchemeCache,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "CameraSchemeCache" => Ok(GeneratedField::CameraSchemeCache),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CameraSelectSchemeCache;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.cameraSelectSchemeCache")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CameraSelectSchemeCache, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut camera_scheme_cache__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CameraSchemeCache => {
                            if camera_scheme_cache__.is_some() {
                                return Err(serde::de::Error::duplicate_field("CameraSchemeCache"));
                            }
                            camera_scheme_cache__ = map_.next_value()?;
                        }
                    }
                }
                Ok(CameraSelectSchemeCache {
                    camera_scheme_cache: camera_scheme_cache__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.cameraSelectSchemeCache", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for HttpCachePhotoInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.http_cache_photo_info_dict.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.httpCachePhotoInfo", len)?;
        if !self.http_cache_photo_info_dict.is_empty() {
            struct_ser.serialize_field("HttpCachePhotoInfoDict", &self.http_cache_photo_info_dict)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for HttpCachePhotoInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "HttpCachePhotoInfoDict",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            HttpCachePhotoInfoDict,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "HttpCachePhotoInfoDict" => Ok(GeneratedField::HttpCachePhotoInfoDict),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = HttpCachePhotoInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.httpCachePhotoInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<HttpCachePhotoInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut http_cache_photo_info_dict__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::HttpCachePhotoInfoDict => {
                            if http_cache_photo_info_dict__.is_some() {
                                return Err(serde::de::Error::duplicate_field("HttpCachePhotoInfoDict"));
                            }
                            http_cache_photo_info_dict__ = Some(
                                map_.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                    }
                }
                Ok(HttpCachePhotoInfo {
                    http_cache_photo_info_dict: http_cache_photo_info_dict__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.httpCachePhotoInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PhotoInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.temp_photo_keys.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.photoInfo", len)?;
        if !self.temp_photo_keys.is_empty() {
            struct_ser.serialize_field("TempPhotoKeys", &self.temp_photo_keys)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PhotoInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TempPhotoKeys",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TempPhotoKeys,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TempPhotoKeys" => Ok(GeneratedField::TempPhotoKeys),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PhotoInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.photoInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PhotoInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut temp_photo_keys__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TempPhotoKeys => {
                            if temp_photo_keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TempPhotoKeys"));
                            }
                            temp_photo_keys__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(PhotoInfo {
                    temp_photo_keys: temp_photo_keys__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.photoInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SchemeInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.scheme_info_keys.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.schemeInfo", len)?;
        if !self.scheme_info_keys.is_empty() {
            struct_ser.serialize_field("SchemeInfoKeys", &self.scheme_info_keys)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SchemeInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SchemeInfoKeys",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SchemeInfoKeys,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "SchemeInfoKeys" => Ok(GeneratedField::SchemeInfoKeys),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SchemeInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.schemeInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SchemeInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scheme_info_keys__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SchemeInfoKeys => {
                            if scheme_info_keys__.is_some() {
                                return Err(serde::de::Error::duplicate_field("SchemeInfoKeys"));
                            }
                            scheme_info_keys__ = Some(map_.next_value()?);
                        }
                    }
                }
                Ok(SchemeInfo {
                    scheme_info_keys: scheme_info_keys__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.schemeInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TempPhotoCache {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.temp_photo_cache_dict.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.tempPhotoCache", len)?;
        if !self.temp_photo_cache_dict.is_empty() {
            struct_ser.serialize_field("TempPhotoCacheDict", &self.temp_photo_cache_dict)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TempPhotoCache {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TempPhotoCacheDict",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TempPhotoCacheDict,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "TempPhotoCacheDict" => Ok(GeneratedField::TempPhotoCacheDict),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TempPhotoCache;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.tempPhotoCache")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TempPhotoCache, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut temp_photo_cache_dict__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TempPhotoCacheDict => {
                            if temp_photo_cache_dict__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TempPhotoCacheDict"));
                            }
                            temp_photo_cache_dict__ = Some(
                                map_.next_value::<std::collections::HashMap<_, _>>()?
                            );
                        }
                    }
                }
                Ok(TempPhotoCache {
                    temp_photo_cache_dict: temp_photo_cache_dict__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.tempPhotoCache", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TempPhotoCacheInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.temp_photo.is_some() {
            len += 1;
        }
        if self.temp_ori_photo.is_some() {
            len += 1;
        }
        if self.temp_thumb_photo.is_some() {
            len += 1;
        }
        if self.shot_time.is_some() {
            len += 1;
        }
        if self.shot_time_str.is_some() {
            len += 1;
        }
        if self.shot_place.is_some() {
            len += 1;
        }
        if self.decorate_data.is_some() {
            len += 1;
        }
        if self.height.is_some() {
            len += 1;
        }
        if self.width.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.tempPhotoCacheInfo", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.temp_photo.as_ref() {
            struct_ser.serialize_field("TempPhoto", v)?;
        }
        if let Some(v) = self.temp_ori_photo.as_ref() {
            struct_ser.serialize_field("TempOriPhoto", v)?;
        }
        if let Some(v) = self.temp_thumb_photo.as_ref() {
            struct_ser.serialize_field("TempThumbPhoto", v)?;
        }
        if let Some(v) = self.shot_time.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("ShotTime", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.shot_time_str.as_ref() {
            struct_ser.serialize_field("ShotTimeStr", v)?;
        }
        if let Some(v) = self.shot_place.as_ref() {
            struct_ser.serialize_field("ShotPlace", v)?;
        }
        if let Some(v) = self.decorate_data.as_ref() {
            struct_ser.serialize_field("DecorateData", v)?;
        }
        if let Some(v) = self.height.as_ref() {
            struct_ser.serialize_field("Height", v)?;
        }
        if let Some(v) = self.width.as_ref() {
            struct_ser.serialize_field("Width", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TempPhotoCacheInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "TempPhoto",
            "TempOriPhoto",
            "TempThumbPhoto",
            "ShotTime",
            "ShotTimeStr",
            "ShotPlace",
            "DecorateData",
            "Height",
            "Width",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            TempPhoto,
            TempOriPhoto,
            TempThumbPhoto,
            ShotTime,
            ShotTimeStr,
            ShotPlace,
            DecorateData,
            Height,
            Width,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "TempPhoto" => Ok(GeneratedField::TempPhoto),
                            "TempOriPhoto" => Ok(GeneratedField::TempOriPhoto),
                            "TempThumbPhoto" => Ok(GeneratedField::TempThumbPhoto),
                            "ShotTime" => Ok(GeneratedField::ShotTime),
                            "ShotTimeStr" => Ok(GeneratedField::ShotTimeStr),
                            "ShotPlace" => Ok(GeneratedField::ShotPlace),
                            "DecorateData" => Ok(GeneratedField::DecorateData),
                            "Height" => Ok(GeneratedField::Height),
                            "Width" => Ok(GeneratedField::Width),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TempPhotoCacheInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.tempPhotoCacheInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TempPhotoCacheInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut temp_photo__ = None;
                let mut temp_ori_photo__ = None;
                let mut temp_thumb_photo__ = None;
                let mut shot_time__ = None;
                let mut shot_time_str__ = None;
                let mut shot_place__ = None;
                let mut decorate_data__ = None;
                let mut height__ = None;
                let mut width__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = map_.next_value()?;
                        }
                        GeneratedField::TempPhoto => {
                            if temp_photo__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TempPhoto"));
                            }
                            temp_photo__ = map_.next_value()?;
                        }
                        GeneratedField::TempOriPhoto => {
                            if temp_ori_photo__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TempOriPhoto"));
                            }
                            temp_ori_photo__ = map_.next_value()?;
                        }
                        GeneratedField::TempThumbPhoto => {
                            if temp_thumb_photo__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TempThumbPhoto"));
                            }
                            temp_thumb_photo__ = map_.next_value()?;
                        }
                        GeneratedField::ShotTime => {
                            if shot_time__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShotTime"));
                            }
                            shot_time__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ShotTimeStr => {
                            if shot_time_str__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShotTimeStr"));
                            }
                            shot_time_str__ = map_.next_value()?;
                        }
                        GeneratedField::ShotPlace => {
                            if shot_place__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ShotPlace"));
                            }
                            shot_place__ = map_.next_value()?;
                        }
                        GeneratedField::DecorateData => {
                            if decorate_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("DecorateData"));
                            }
                            decorate_data__ = map_.next_value()?;
                        }
                        GeneratedField::Height => {
                            if height__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Height"));
                            }
                            height__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Width => {
                            if width__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Width"));
                            }
                            width__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(TempPhotoCacheInfo {
                    id: id__,
                    temp_photo: temp_photo__,
                    temp_ori_photo: temp_ori_photo__,
                    temp_thumb_photo: temp_thumb_photo__,
                    shot_time: shot_time__,
                    shot_time_str: shot_time_str__,
                    shot_place: shot_place__,
                    decorate_data: decorate_data__,
                    height: height__,
                    width: width__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.tempPhotoCacheInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WorldEventData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.target_num.is_some() {
            len += 1;
        }
        if self.award.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.worldEventData", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("Id", v)?;
        }
        if let Some(v) = self.target_num.as_ref() {
            struct_ser.serialize_field("TargetNum", v)?;
        }
        if let Some(v) = self.award.as_ref() {
            struct_ser.serialize_field("Award", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WorldEventData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "Id",
            "TargetNum",
            "Award",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            TargetNum,
            Award,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "Id" => Ok(GeneratedField::Id),
                            "TargetNum" => Ok(GeneratedField::TargetNum),
                            "Award" => Ok(GeneratedField::Award),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WorldEventData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.worldEventData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WorldEventData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut target_num__ = None;
                let mut award__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Id"));
                            }
                            id__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TargetNum => {
                            if target_num__.is_some() {
                                return Err(serde::de::Error::duplicate_field("TargetNum"));
                            }
                            target_num__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Award => {
                            if award__.is_some() {
                                return Err(serde::de::Error::duplicate_field("Award"));
                            }
                            award__ = 
                                map_.next_value::<::std::option::Option<::pbjson::private::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                    }
                }
                Ok(WorldEventData {
                    id: id__,
                    target_num: target_num__,
                    award: award__,
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.worldEventData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for WorldQuestList {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.quest_list.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("blueprotobuf_package.worldQuestList", len)?;
        if !self.quest_list.is_empty() {
            struct_ser.serialize_field("QuestList", &self.quest_list)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for WorldQuestList {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "QuestList",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            QuestList,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "QuestList" => Ok(GeneratedField::QuestList),
                            _ => Err(serde::de::Error::unknown_field(value, FIELDS)),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = WorldQuestList;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct blueprotobuf_package.worldQuestList")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<WorldQuestList, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut quest_list__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::QuestList => {
                            if quest_list__.is_some() {
                                return Err(serde::de::Error::duplicate_field("QuestList"));
                            }
                            quest_list__ = 
                                Some(map_.next_value::<Vec<::pbjson::private::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                    }
                }
                Ok(WorldQuestList {
                    quest_list: quest_list__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("blueprotobuf_package.worldQuestList", FIELDS, GeneratedVisitor)
    }
}
